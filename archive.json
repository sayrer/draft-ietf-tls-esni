{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-03-08T18:55:27.451499+00:00",
  "repo": "tlswg/draft-ietf-tls-esni",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "needs WG discussion",
      "description": "",
      "color": "c5def5"
    },
    {
      "name": "ready-for-text",
      "description": "",
      "color": "f9d0c4"
    }
  ],
  "issues": [
    {
      "number": 5,
      "id": "MDU6SXNzdWUzMjI0NjYzMDg=",
      "title": "Add an optional \"fronting SNI\" to the DNS record",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/5",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In most cases, this can be absent, but it might help with deployment to have SNI in every handshake.  Controlling the value of the SNI used (or more to the point, suggesting a safe value), might give clients a better way to avoid notice.",
      "createdAt": "2018-05-12T00:16:10Z",
      "updatedAt": "2018-05-12T15:35:30Z",
      "closedAt": "2018-05-12T15:35:30Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed",
          "createdAt": "2018-05-12T15:35:30Z",
          "updatedAt": "2018-05-12T15:35:30Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWUzMjI0NjY3MjQ=",
      "title": "Do you need the nonce?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/6",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "You are mixing ClientHello.random in.  That would seem to be sufficient.  From that you can generate the AEAD nonce and key as though this were record protection.\r\n\r\n```\r\nesni_secret = HKDF-Extract(0, Z)\r\nk = HKDF-Expand-Label(esni_secret, \"esni key\", ClientHello.random, L)\r\niv = HKDF-Expand-Label(esni_secret, \"esni key\", ClientHello.random, L)\r\n```\r\n\r\nWe don't need another reason for people to complain about exposing the random number generator state to the network.",
      "createdAt": "2018-05-12T00:20:54Z",
      "updatedAt": "2018-05-12T13:13:33Z",
      "closedAt": "2018-05-12T13:13:33Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If servers choose to use the same ESNI and semi-static key, not generating and including a nonce could lead to nonce-reuse for 0-RTT data. We talked about just prohibiting this sort of key sharing for servers, though it's good to have a client-side defense against it.",
          "createdAt": "2018-05-12T04:03:57Z",
          "updatedAt": "2018-05-12T04:03:57Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWUzMjI0NjcyNDA=",
      "title": "Where do the TXT records go?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/7",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In DNS, yes, but under what name?  \r\n\r\nI suggest at _esni.<domain>.  Usage of TXT and underscore names is now considered an acceptable way to deploy new features.  It also deploys more reliably than a new RRtype.",
      "createdAt": "2018-05-12T00:26:13Z",
      "updatedAt": "2018-05-12T15:36:25Z",
      "closedAt": "2018-05-12T15:36:25Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I would like to note that the use of RRtype would be a no-go for many operators, because you cannot delegate an APEX name.\r\n\r\nMany websites are served by their APEX names. It is common for a web-site publisher to choose different hosting providers for HTTP (i.e. CDN) and DNS. This is especially the case with CDNs relying on anycast.\r\n\r\nThese facts lead to the conclusion that if we choose RRtype as the method, there would often be cases where the DNS record of the ESNIKey and the TLS server would be required to be operated by different entities.\r\n\r\nThis essentially means that there would be high risk of ESNIKey record and the key in TLS server becoming out-of-sync for large amount of deployments.\r\n\r\nHaving such _additional_ risk in operation for a nice-to-have feature like ESNI would be unacceptable for many operators.\r\n\r\nPS. Using TXT records with prefix sounds good to me because we can use CNAME to delegate the ESNIKey when an APEX name is used to serve the website.",
          "createdAt": "2018-05-12T05:42:56Z",
          "updatedAt": "2018-05-12T06:23:23Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: we went with TXT.",
          "createdAt": "2018-05-12T15:36:24Z",
          "updatedAt": "2018-05-12T15:36:24Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWUzMjI0Njc1NTY=",
      "title": "Explain the DNS layout a little more clearly",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/8",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When I lookup `hidden.example`, I would expect to have an A (or AAAA) for `hidden.example`, a TXT for `_esni.hidden.example` and nothing more.  \r\n\r\nThe key idea is that all hidden servers that share a front would return the same A records.  You need to say that.",
      "createdAt": "2018-05-12T00:29:21Z",
      "updatedAt": "2018-05-12T15:35:38Z",
      "closedAt": "2018-05-12T15:35:38Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed",
          "createdAt": "2018-05-12T15:35:38Z",
          "updatedAt": "2018-05-12T15:35:38Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWUzMjI0ODY4ODQ=",
      "title": "sending certificate chain along with ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/10",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Thank you for working on the draft. I can't be more happy to see someone willing to lead the community towards having a particular ESNI solution.\r\n\r\nConsidering the fact that omitting the certificate chain and the signature was [one of the options discussed in my draft](https://tools.ietf.org/html/draft-kazuho-protected-sni-00#section-5.3) (was originally suggested by @siyengar), I am happy to support the proposal and am willing to implement it.\r\n\r\nOTOH, please let me argue here for sending the certificate-chain along with the ESNIKey.\r\n\r\nWhile I agree that there is no huge difference in terms of security, there are benefits related to performance in sending the certificate chain along with the ESNIKey.\r\n\r\nIn QUIC, we are discussing how many packets a server can send before the client's address is validated. This is because sending packets to an non-validated address is an vector for amplification attacks. We can resolve the issue by sending the certificate chain along with the ESNIKey and using an encrypted variant of Cached Certificate Extension.\r\n\r\nWe also revive the possibility of doing 0-RTT using semi-static key, because the key will be signed by the certificate.\r\n\r\nI think that providing performance improvement might give people more incentive to start using ESNI.",
      "createdAt": "2018-05-12T06:18:51Z",
      "updatedAt": "2018-05-14T13:16:57Z",
      "closedAt": "2018-05-14T13:16:57Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: you make a good point here (and thanks for doing your original draft; as you can see,  stole a lot of ideas!) and I think it's something we should look into\r\n\r\nI would argue for keeping these two mechanisms separate, for a few reasons:\r\n\r\n1. The cached_info indication would be consumed by the hidden server, not the fronting server, so you have the issues I note in Appendix A.\r\n\r\n2. If we ultimately want to do 0-RTT priming (which seems interesting) we will likely want different keys with different lifetimes.\r\n\r\n3. Not every hidden server may want to support cached_info and so it might make it harder to get wide ESNI deployment.\r\n\r\nIn line with point 3, I think it may be easier to experiment with the simpler mechanism, because we can easily change the semantics to be the ones you propose if we need to, given that the extension is encrypted.\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2018-05-12T15:50:10Z",
          "updatedAt": "2018-05-12T15:50:10Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr Thank you for your comments.\r\n\r\n> I would argue for keeping these two mechanisms separate, for a few reasons:\r\n> \r\n> 1. The cached_info indication would be consumed by the hidden server, not the fronting server, so you have the issues I note in Appendix A.\r\n> \r\n> 2. If we ultimately want to do 0-RTT priming (which seems interesting) we will likely want different keys with different lifetimes.\r\n> \r\n> 3. Not every hidden server may want to support cached_info and so it might make it harder to get wide ESNI deployment.\r\n> \r\n> In line with point 3, I think it may be easier to experiment with the simpler mechanism, because we can easily change the semantics to be the ones you propose if we need to, given that the extension is encrypted.\r\n\r\nI would argue that these three concerns could be resolved by sending the certificate as an optional feature (as well as the 0-RTT a flag in the ESNIKey structure).\r\n\r\nBut having that said, it really depends on if client and resolver developers want to implement. I also understand that a small step is a good thing.\r\n\r\nPlease feel free to close the issue (or float it around if you think we might revisit).\r\n\r\nOTOH, having an `extensions` field might be always a good idea.",
          "createdAt": "2018-05-12T22:17:47Z",
          "updatedAt": "2018-05-12T22:17:47Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, you should remember that cached-info will reveal the identity of the server as effectively as SNI.\r\n\r\nI think that I agree with ekr here: priming clients with certificates is valuable, as is priming them for 0-RTT, but both require\r\n\r\nI think that protecting ALPN is of far less interest.  Also, as ekr observes, the lifetime for these keys might be dramatically different.  All in all, that makes me lean more toward the piecemeal approach that this draft suggests, as opposed to the \"just encrypt extensions\" approach that Richard considered.",
          "createdAt": "2018-05-12T23:30:06Z",
          "updatedAt": "2018-05-12T23:30:06Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> FWIW, you should remember that cached-info will reveal the identity of the server as effectively as SNI.\r\n\r\nWhat I am arguing for is \"an encrypted variant of Cached Certificate Extension\", which is sent by client using the ESNIKey.",
          "createdAt": "2018-05-13T00:09:56Z",
          "updatedAt": "2018-05-13T00:09:56Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think that protecting ALPN is of far less interest. Also, as ekr observes, the lifetime for these keys might be dramatically different. All in all, that makes me lean more toward the piecemeal approach that this draft suggests, as opposed to the \"just encrypt extensions\" approach that Richard considered.\r\n\r\nI agree. Considering the fact that sending the certificate-chain does not improve security, it can be an option that can be added later as an extension.\r\n\r\nDo you think that it would generally be a good idea to have an extensions slot in ESNIKey? I would assume so considering the fact that we now have extensions field in most of the TLS handshake messages.",
          "createdAt": "2018-05-13T00:21:24Z",
          "updatedAt": "2018-05-13T00:21:24Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think we need extensions.  If we miss something, we can add another extension.  We had extensions in (the unencrypted) SNI, and they ended up being unused and unusable eventually.  And there was a clear intended use for those even.",
          "createdAt": "2018-05-13T10:04:20Z",
          "updatedAt": "2018-05-13T10:04:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we might be having a confusion here.\r\n\r\nWhat I am arguing for is adding an extensions slot to ESNIKey, which is currently defined as:\r\n```\r\nstruct {\r\n    ESNIKeyShareEntry keys<4..2^16-1>;\r\n    CipherSuite cipher_suites<2..2^16-2>;\r\n    uint16 padded_length;\r\n} ESNIKeys;\r\n```\r\n\r\nThis structure is sent as a DNS record; you cannot extend it. If we want to add additional attributes, we would be forced to define a new DNS record that gets queried simultaneously. I think we do not want to do that.\r\n\r\nI totally agree that we do not need the capability to extend the EncryptedSNI structure.",
          "createdAt": "2018-05-13T12:31:20Z",
          "updatedAt": "2018-05-13T12:31:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ahh, I see what you mean.  Yeah, that's probably fine.",
          "createdAt": "2018-05-14T01:03:27Z",
          "updatedAt": "2018-05-14T01:03:27Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWUzMjI1MjkwMTM=",
      "title": "Proposed _esni TXT structure does not fit with DNS encodings",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/14",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The proposed DNS publication method for the key is sketched in section 4, Publishing the SNI Encryption Key. The proposed structure is\r\n~~~\r\n    struct {\r\n        ESNIKeyShareEntry keys<4..2^16-1>;\r\n        CipherSuite cipher_suites<2..2^16-2>;\r\n        uint16 padded_length;\r\n    } ESNIKeys;\r\n~~~\r\nThis can be problematic, given the constraints on TXT records. The practical length of the record payload is at most 255 bytes. The payload content is supposed to be text, which would suggest a base64 encoding, further reducing the available payload size to 189 bytes.\r\n\r\nI would suggest encoding just one key & one ciphersuite per record using base64 encoding, and using multiple records if necessary.",
      "createdAt": "2018-05-12T17:34:36Z",
      "updatedAt": "2018-05-13T03:18:44Z",
      "closedAt": "2018-05-13T03:18:44Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW RFC 4408 allows you to have multiple strings in the same TXT record to get around the limit https://tools.ietf.org/html/rfc4408#section-3.1.3\r\n\r\n> one key & one ciphersuite per record\r\n\r\nThis should probably be one key and _all_ cipher suites, since suites and keys are orthogonal to each other.",
          "createdAt": "2018-05-12T18:06:07Z",
          "updatedAt": "2018-05-12T18:06:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We assumed a suitable encoding that would not bump into this bound. Alessandro\u2019s suggestion above seems best.",
          "createdAt": "2018-05-12T18:25:27Z",
          "updatedAt": "2018-05-12T18:25:27Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I really have two concerns, the maximum length and the char requirement. The latter may be an harder issue. For example, can I set a TXT record to contain binary data if I use Amazon's Route 53 service?",
          "createdAt": "2018-05-12T18:28:01Z",
          "updatedAt": "2018-05-12T18:28:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we can work around the first with the concatenation suggestion. For the second, I assumed (perhaps incorrectly) any binary data was admissible. If we can\u2019t use binary data, then we can encode it easy enough. ",
          "createdAt": "2018-05-12T18:30:39Z",
          "updatedAt": "2018-05-12T18:30:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema Shall we close this?",
          "createdAt": "2018-05-13T00:33:13Z",
          "updatedAt": "2018-05-13T00:33:13Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed after merging PR #18",
          "createdAt": "2018-05-13T03:18:44Z",
          "updatedAt": "2018-05-13T03:18:44Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWUzMjI1Mjk1MjE=",
      "title": "Think of the smiley when forwarding ESNI values",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/15",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": " Appendix A, Communicating SNI to Hidden Server, specifies mechanisms for providing the hidden server with the selected SNI. We should not assume that the network connection between fronting and hidden is private. An obvious attack path is for the adversary to rent or hack servers in the same location as the hidden server. That's one more reason for not sending the SNI in clear text.",
      "createdAt": "2018-05-12T17:42:02Z",
      "updatedAt": "2018-05-22T18:34:46Z",
      "closedAt": "2018-05-22T18:34:46Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with this. Added some clarifying text.",
          "createdAt": "2018-05-12T18:31:42Z",
          "updatedAt": "2018-05-12T18:31:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema can we close this?",
          "createdAt": "2018-05-22T14:19:31Z",
          "updatedAt": "2018-05-22T14:19:31Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "EKR mentioned that the text of appendix A was clarified, but I don't see the clarification. The text says:\r\n~~~\r\nAs noted in Section 5.3, in Fronting Mode the hidden server will generally not know the true SNI. It is possible for the fronting server to communicate the true SNI to the hidden server, but at the cost of having that communication not be unmodified TLS 1.3. The basic idea is to have a shared key between the fronting server and the hidden server (this can be a symmetric key) and use it to send Z at the beginning of the connection before the ClientHello. The hidden server can then decrypt ESNI to recover the true SNI.\r\n\r\nAn obvious alternative here would be to have the fronting server forward the true SNI, but that would allow the fronting server to lie. In this design, the attacker would need to be able to find a Z which would expand into a key that would validly AEAD-encrypt a message of his choice, which should be intractable (Hand-waving alert!).\r\n~~~\r\nWhat I don't see is a mention that the network transmission between the fronting server and the hidden server  could be spied upon. I guess I need to propose a PR.\r\n",
          "createdAt": "2018-05-22T14:43:44Z",
          "updatedAt": "2018-05-22T14:43:44Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Given (a) RFC 3552 and (b) that we propose encrypting the value, I don't really think we need to say that this channel can be observed.",
          "createdAt": "2018-05-22T15:20:47Z",
          "updatedAt": "2018-05-22T15:20:47Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, OK. I suppose the requirement for encryption solves the issue.",
          "createdAt": "2018-05-22T18:34:46Z",
          "updatedAt": "2018-05-22T18:34:46Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWUzMjI1MzI1ODA=",
      "title": "Refresh ESNIKeys with HelloRetryRequest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/17",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Regarding:\r\n\r\n```\r\n- If the EncryptedSNI.label value does not correspond to any known\r\n  SNI encryption key, it MUST abort the connection with an\r\n  \"illegal_parameter\" alert.\r\n  [[OPEN ISSUE: We looked at ignoring the extension but concluded\r\n  this was better.]]\r\n```\r\nRather than aborting, would it make more sense for the server to (optionally?) send a fresh `ESNIKeys` as an extension as part of `HelloRetryRequest`? Example use case would be that for whatever reason (e.g. key compromise?) the server might want to discard a previously advertised `ESNIKeys` before it expires. Not sure if it's worth the added complexity though.\r\n\r\n(With some other changes it could also be used as an alternative way to publish a key at the cost of one round trip, but the usefulness there is probably limited)\r\n",
      "createdAt": "2018-05-12T18:26:58Z",
      "updatedAt": "2018-05-14T17:22:37Z",
      "closedAt": "2018-05-14T17:22:37Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought about this a bit, but making sure it doesn't allow cut-and-paste attacks seemed like it was going to need a lot of thought.",
          "createdAt": "2018-05-12T18:32:49Z",
          "updatedAt": "2018-05-12T18:32:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ghedo I don't think we should do this. It allows an on-path TCP proxy to inject a HRR, with a fresh ESNI key, and cause the client to reveal its SNI to that proxy. ",
          "createdAt": "2018-05-12T18:43:31Z",
          "updatedAt": "2018-05-12T18:43:31Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ugh, right. I guess the server could send the full DNS record, alongside DNSSEC signatures and chain, though that sounds like something that should be done independently from this spec.",
          "createdAt": "2018-05-14T17:22:37Z",
          "updatedAt": "2018-05-14T17:22:37Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWUzMjI1NDY2ODE=",
      "title": "Specify whether ESNI key is provided by hidden or by fronting server",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/19",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The text in section 4, Publishing the SNI Encryption Key, specifies that _if a client queries example.com, the ESNI TXT name is _esni.example.com_. That's fine, but suppose that the client queries \"hidden.example.com\". The client needs to learn that \"hidden.example.com\" is fronted by \"fronting.example.com\" -- per PR #18, the client will do that by obtaining an ALT-SVC record. Should the client get the ESNI key from \"_esni.hidden.example.com\", or from \"_esni.fronting.example.com\" ?",
      "createdAt": "2018-05-12T22:11:46Z",
      "updatedAt": "2018-05-22T14:49:12Z",
      "closedAt": "2018-05-22T14:49:12Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I think this is you.",
          "createdAt": "2018-05-12T23:23:18Z",
          "updatedAt": "2018-05-12T23:23:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#18 covers this.  Mostly.  It might pay to observe that the client does not look up and DNS records for the fronting service, it is just the case that all servers in the anonymity set point to the same IP address.  I made similar comments on #18.",
          "createdAt": "2018-05-12T23:25:00Z",
          "updatedAt": "2018-05-12T23:25:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @martinthomson here. I didn't see the client querying fronting.example.com.",
          "createdAt": "2018-05-12T23:38:42Z",
          "updatedAt": "2018-05-12T23:38:42Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That means all servers that share the same IP need to publish the same key. Are we confident that there is no synch issue during key rollover?",
          "createdAt": "2018-05-13T00:05:34Z",
          "updatedAt": "2018-05-13T00:05:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Servers can publish multiple ESNI keys with different labels in a record. That way they can retire one key and start using another as needed. Though it might be good (necessary?) to require clients to use one of those keys. ",
          "createdAt": "2018-05-13T00:30:04Z",
          "updatedAt": "2018-05-13T00:30:04Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Servers can publish multiple ESNI keys with different labels in a record. That way they can retire one key and start using another as needed.\r\n\r\nWhile that is possible, I am not sure if it would be the approach that would generally be used.\r\n\r\nThe issue is identical to the encryption key of the session tickets. In case of session tickets, we encrypt the ticket using one key, and send the identifier of the key along with the encrypted ticket.\r\n\r\nWhen we rollover the keys, we first deploy a new key to the server as well as keeping the old one alive for decryption only. And we retire the old key after certain amount of period that we become sure that it is no longer used.\r\n\r\nI'd assume that we can and will use the same approach for ESNIKeys.",
          "createdAt": "2018-05-14T05:29:19Z",
          "updatedAt": "2018-05-14T05:33:45Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "PS. therefore, it is possible to have just one label for the set of keys rather than having labels for each of the keys (assuming that we can remove the \"choose one at random\" rule). In that approach, a server will identify the key being used by looking at the `(label, group)` tuple.\r\n\r\nThe benefit will be that you will save the space of N-1 labels assuming that you are sending N key shares. Identification of the key on the server-side might seem complicated, but I actually think that it simplifies things, because a server operator is anyways expected to deploy the entire set of keys found in ESNIKeys at the same moment.",
          "createdAt": "2018-05-14T05:41:16Z",
          "updatedAt": "2018-05-14T05:51:07Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> therefore, it is possible to have just one label for the set of keys rather than having labels for each of the keys (assuming that we can remove the \"choose one at random\" rule)\r\n\r\nTo me it seems that this is necessary to prevent downgrade attack. Hence #24.",
          "createdAt": "2018-05-14T12:02:31Z",
          "updatedAt": "2018-05-14T12:02:31Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How do we prevent labels from becoming identifiers?",
          "createdAt": "2018-05-14T13:36:56Z",
          "updatedAt": "2018-05-14T13:36:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Labels as identifiers seem problematic in both approaches -- current and #24. ",
          "createdAt": "2018-05-14T13:43:30Z",
          "updatedAt": "2018-05-14T13:43:30Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you mind elaborating why label becomes an identifier? We state in the document that the probability of identifying the hidden server is 1/N where N is the number of the hosts belonging to the same set of hidden servers. A label represents that entire set.\r\n\r\nSo I do not think it is an issue.",
          "createdAt": "2018-05-14T15:23:44Z",
          "updatedAt": "2018-05-14T15:23:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Now that #43 is merged, which removes the label altogether, and we've added text describing the anonymity set for hidden servers, I think this issue is covered. @huitema do you agree?",
          "createdAt": "2018-05-22T14:21:18Z",
          "updatedAt": "2018-05-22T14:21:18Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The label issue is definitely covered. ",
          "createdAt": "2018-05-22T14:49:12Z",
          "updatedAt": "2018-05-22T14:49:12Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWUzMjI1NTIxMjg=",
      "title": "Client-side verification of ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/20",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The biggest concern from web-site operators will be the possibility of out-of-sync or broken ESNIKeys leading to service disruption.\r\n\r\nConsidering that, I propose having two attributes being added:\r\n* validity - we can borrow `notBefore` and `notAfter` from PKIX\r\n* checksum - something like 32-bits would be enough\r\n\r\nSeeing wired ESNIKeys will become a big issue especially if the clients accept ESNIKeys sent from low-quality resolvers / proxies (e.g. those in home routers).\r\n\r\nPS. One alternative approach would be to use HTTP (.well-known URI) as a transport of the semi-static key between the TLS server and the resolver. Then, we can use the vocabulary of HTTP to implement client-side verification.",
      "createdAt": "2018-05-13T00:06:15Z",
      "updatedAt": "2018-05-14T16:04:43Z",
      "closedAt": "2018-05-14T16:04:43Z",
      "comments": []
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWUzMjI3OTQ4ODI=",
      "title": "wildcard delegations to hidden server",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/25",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current text says:\r\n> If the serialized ServerNameList is longer than ESNIKeys.padded_length, the client MUST NOT use\r\nthe \"encrypted_server_name\" extension.\r\n\r\nHowever, I am not sure if this is the desired behavior. I would rather suggest encrypting even when the hostname exceeds the padded_length. Having some protection is better than none.\r\n\r\nThe issue is that in certain deployments it is impossible to guess what the maximum length of the hostname will be. Consider `*.github.io`. It uses a wildcard certificate. Anybody can add a new hostname of any length by creating a new Github account (it might be true that Github some limitation on the length, but that does not necessarily mean that Github shares the maximum length information with the fronting CDN, assuming that it uses a CDN).",
      "createdAt": "2018-05-14T12:27:23Z",
      "updatedAt": "2018-06-21T13:19:04Z",
      "closedAt": "2018-06-21T13:19:04Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I have filed #26 that fixes another issue (it's just a clarification of an open issue) related to wildcard delegation.",
          "createdAt": "2018-05-14T12:33:38Z",
          "updatedAt": "2018-05-14T12:33:38Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Technically, it is possible to guess the maximum length of the hostname, as that maximum textual representation length is defined as 253 bytes per RFC 1034.",
          "createdAt": "2018-05-16T06:24:06Z",
          "updatedAt": "2018-05-16T06:24:06Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. So the question is if a CDN that has a wildcard mapping needs to set `padded_length` to 253 (since current text is a MUST NOT for sending a server name longer than the padded_length), or if we should introduce a different rule.",
          "createdAt": "2018-05-16T12:16:10Z",
          "updatedAt": "2018-05-16T12:16:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How about something like:\r\n\r\npadded_length : The length to pad the ServerNameList value to prior to encryption. This value SHOULD be set to the largest ServerNameList the fronting server expects to support rounded up the nearest multiple of 16. If the fronting server supports wildcard names, it SHOULD set this value to 256.",
          "createdAt": "2018-05-16T18:10:58Z",
          "updatedAt": "2018-05-16T18:10:58Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi Thank you for the suggestion.\r\n\r\nI was feeling uneasy (and am still feeling a bit) about requiring the client to send an ESNI extension as large as ~300 bytes, assuming that CDN's would have at least one wildcard mappings.\r\n\r\nBut it's about the first packet sent from the client, and we typically have enough room even when 0-RTT data is involved. So I think that we can live with that.",
          "createdAt": "2018-05-25T05:42:35Z",
          "updatedAt": "2018-05-25T05:42:35Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "To be closed by #48.",
          "createdAt": "2018-05-26T05:09:23Z",
          "updatedAt": "2018-05-26T05:09:23Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #48.",
          "createdAt": "2018-06-21T13:19:04Z",
          "updatedAt": "2018-06-21T13:19:04Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWUzMjI4MjQ2NjI=",
      "title": "Client and server ESNI key selection",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/27",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Doing so doesn't allow a server to gracefully generate new ESNI keys and retire old ones. We should mandate that clients always choose the first ESNI key for which they have group support. If we adopt #24, where servers lookup keys with a (label, group) -> key mapping, should we also require that each label have the same groups? ",
      "createdAt": "2018-05-14T13:48:27Z",
      "updatedAt": "2018-07-02T14:17:59Z",
      "closedAt": "2018-07-02T14:17:59Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho what do you think?",
          "createdAt": "2018-05-14T13:49:00Z",
          "updatedAt": "2018-05-14T13:49:00Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not sure what you mean by \"doing so\", but the model I expect is something like following assuming that we adopt #24.\r\n\r\n* the fronting server generates a new ESNIKeys and pushes it to DNS server every 1 hour\r\n  * TTL will be set to 5 minutes ~~`not_after` - now~~<sup>1</sup>\r\n* the fronting server will accept the following keys to be used in the EncryptedSNI extension:\r\n  * the key for the current hour\r\n  * the key for the previous hour, for the first 10 minutes of every hour\r\n\r\nA ESNIKeys record can contain multiple keys belonging to different groups, but not belonging to the same group. So there is no ambiguity by specifying the key using (label, group).\r\n\r\nThe server can add a new Named Group or retire one when it generates a new ESNIKeys.\r\n\r\n[1] updated to reflect the fact that we can only use a constant TTL in the standard way of DNS server synchronization (i.e. DNS zone transfer) (02:47UTC May 15 2018)",
          "createdAt": "2018-05-14T15:15:13Z",
          "updatedAt": "2018-05-15T02:47:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems perfectly fine. But it does mean that there exists only one key per group at any given point in time. Is that a restriction we are comfortable with?",
          "createdAt": "2018-05-14T15:18:39Z",
          "updatedAt": "2018-05-14T15:18:39Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> That seems perfectly fine. But it does mean that there exists only one key per group at any given point in time. \r\n\r\nI don't think so. A DNS server can send different ESNIKeys at the same hour using short TTL (e.g. 60 seconds) in response to different queries (a.k.a. round-robin DNS).",
          "createdAt": "2018-05-14T15:20:58Z",
          "updatedAt": "2018-05-14T15:20:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, I mean within a single record. ",
          "createdAt": "2018-05-14T15:21:46Z",
          "updatedAt": "2018-05-14T15:21:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I am comfortable with not having that. You can only have a handful of keys in ESNIKeys anyways.\r\n\r\nI'd assume that either one would be enough or we would need a way to distribute more than just a handful, for which we can use round-robin.",
          "createdAt": "2018-05-14T15:26:29Z",
          "updatedAt": "2018-05-14T15:26:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM. We should add this rationale as text to the DNS record section. ",
          "createdAt": "2018-05-14T15:29:09Z",
          "updatedAt": "2018-05-14T15:29:09Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that TTL suffices here.",
          "createdAt": "2018-05-15T01:04:22Z",
          "updatedAt": "2018-05-15T01:04:22Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson FWIW, `not_after` is now in master. We can certainly discuss about the necessity, but you might want to see the debate on #23.",
          "createdAt": "2018-05-15T05:05:23Z",
          "updatedAt": "2018-05-15T05:05:23Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho I think your point in the PR is quite valid. However it's probably worth noting that having explicit not_before / not_after that the client has to validate, is likely to make it very difficult, if not impossible, to deploy very-short-lived keys (say, in the order of a few hours), due to the fact that a significant portion of clients have shitty clocks (https://ai.google/research/pubs/pub46359), which affects forward secrecy.\r\n\r\nMaybe it should be noted in the spec as an appendix or something.",
          "createdAt": "2018-05-22T17:57:46Z",
          "updatedAt": "2018-05-22T17:57:46Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmmm, thinking about this some more. In the \"split brain\" case @kazuho described in #23, the not_after is used to avoid having clients send an ESNI encrypted with an old key (as fetched from an out-of-date DNS server), to a TLS server that might have already switched to a new key (thus causing the connection to break).\r\n\r\nSo i'm guessing what happens is that the client would fallback to plaintext SNI if the key it fetched from DNS is expired. Though it seems to me this fallback could be dangerous for the client since they would end up exposing the SNI, but I can't come up with a practical way to exploit this (could be dependent on the specific deployment I guess).\r\n\r\nWhether this is something worth fixing is a different question, but an alternative to fix the split brain problem would be for the TLS server to somehow make sure the new key has been received by the DNS server, before discarding the old one.\r\n\r\nDid I understand the problem you described in #23 correctly @kazuho ?",
          "createdAt": "2018-05-22T20:18:23Z",
          "updatedAt": "2018-05-22T20:18:23Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@ghedo Thank you for your comments.\r\n\r\n> I think your point in the PR is quite valid. However it's probably worth noting that having explicit not_before / not_after that the client has to validate, is likely to make it very difficult, if not impossible, to deploy very-short-lived keys (say, in the order of a few hours), due to the fact that a significant portion of clients have shitty clocks (https://ai.google/research/pubs/pub46359), which affects forward secrecy.\r\n\r\nI think you are correct in stating that the ESNIKeys cannot have a very short lifetime. However, I would like to argue that the fact does not prevent server operators from rotating the keys frequently.\r\n\r\nServer operators can rotate the keys at the speed they like, as well as retiring them from the servers in any way.\r\n\r\n> So i'm guessing what happens is that the client would fallback to plaintext SNI if the key it fetched from DNS is expired. Though it seems to me this fallback could be dangerous for the client since they would end up exposing the SNI, but I can't come up with a practical way to exploit this (could be dependent on the specific deployment I guess).\r\n\r\nI agree with what happens.\r\n\r\nIn my view, ESNI is opportunistic encryption in sense that the unencrypted hostname is used when the ESNI resource record fails to reach the client (including the case of a middlebox dropping it intentionally).\r\n\r\nI would argue that using SNI in case of receiving an expired ESNI record is one of the failure modes in distributing the correct resource record. And therefore, I do not think that it is a security concern.\r\n\r\n> Whether this is something worth fixing is a different question, but an alternative to fix the split brain problem would be for the TLS server to somehow make sure the new key has been received by the DNS server, before discarding the old one.\r\n\r\nThat is correct. However, I fear that having such a requirement hinders us from using existing DNS deployments, because DNS authoritative servers are designed to favor availability over consistency, whereas in our case without `not_after`, we need consistency over availability.",
          "createdAt": "2018-05-23T02:02:02Z",
          "updatedAt": "2018-05-23T02:02:02Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Server operators can rotate the keys at the speed they like, as well as retiring them from the servers in any way.\r\n\r\nI didn't realize that was possible (that is, I kind of assumed servers would have to keep the key around until the not_after expired, but it's not actually written anywhere). In that case fine, though it might be worth clarifying.\r\n\r\nThe other concern I had was risking of turning this into another OCSP (where network failure and attack basically look the same so clients end up ignoring both), but I guess that with DoH, DPRIVE and DNSSEC an attack here is much harder to pull off. So all in all I don't have a strong opinion on not_before / not_after anymore.",
          "createdAt": "2018-06-01T19:15:50Z",
          "updatedAt": "2018-06-01T19:15:50Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is fine, @chris-wood please re-open if not.",
          "createdAt": "2018-07-02T14:17:59Z",
          "updatedAt": "2018-07-02T14:17:59Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWUzMjI4Njk1MDM=",
      "title": "Recast Fronting mode as Split Mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/28",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Domain fronting already has a bad rap. Perhaps we should give this a new name to avoid pushback?",
      "createdAt": "2018-05-14T15:33:48Z",
      "updatedAt": "2018-05-22T14:18:55Z",
      "closedAt": "2018-05-22T14:18:55Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree, Maybe \"Transparent\" mode? \"Proxy\" mode?",
          "createdAt": "2018-05-14T17:32:16Z",
          "updatedAt": "2018-05-14T17:32:16Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm going to go a step farther and suggest only defining shared mode in this document.\r\n\r\nit brings esni to the masses and eliminates the need for special tech to acheive classic fronting. That's a significant net-win without being weighed down by bias about fronting - I think we'll get more participation that way because the set of goals is easier to achieve consensus on (privacy is good!)\r\n\r\nIf folks need a separate document later to figure out they can tunnel based on the decrypted SNI then istm it can be separable.. true?\r\n",
          "createdAt": "2018-05-15T18:00:31Z",
          "updatedAt": "2018-05-15T18:00:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus My reservation there is that, with only Shared Mode, a better design is probably to encrypt all of the extensions, and not just the SNI. With that change, it then later becomes infeasible to accomplish the front/hidden split. ",
          "createdAt": "2018-05-20T23:58:11Z",
          "updatedAt": "2018-05-20T23:58:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing via #45. @mcmanus if we want to keep only Shared Mode, let's use a new issue to track that.",
          "createdAt": "2018-05-22T14:18:55Z",
          "updatedAt": "2018-05-22T14:18:55Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWUzMjI5MDk3MzY=",
      "title": "Why single A and AAAA requirements?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/29",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Regarding:\r\n```\r\nServers SHOULD configure DNS such that, upon querying a domain name with ESNI support, at most one each of A, AAAA, TXT ESNI, and ALTSVC {{?I-D.schwartz-httpbis-dns-alt-svc}} Resource Record is returned.\r\n```\r\nWhy is that a SHOULD? Does it apply to both fronting and shared mode?\r\n\r\nFor reference, Cloudflare almost always sends at least two A and AAAA answers for every question.\r\n\r\n(I get that it's not a MUST, though I'd also like to understand what the reasoning is in the first place)",
      "createdAt": "2018-05-14T17:27:10Z",
      "updatedAt": "2018-05-14T22:50:01Z",
      "closedAt": "2018-05-14T22:50:01Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ??",
          "createdAt": "2018-05-14T19:51:09Z",
          "updatedAt": "2018-05-14T19:51:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The idea was to simplify key management. If multiple A or AAAA records are returned, the server needs to ensure each server behind those addresses have all the necessary keys. ",
          "createdAt": "2018-05-14T19:52:31Z",
          "updatedAt": "2018-05-14T19:52:31Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood I see, I'd rather the spec said that instead of trying to impose limits (I made #31 with suggested fix).",
          "createdAt": "2018-05-14T22:18:56Z",
          "updatedAt": "2018-05-14T22:18:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ghedo works for me :)",
          "createdAt": "2018-05-14T22:28:59Z",
          "updatedAt": "2018-05-14T22:28:59Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWUzMjI5MzE2MjA=",
      "title": "Rename ESNIKeys to something more generic",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/30",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "With #22 merged, I wonder if the ESNIKeys struct should just be renamed to something not specific to ESNI, but something more like \"generic TLS config in DNS\" so that it can be more cleanly reused by unrelated features.\r\n\r\n\"ServerConfiguration\" comes to mind from the early TLS 1.3 days.",
      "createdAt": "2018-05-14T18:33:48Z",
      "updatedAt": "2018-05-17T19:56:27Z",
      "closedAt": "2018-05-17T19:56:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If we were to re-use these keys for other purposes, that seems fine. However, I'm not sure we want to do that. Semi-static keys, for example, should ideally be separate.",
          "createdAt": "2018-05-14T21:41:23Z",
          "updatedAt": "2018-05-14T21:41:23Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The keys yes, but I imagine the extensions field can hold \"arbitrary\" data, so while the keys would be ESNI-specific, you could also include extensions that have nothing to do with ESNI.",
          "createdAt": "2018-05-14T21:59:22Z",
          "updatedAt": "2018-05-14T21:59:22Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking about this some more, this would also require changing the \"_esni.\" prefix to something else.\r\n\r\nIn any case I can see how this might be out of scope for this spec. In the end it's a matter of deciding whether future TLS extensions that need similar DNS records, should be able to reuse the same structure (so no additional TXT record with its own prefix would be required), or if they should define their own structure (and have a separate TXT record).\r\n\r\nI'm happy to close this if it goes too much out of scope.",
          "createdAt": "2018-05-14T22:27:54Z",
          "updatedAt": "2018-05-14T22:27:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, I think it's verging on being out of scope. What do others think? @kazuho @ekr?",
          "createdAt": "2018-05-14T22:28:37Z",
          "updatedAt": "2018-05-14T22:28:37Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My preference goes to keeping the name as-is, considering the fact that the role of ESNIKeys is  (at least for the moment) to negotiate properties between the client and the fronting server (not the hidden server), and that the only property we need to negotiate between the two is the information necessary for ESNI protection.\r\n\r\nIt is true that the DNS record can covey properties related to the hidden server (as you know, I've argued for using it to carry the server certificate chain). But IMO that's a change of concept, and I prefer keeping the concept simple for the time being.",
          "createdAt": "2018-05-14T22:55:51Z",
          "updatedAt": "2018-05-14T22:55:51Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok.",
          "createdAt": "2018-05-17T19:56:27Z",
          "updatedAt": "2018-05-17T19:56:27Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWUzMjMzMTUwODg=",
      "title": "Add text comparing ESNI to alternative approaches",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/32",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Others include those discussed in I-D.ietf-tls-sni-encryption and the H2-layer approach with secondary certs.",
      "createdAt": "2018-05-15T17:35:54Z",
      "updatedAt": "2018-07-02T14:18:08Z",
      "closedAt": "2018-07-02T14:18:08Z",
      "comments": []
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWUzMjMzMTYyMjE=",
      "title": "Add text regarding fallback",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/33",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-15T17:39:26Z",
      "updatedAt": "2018-10-21T20:36:28Z",
      "closedAt": "2018-10-21T20:36:28Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Any on-path active attacker can send an unsigned alert in response to a CH it doesn't like, so perhaps it's best just to acknowledge this. ",
          "createdAt": "2018-05-15T17:43:08Z",
          "updatedAt": "2018-05-15T17:43:08Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "More than acknowledge this, should we make a recommendation as to whether the client should fail hard or fallback to unencrypted SNI?",
          "createdAt": "2018-05-16T06:48:31Z",
          "updatedAt": "2018-05-16T06:48:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi I don't think so. ",
          "createdAt": "2018-05-16T22:03:13Z",
          "updatedAt": "2018-05-16T22:03:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can you elaborate?",
          "createdAt": "2018-05-16T23:59:19Z",
          "updatedAt": "2018-05-16T23:59:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "AFAIK, the 1.3 draft makes no recommendation for dealing with this particular problem, and so I think we shouldn't do so here, either.",
          "createdAt": "2018-05-17T19:49:22Z",
          "updatedAt": "2018-05-17T19:49:22Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do you mean fallback to TLS 1.2 or fallback to unencrypted SNI? The latter is a new privacy concern that arises in this document so we may want recommendations for that one.",
          "createdAt": "2018-05-17T20:21:28Z",
          "updatedAt": "2018-05-17T20:21:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I see little difference between those fallbacks since they're triggered the same way. So I would prefer to simply acknowledge the problem and nothing more.",
          "createdAt": "2018-05-17T20:24:50Z",
          "updatedAt": "2018-05-17T20:24:50Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Acknowledging is fine if you explain the properties so implementers can make an informed decision knowing the consequences. Also these fallbacks are very different in my mind. TLS 1.3->1.2 has downgrade prevention, whereas once you've fallen back to unencrypted SNI it's too late you've leaked it.",
          "createdAt": "2018-05-17T20:35:59Z",
          "updatedAt": "2018-05-17T20:38:31Z"
        },
        {
          "author": "mhofman",
          "authorAssociation": "NONE",
          "body": "I agree there may be a risk of leaking SNI here.\r\n\r\nIf an attacker is on the path between the client and fronting server, it is capable of forcing a downgrade to a TLS 1.2 connection. Even if such downgrade might ultimately cause the connection to fail, some clients could be tricked into revealing the unencrypted server name.\r\n\r\nWhile the [Section 6.1. Misconfiguration](https://github.com/ekr/draft-rescorla-tls-esni/blob/master/draft-ietf-tls-esni.md#misconfiguration) states that `Clients SHOULD NOT fall back to cleartext SNI, because that allows a network attacker to disclose the SNI`, there is a risk that the client implementation would just switch to a 1.2 mode that completely omits any ESNI logic.\r\n\r\nThe middlebox section also focuses mostly on the stripping of the explicit encrypted_server_name extension. In a downgrade scenario, the stripping could be implicitly performed by the client.\r\n\r\nI think there should be a more explicit protection against MITM middleboxes that force a downgrade of the connection to 1.2.",
          "createdAt": "2018-09-27T19:24:05Z",
          "updatedAt": "2018-09-27T19:24:05Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "We now forbid negotiating 1.2.",
          "createdAt": "2018-10-21T20:36:28Z",
          "updatedAt": "2018-10-21T20:36:28Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWUzMjMzMjcxMDE=",
      "title": "altsvc",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/34",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I suggest dropping the references to Ben's individual alt-svc in DNS draft.. it hasn't been adopted and its future is murky.\r\n\r\nactual alt-svc (the non dns kind) actually requires the use of the plaintext SNI. As those are both cachable and connections to new IP addresses (less linkable) you could consider updating it with mike bishop's https://tools.ietf.org/html/draft-bishop-httpbis-sni-altsvc-01 (also an individual draft atm)\r\n\r\n",
      "createdAt": "2018-05-15T18:13:00Z",
      "updatedAt": "2018-05-17T20:29:24Z",
      "closedAt": "2018-05-17T20:29:24Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood also suggested that the reference might not be needed in https://github.com/ekr/draft-rescorla-tls-esni/pull/31#discussion_r188117285 so I made #44 to actually remove it.",
          "createdAt": "2018-05-17T20:01:41Z",
          "updatedAt": "2018-05-17T20:01:41Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWUzMjMzMzM1OTk=",
      "title": "define rules for cname (aka multi-cdn or multi-cloud)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/35",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "traditional SNI is the origin name. You can use an HTTP connect tunnel, traverse a CNAME (or 3), or engage in some alt-svc load balancing and, while these things all change the DNS name you lookup and connect() to, they don't change the SNI.\r\n\r\nwhat about eSNI? the keys are a property of the server, not really the origin. It seems really hard to coordinate this across administrative domains.\r\n\r\nThe case I'm particularly worried about is where more than one hosting provider is in the mix.. ISTM a typical way of doing this is LB'ing DNS responses with CNAMEs. (e.g. 50% of www.example.com gets CNAME www.cdnA.com and 50% gets www.cdnB.com).. We've got folks from 2 CDNs as active contributors here who know better than I, but this kind of level of indirection to get you CDN agility seems pretty common.. we would want cdnA and cdnB to be able to each use their own keys.\r\n\r\nEven without agility, its a pretty common pattern for an origin to maintain control of their own DNS and only delegate to a CDN under load/whatnot and do that via cname...\r\n\r\nthat argues to me to allow _esni TXT records on the server lookup, not just the origin name. Perhaps they could override the _esni at the origin scope but that seems like a way to trigger the misconfiguration fallback path.\r\n\r\nAlso, what about connect tunnels where you do do SNI, but don't traditionally do DNS at all?\r\n\r\n",
      "createdAt": "2018-05-15T18:32:29Z",
      "updatedAt": "2019-06-05T14:51:05Z",
      "closedAt": "2019-06-05T14:51:05Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "rfc 1034 (I cannot figure out if this provision has been udpated) says\r\n\r\nThe domain system provides such a feature using the canonical name\r\n(CNAME) RR.  A CNAME RR identifies its owner name as an alias, and\r\nspecifies the corresponding canonical name in the RDATA section of the\r\nRR.  If a CNAME RR is present at a node, no other data should be\r\npresent; this ensures that the data for a canonical name and its aliases\r\ncannot be different.  This rule also insures that a cached CNAME can be\r\nused without checking with an authoritative server for other RR types.\r\n",
          "createdAt": "2018-05-15T19:03:20Z",
          "updatedAt": "2018-05-15T19:03:20Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess there is also the question of whether a txt query of _esni.www.example.com can return a CNAME even if www.exmaple.com returned A/AAAA (which would seem to be a good way to keep your keys straight.)\r\n\r\n",
          "createdAt": "2018-05-15T19:05:46Z",
          "updatedAt": "2018-05-15T19:05:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I guess there is also the question of whether a txt query of _esni.www.example.com can return a CNAME even if www.exmaple.com returned A/AAAA (which would seem to be a good way to keep your keys straight.)\r\n\r\nWe need to allow this. As you said, certain CDNs do not provide DNS as a service and their customers use their own DNS. Please see my comment on https://github.com/ekr/draft-rescorla-tls-esni/issues/7#issuecomment-388531906.\r\n\r\nRegarding the multi-CDN use-case, I do not think there is a easy solution.\r\n\r\nOne way of supporting that kind of configuration will be to do the following:\r\n1. (instead of querying for A and _eni) client only queries for A. Let's consider example.com is queried for and 1.2.3.4 is returned.\r\n2. client then connects to the return address via https to obtain the ESNIKeys (i.e. https://1.2.3.4/.well-known/esni-keys/example.com\r\n3. client connects to 1.2.3.4 with ESNI specifying \"example.com\"\r\n\r\nBut this has more overhead, looks more like TLS tunneling...\r\n\r\nHonestly, I'd prefer to not covering multi-CDN use-case. IIUC it's mostly for entertainment content. They need least protection, to the extent to which some believe that serving using plaintext HTTP is fine.",
          "createdAt": "2018-05-15T20:38:28Z",
          "updatedAt": "2018-05-15T20:38:28Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "we need to document that when a.example.com -> cname b.example.com the TXT record that is looked up is _esni.b.example.com\r\n\r\nWe also need to document that when _esni.b.example.com is a CNAME to c.example.com the TXT record is recursively looked up from c.example.com not _esni.c.example.com. (If they want that behavior the CNAME should be from b.example.com to c.example.com).\r\n",
          "createdAt": "2018-07-03T15:58:48Z",
          "updatedAt": "2018-07-03T15:58:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> we need to document that when a.example.com -> cname b.example.com the TXT record that is looked up is _esni.b.example.com\r\n\r\nI am not sure if using an _intermediate_ result of address resolution as a key to obtain ESNI is a good approach. Rather, I would argue that `_esni.a.example.com` should be used in that case, due to the following reasons:\r\n\r\n* some APIs used for querying a hostname (or a DNS record) might resolve CNAME's by itself\r\n  * `getaddrinfo` is one of such APIs, though it does not provide you the ability to query TXT records\r\n* we can fully parallelize the address resolution and the ESNI key resolution if we select `_esni.original-host` as the name\r\n\r\nIf we are _not_ going to use the original hostname, I wonder if we could use the final result rather than the intermediate result (e.g., assuming that a.example.com results to 192.0.2.1, query `_esni.1.2.0.192.in-addr.apa`). That solves the API issue and the multi-CDN use-case, with the downside being that the queries cannot be parallelized.",
          "createdAt": "2018-07-04T01:15:43Z",
          "updatedAt": "2018-07-04T01:15:43Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @kazuho.  You start with A/AAAA requests to example.com and TXT requests to _esni.example.com and see where each leads you.  The point about _esni. using CNAME to point to a leaf that might not have the underscore is valuable.",
          "createdAt": "2018-07-04T02:36:07Z",
          "updatedAt": "2018-07-04T02:36:07Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the use case not being captured is when www.example.com is a cname to\nwww.cdn-a.com (and at other times a cname to www.cdn-b.com). presumably the\nonus to manage their key records falls on cdn-a and cdn.b and should\nrequire example.com to be managing the _esni record. (example.com may not\neven be aware which cdn is currently doing esni)\n\n\nOn Tue, Jul 3, 2018 at 10:36 PM, Martin Thomson <notifications@github.com>\nwrote:\n\n> I agree with @kazuho <https://github.com/kazuho>. You start with A/AAAA\n> requests to example.com and TXT requests to _esni.example.com and see\n> where each leads you. The point about _esni. using CNAME to point to a leaf\n> that might not have the underscore is valuable.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/issues/35#issuecomment-402345849>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAP5s1q0uoHCz_HMIKovuOw4eQ1kRflNks5uDCoXgaJpZM4UADk5>\n> .\n>\n",
          "createdAt": "2018-07-04T02:48:26Z",
          "updatedAt": "2018-07-04T02:48:26Z"
        },
        {
          "author": "sludin",
          "authorAssociation": "NONE",
          "body": "I know this is three months old, but did the CDN case get landed?  Entities using multiple CDNs, or even an entity flipping between using a CDN and not is a reality that needs to be fully thought through.  Reading through the tickets and RFC I am concerned about:\r\n  - The apparent need to share the private key between entities\r\n  - The possibility of the TXT or RR record returning information for one CDN and then the A record returning information for another (in cases where there are multiple keys).\r\n\r\n",
          "createdAt": "2018-10-04T18:36:15Z",
          "updatedAt": "2018-10-04T18:36:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus I think this issue is resolved. Can you please confirm and close if so?",
          "createdAt": "2019-06-02T14:56:18Z",
          "updatedAt": "2019-06-02T14:56:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved. Please re-open if something's still needed!",
          "createdAt": "2019-06-05T14:51:05Z",
          "updatedAt": "2019-06-05T14:51:05Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWUzMjM0Mjg1MDE=",
      "title": "Remove the fronting / hidden server distinction",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/37",
      "state": "CLOSED",
      "author": "kontaxis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In 3.1 Topologies, in Shared Mode topology the fronting and hidden servers are one and the same.\r\n\r\nFronting Mode Topology is described as \"... might not be the origin for any domains, but as a practical matter, it is probably the origin for a large set of innocuous domains\".\r\n\r\nWhy are some domains innocuous and others aren't?\r\nIs it ok for an attacker (adversary) to discover innocuous domains names?\r\n\r\nInnocuous domain names may provide cover when the threat model includes censorship.\r\nIs this what you are trying to solve here?\r\nIsn't that orthogonal to ESNI, i.e., architectures where there is a cover reason why a client is communicating with a server? (because it's a known CDN or sth)\r\n\r\n\r\nIn 5.2 Fronting Server Behavior the text says \"Upon determining the true SNI, the fronting server then either serves the connection directly (if in Shared Mode), in which case it executes the steps in the following section, or forwards the TLS connection to the hidden server (if in Fronting Mode).\"\r\n\r\n... or decrypts the TLS connections and forwards plain text traffic to the hidden server. (Bad idea I know)\r\nThe question is why should this document describe what happens after a TLS connection is established between a client and server? Seems to deviate from the problem this document is trying to address. (See below)\r\n\r\n\r\nIntroduction implicitly defines the problem as \"an on-path attacker to determine the domain name\"\r\nThis is always true with ESNI between the client and fronting server.\r\nAll domain names are hidden, innocuous, non-innocuous, hosted in the fronting or some other server.\r\n\r\nI would propose to drop any mention of hidden servers or deployment architectures, just say \"server\" and in Security Considerations mention that a server SHOULD be configured in a way that it does not leak the identities of domains it wants to protect. I.e., when the SNI / ESNI extension is missing the server SHOULD not return a certificate for a protected site. For example CDNs should just return a certificate for their own domain.",
      "createdAt": "2018-05-16T00:26:15Z",
      "updatedAt": "2018-07-02T14:18:59Z",
      "closedAt": "2018-07-02T14:18:59Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "see also #28 ",
          "createdAt": "2018-05-16T02:43:50Z",
          "updatedAt": "2018-05-16T02:43:50Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "We ended up changing the terminology here.",
          "createdAt": "2018-07-02T14:18:59Z",
          "updatedAt": "2018-07-02T14:18:59Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWUzMjM0Mjk0NzQ=",
      "title": "Make ESNI TLS 1.2 compatible",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/38",
      "state": "CLOSED",
      "author": "kontaxis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "ESNI seems to rely on TLS 1.3 KeyShareEntry which makes it incompatible with TLS 1.2.\r\n\r\nThat's unfortunate with that \"The protocol designed in this document is quite straightforward.\"\r\n\r\nThe gist of ESNI comes down to \"encrypted_server_name extension, which contains the true extension encrypted under the provider\u2019s public key.\"\r\n\r\nThat seems pretty generic and backwards compatible.",
      "createdAt": "2018-05-16T00:32:42Z",
      "updatedAt": "2018-05-18T13:18:46Z",
      "closedAt": "2018-05-18T13:18:45Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "To prevent cut-and-paste attacks, you need to bind ESNI to the CH. That means we\u2019d need 1.2 clients to send a key share in the CH to use when deriving encryption keying material, and that\u2019s not currently done. ",
          "createdAt": "2018-05-16T00:46:43Z",
          "updatedAt": "2018-05-16T00:46:43Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since TLS 1.2 sends the server certificate in plaintext it seems like ESNI wouldn't be particularly useful there anyway, no?",
          "createdAt": "2018-05-18T08:29:25Z",
          "updatedAt": "2018-05-18T08:29:25Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "Indeed. I guess someone could argue about wildcard certificates or when multiple names are present but the names are usually related so I agree there\u2019s no significant benefit from encrypting the SNI.",
          "createdAt": "2018-05-18T13:18:45Z",
          "updatedAt": "2018-05-18T13:18:45Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWUzMjM0MzEyMTA=",
      "title": "Reuse RFC 6066 ServerName extension / Do not define a new extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/39",
      "state": "CLOSED",
      "author": "kontaxis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "6.2 Middleboxes identifies a legitimate concern where middleboxes might strip a new ESNI extension that is unknown to them.\r\n\r\nThe ServerName structure as defined in RFC 6066 has an 8-bit NameType field where 0 is defined as host_name and all other values are undefined. Why not define 1 (or any other value) as encrypted_host_name?\r\n\r\nThe name structure inside ServerName is 16 opaque bits which seems able to accommodate EncryptedSNI as defined in this document. (Make encrypted_sni slightly smaller so that \"label\" and \"suite\" fit)",
      "createdAt": "2018-05-16T00:44:07Z",
      "updatedAt": "2018-05-16T06:32:28Z",
      "closedAt": "2018-05-16T06:32:27Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I prefer having a different extension, because we do not want to limit the capability of ESNIKeys to just protecting the \"HostName\" (as identified by the 8-bit NameType field of zero).  IMO it is better to have a mechanism that can protect any type of \"server-name\", including those covered by NameTypes other than zero.\r\n\r\nNote that DNS is just one way of publishing ESNIKeys.",
          "createdAt": "2018-05-16T03:40:23Z",
          "updatedAt": "2018-05-16T03:40:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @kazuho.",
          "createdAt": "2018-05-16T03:53:42Z",
          "updatedAt": "2018-05-16T03:53:42Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "I didn't mean for ESNI to only apply to NameType 0.\r\n\r\nThere are 256 values, 0 is host_name, 1 can be encrypted_server_name, and there are 254 more values for additional types of server name types. Going forward I doubt someone will define a plain text type that will have to be protected. But even if that happens encrypted_server_name can encapsulate all name types but itself.\r\n\r\nP.S.: Not really sure how the use of DNS is a factor here.",
          "createdAt": "2018-05-16T04:15:37Z",
          "updatedAt": "2018-05-16T04:15:37Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Recall that SNI extensibility is [irrevocably busted](https://mailarchive.ietf.org/arch/msg/tls/1t79gzNItZd71DwwoaqcQQ_4Yxc).",
          "createdAt": "2018-05-16T06:03:36Z",
          "updatedAt": "2018-05-16T06:03:36Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "Fair enough.",
          "createdAt": "2018-05-16T06:32:27Z",
          "updatedAt": "2018-05-16T06:32:27Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWUzMjM0ODgzOTE=",
      "title": "Consider using a new DNS RR Type instead of TXT",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/40",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current document uses the TXT record for `_esni.example.org`. This will cause multiple issues.\r\n\r\n1) There is no IANA registry for prefixes that start with underscores to be used in DNS, so it is valid for existing servers to already be using _esni as part of the FQDN.\r\n2) The TXT record was designed to hold descriptive text, which means operators can already be using it for other descriptions.\r\n3) As described in issue #35 , using a prefix breaks CNAME.\r\n4) TXT requires base64 encoding which adds overhead on the network and recursive resolvers.\r\n\r\nThe generally recommended way to \"stuff it in the DNS\" is to create a new RR type for your data. For example DANE established RR type TLSA (52). There is room in the 16bit IANA registry for another value. The key here is that this prevents systems from misinterpreting the TXT record as something else, and it prevents systems from already using it for something else\r\n\r\nhttps://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4",
      "createdAt": "2018-05-16T06:46:43Z",
      "updatedAt": "2018-05-16T21:59:06Z",
      "closedAt": "2018-05-16T21:59:06Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "That was previously discussed in #7.",
          "createdAt": "2018-05-16T07:03:09Z",
          "updatedAt": "2018-05-16T07:03:09Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See https://www.ietf.org/internet-drafts/draft-ietf-dnsop-attrleaf-fix-00.txt regarding the use of underscore names.",
          "createdAt": "2018-05-16T07:23:52Z",
          "updatedAt": "2018-05-16T07:23:52Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for those links, I had missed #7. This makes sense to me. I makes me somewhat uncomfortable to abuse TXT this way but I understand the operational concerns. Feel free to close this issue.",
          "createdAt": "2018-05-16T17:42:16Z",
          "updatedAt": "2018-05-16T17:42:16Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWUzMjM0OTA2MjQ=",
      "title": "Clarify downsides of encrypting ALPN with the same key as SNI",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/41",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "This seems to be somewhat discussed in the draft and in issues, but I fail to see the motivation behind not using the ESNI key to encrypt other extensions such as ALPN. The main concern seems to be around entities seeing the value of decrypted ALPN, but that's still better than ALPN being the clear. Another concern is a middlebox blocking this extension, but if the client decides to fail hard, blocking is better than leaking; and if a client falls back to unencrypted then the connection works regardless. If I'm missing something, can that be clarified in the draft?",
      "createdAt": "2018-05-16T06:56:12Z",
      "updatedAt": "2020-10-16T17:14:14Z",
      "closedAt": "2019-07-08T17:26:24Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the goal with ALPN is to ensure that the set of values that are advertised remains small and fixed.  That is, everyone can offer h2+http/1.1 and no more.  This gives no advantage to a passive observer in terms of distinguishing traffic; the pattern of TLS extensions (order and so forth) gives more away.",
          "createdAt": "2018-07-03T05:15:46Z",
          "updatedAt": "2018-07-03T05:15:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "The other point is that SNI designates the server the client wants to handshakes with. ALPN (as well as other properties of ClientHello) is a property of the handshake.\r\n\r\nConsider the split case. SNI is decrypted by the fronting server. ALPN will be a property that will be taken into consideration by the backend server.",
          "createdAt": "2018-07-03T05:23:06Z",
          "updatedAt": "2018-07-03T05:25:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that in current usage, ALPN is only used for h2 vs http/1.1. But if we had a way to hide ALPN from censors, we could use it to run a VPN over TLS to evade censorship - I'd like to have a TLS server on port 443 that mostly serves HTTPS but can also serve VPN to select clients.\r\n\r\nIn the split case, having the fronting server decrypt the ALPN and pass it decrypted to the backend server is fine - I'm mostly concerned about threats between the client and the fronting server.",
          "createdAt": "2018-07-03T05:32:33Z",
          "updatedAt": "2018-07-03T05:32:33Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> In the split case, having the fronting server decrypt the ALPN and pass it decrypted to the backend server is fine\r\n\r\nCurrent draft is designed in a way to allow stock TLS servers to be run as a hidden server. Creating a way to pass the decrypted ALPN (or decrypted SNI) from the client-facing server to hidden server destroys that design.\r\n\r\nGenerally speaking, I am not opposed to protecting more properties. OTOH, I might prefer doing things in small steps; we have the extensions field in ESNIKeys.",
          "createdAt": "2018-07-03T06:04:40Z",
          "updatedAt": "2018-07-03T06:04:53Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DavidSchinazi, if you want to advertise a VPN ALPN on all your connections, then that would work.  I'd prefer to establish privacy-preserving usage patterns as the norm so that this is considered acceptable (and not a reason to block a connection).  Advertising a willingness to use a VPN connection in addition to HTTP would be analogous to what we're doing here; the observer doesn't know what you ended up using.  They could decide to block based on the possibility that you are doing something bad, but that applies to encrypted SNI in equal measure.",
          "createdAt": "2018-07-03T10:17:44Z",
          "updatedAt": "2018-07-03T10:17:44Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This sounds reasonable to me. If we build this solution in a way that allows us to encrypt ALPN later without it being distinguishable from ESNI by a MitM, then I'm happy \ud83d\ude04 ",
          "createdAt": "2018-07-03T20:19:34Z",
          "updatedAt": "2018-07-03T20:19:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi this should be fixed by #169 -- please reopen if that's not the case!",
          "createdAt": "2019-07-08T17:26:24Z",
          "updatedAt": "2019-07-08T17:26:24Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood #169 works for me, thanks.",
          "createdAt": "2019-07-08T18:18:13Z",
          "updatedAt": "2019-07-08T18:18:13Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWUzMjM0OTE0Njg=",
      "title": "Fronting server forwarding the TLS connection is unclear",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/42",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From the \"Fronting Server Behavior\" section:\r\n\r\n> the fronting server then [...] forwards the TLS connection to the hidden server\r\n\r\nThis is not very clearly defined. Does the fronting server not make any changes to the client hello? Doesn't it remove the encrypted SNI extension and/or possibly add a cleartext SNI as discussed in \"Communicating SNI to Hidden Server\"?",
      "createdAt": "2018-05-16T06:59:54Z",
      "updatedAt": "2018-07-02T14:20:43Z",
      "closedAt": "2018-07-02T14:20:43Z",
      "comments": []
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWUzMjU4OTIzMTQ=",
      "title": "pad the certificate too",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/47",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-23T22:12:20Z",
      "updatedAt": "2018-07-02T14:17:23Z",
      "closedAt": "2018-07-02T14:17:23Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson addressed by #48?",
          "createdAt": "2018-06-15T21:06:21Z",
          "updatedAt": "2018-06-15T21:06:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mostly.  I left comments on the PR.  A few things to follow-up on.",
          "createdAt": "2018-06-15T23:28:44Z",
          "updatedAt": "2018-06-15T23:28:44Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "MDU6SXNzdWUzMzc5NjQwOTQ=",
      "title": "Is DNS query for server or origin",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/61",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The TLS server name (and thus SNI) is the HTTP origin name, however it is not necessarily the same as the host name of the TLS server. HTTP Alternative Services is the obvious way that happens - but Alt-Svc never changes the origin name.\r\n\r\nWhen fetching the ESNI key, do we fetch it from _esni.origin-name or _esni.host-name?\r\n\r\nI think origin-name makes more sense - keeping everything that is an expiicit protocol element in terms of origin eliminates confusion.\r\n\r\nthe counter argument is that you can use alt-svc to do fine grained fanout to providers with different keys (using cdn specific names for them in alt-svc) in a way that is harder to do through the origin name dns controls.",
      "createdAt": "2018-07-03T16:06:46Z",
      "updatedAt": "2018-10-21T20:52:41Z",
      "closedAt": "2018-10-21T20:52:41Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My view is that the base name that is used to lookup the ESNI value (i.e. the name excluding the `_esni.` prefix) must be the same as the hostname that is carried by the ESNI extension.\r\n\r\nESNI is a replacement for SNI, and I think that the design should allow the TLS stack to obtain the ESNI key by itself (i.e. by querying `_esni.<sni-name>`).",
          "createdAt": "2018-07-12T02:28:22Z",
          "updatedAt": "2018-07-12T02:28:34Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "PS. To give an example, golang's TLS API to establish a new connection looks like below.\r\n```\r\nconn, err := tls.Dial(\"tcp\", \"mail.google.com:443\", &tls.Config{\r\n    RootCAs: roots,\r\n})\r\n```\r\n\r\nAs is obvious from the example, name resolution happens inside the TLS stack. I'd assume that we would want to handle ESNI record lookup within the stack as well.\r\n\r\nTherefore, the name used to lookup the ESNI record cannot be the origin name, which is specific to the behavior defined in HTTP (alt-svc), which operates above the TLS stack. It needs to be the hostname that is used for the name resolution (or a name that is derived from that).\r\n\r\nMy understanding is that TLS stacks on other programming language often has the same abstraction; i.e. handle name resolution inside in the TLS connection establishment call (or the TCP connection establishment call).",
          "createdAt": "2018-07-12T03:47:28Z",
          "updatedAt": "2018-07-12T03:54:58Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> My view is that the base name that is used to lookup the ESNI value (i.e. the name excluding the `_esni.` prefix) must be the same as the hostname that is carried by the ESNI extension.\r\n> \r\n\r\nto be clear - that is the origin name. In the case of alt-svc, where the host name and the origin name diverge, the SNI remains the origin name. This is also the identity that the client stack will authenticate. The host name is resolved to get a a/aaaa but never appears on the wire.\r\n\r\n> ESNI is a replacement for SNI, and I think that the design should allow the TLS stack to obtain the ESNI key by itself (i.e. by querying `_esni.<sni-name>`).\r\n\r\nThis matches my opinion, and also what firefox nightly is currently doing.. but I'm confused by your next comment\r\n\r\n> PS. To give an example, golang's TLS API to establish a new connection looks like below.\r\n> \r\n> ```\r\n> conn, err := tls.Dial(\"tcp\", \"mail.google.com:443\", &tls.Config{\r\n>     RootCAs: roots,\r\n> })\r\n> ```\r\n> As is obvious from the example, name resolution happens inside the TLS stack. I'd assume that we would want to handle ESNI record lookup within the stack as well.\r\n\r\nafaict the SNI information actually comes from tls.Config (Falling back to mail.google.com only if not provided).. this is no doubt also the information used to authenticate the cert.. https://golang.org/src/crypto/tls/tls.go?s=3255:3347#L88\r\n\r\nThe TLS stack is going to need both pieces of information. So which should it use?\r\n> \r\n> Therefore, the name used to lookup the ESNI record cannot be the origin name, which is specific to the behavior defined in HTTP (alt-svc), which operates above the TLS stack. \r\n\r\nno - the origin name is the SNI name even with alt-svc. It might not be the host name.\r\n\r\n> It needs to be the hostname that is used for the name resolution (or a name that is derived from that).\r\n> \r\n\r\nI think that's defensible but for different reasons (key management flexibility). but I would argue against this as we don't really want you using large sets of keys\r\n\r\n> My understanding is that TLS stacks on other programming language often has the same abstraction; i.e. handle name resolution inside in the TLS connection establishment call (or the TCP connection establishment call).\r\n\r\nIf a stack can't support alt-svc, then this isn't a problem - the name is the same everywhere :)\r\n\r\nIf a stack does support alt-svc then it has 2 names to deal with.. one is the name used for SNI and auth, and the other is the one used for TCP. (or perhaps it doesn't do TCP on its own).\r\n\r\nAll this issue is trying to do is decide whether the name we lookup for ENSNI/TXT is the same as the name we lookup for A/AAAA.. I'm going to say that they don't necessarily have to match. (i.e. your A could be for the alt-svc but your txt/esni is always going to be for the origin - which is the same thing you put in your CH.\r\n\r\nI'll make a pr.",
          "createdAt": "2018-10-17T22:13:40Z",
          "updatedAt": "2018-10-17T22:13:40Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWUzMzgzOTQ1Mzg=",
      "title": "Note about checking zero padding",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/62",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Require that the server check that everything after ServerNameList is zero.",
      "createdAt": "2018-07-05T00:28:46Z",
      "updatedAt": "2018-10-21T20:41:00Z",
      "closedAt": "2018-10-21T20:41:00Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed.",
          "createdAt": "2018-10-21T20:38:55Z",
          "updatedAt": "2018-10-21T20:38:55Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWUzMzg0MjQ5Njc=",
      "title": "Versioning for the record?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/63",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Do we need it.",
      "createdAt": "2018-07-05T04:39:04Z",
      "updatedAt": "2018-09-16T20:03:24Z",
      "closedAt": "2018-09-16T20:03:24Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "For ESNIKeys (the DNS record) I do not think we need a version for the following reasons:\r\n* I think we would prefer adding extensions rather than making incompatible changes\r\n* we always have the freedom to pick a new prefix (e.g. `_esni2`) or a new RR type when making incompatible changes\r\n  * an incompatible change will require the client to query for two DNS records anyways\r\n\r\nFor the ESNI extension, I also do not think that we need a version field. When we define an extension sometime in the future, we could the advertise the support as an extension in the ESNIKeys to instruct the clients that support that extension to send a CH extension that uses a different extension ID than the ESNI extension.",
          "createdAt": "2018-07-05T06:05:15Z",
          "updatedAt": "2018-07-05T06:05:15Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> an incompatible change will require the client to query for two DNS records anyways\r\n\r\nA lot of other TXT records have a version in them.  It turns out that if you do that you can query for TXT records and get multiple answers back.  Then, you pick those with the version you like.  That's one query.\r\n\r\nI'm tempted to suggest that the first octet (or two) be used for a version number.  It's cheap.",
          "createdAt": "2018-07-05T09:39:40Z",
          "updatedAt": "2018-07-05T09:39:40Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm concerned about how we iterate on these in the field. They're not tied to TLS version, so what if we decide to change the formats, as we are discussing in #67 ",
          "createdAt": "2018-07-05T12:18:08Z",
          "updatedAt": "2018-07-05T12:18:08Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "a magic number (including version) is a pretty decent idea. right now _esni is in its own namespace but you can imagine someone doing a txt record that applies to every dns response so we would want to disambiguate that as well.\r\n\r\ntake note to update the \"concat multiple records\" rule if we go down this path..",
          "createdAt": "2018-07-05T12:32:21Z",
          "updatedAt": "2018-07-05T12:32:21Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that having version is a good idea in sense that it allows to do experiments before the standardization completes.",
          "createdAt": "2018-07-17T05:29:46Z",
          "updatedAt": "2018-07-17T05:29:46Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "MDU6SXNzdWUzMzg0MjgxMDU=",
      "title": "checksum and extension hashes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/64",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The hash used in the extension should use the same hash inputs as the checksum.  The difference here just makes using this harder.",
      "createdAt": "2018-07-05T05:04:37Z",
      "updatedAt": "2020-10-16T17:14:14Z",
      "closedAt": "2019-07-03T01:20:45Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I support the change, if that makes people feel more comfortable about having the checksum field in ESNIKeys.",
          "createdAt": "2018-07-05T06:13:26Z",
          "updatedAt": "2018-07-05T06:13:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not opposed, but it doesn't help as much as you might think, because\nyou need to compute the label with the cipher hash and not (necessarily)\nwith SHA-256.\n\nOn Wed, Jul 4, 2018 at 11:13 PM, Kazuho Oku <notifications@github.com>\nwrote:\n\n> I support the change, if that makes people feel more comfortable about\n> having the checksum field in ESNIKeys.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/issues/64#issuecomment-402616617>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oepUYCUrNp7wcZST5fvAOOHtpyfvks5uDa6HgaJpZM4VDQOE>\n> .\n>\n",
          "createdAt": "2018-07-05T12:16:24Z",
          "updatedAt": "2018-07-05T12:16:24Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, if you take my suggestion in #142 (which I know @kazuho doesn't like, but we simply disagree about that), then you can identify the ESNI using a truncated hash that is calculated using the cipher hash because it only appears in the context of a handshake.  But that just suggests that this is either not-helpful because we chose not to do anything in #142, or it is not necessary because we did.  I'm OK closing this on that basis.",
          "createdAt": "2019-07-03T00:40:10Z",
          "updatedAt": "2019-07-03T00:40:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Checksum is now gone. Closing this issue. @martinthomson, thanks for filing it!",
          "createdAt": "2019-07-03T01:20:45Z",
          "updatedAt": "2019-07-03T01:20:45Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWUzMzg0MjgzNjA=",
      "title": "checksum",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/65",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Does the advertisement really need a checksum?  It complicates things for questionable benefit.\r\n\r\nUse DNS-over-something-that-isn't-as-lame-as-UDP and this problem goes away.  You probably want DNS to be protected by TLS anyway.",
      "createdAt": "2018-07-05T05:06:36Z",
      "updatedAt": "2019-06-02T15:01:11Z",
      "closedAt": "2019-06-02T15:01:11Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on https://github.com/ekr/draft-rescorla-tls-esni/pull/23 and https://www.ietf.org/mail-archive/web/tls/current/msg26532.html, I prefer to have the checksum for end-to-end integrity checking and to not have increased risk of service disruption for better adoption of ESNI; otherwise the hosts that using ESNI would stick out.\r\n\r\nIt's not only when transmitting data over the wire that the ESNIKeys might get corrupt. That could happen before the record gets installed on the authoritative server, or while the data is being cached in a resolver. Or we might have other conveyer in the future.",
          "createdAt": "2018-07-05T06:11:18Z",
          "updatedAt": "2018-07-05T06:11:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I don't find those arguments particularly persuasive.  The biggest risk is misconfiguration, which - given the nature of this - won't be persistent.  Sites that do this will test their code and once it is fixed, it should work.\r\n\r\nAs for network-level corruption, that's rare, and DNS over TLS (or DoH) aren't really vulnerable to that.",
          "createdAt": "2018-07-05T09:53:00Z",
          "updatedAt": "2018-07-05T09:53:00Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that corruption is rare; the question is if it is as rare as TCP transferring corrupt data.\r\n\r\nI would like to also point out that corruption cannot be immediately fixed; you need to wait for the cached records to expire. And even if you use DNS over TLS or DOH between the client and the resolver, you could still be using unauthenticated DNS over UDP between the resolver and the authoritative server.",
          "createdAt": "2018-07-05T15:33:51Z",
          "updatedAt": "2018-07-05T15:33:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho @martinthomson shall we consider this issue resolved?",
          "createdAt": "2019-01-19T01:15:44Z",
          "updatedAt": "2019-01-19T01:15:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Considering resolved. ",
          "createdAt": "2019-06-02T15:01:11Z",
          "updatedAt": "2019-06-02T15:01:11Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWUzMzg0MjkwNzg=",
      "title": "Contributory behaviour",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/66",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "This might not need the same level of rigour as TLS itself, but the construction of the keys could be better.  Right now, Z is dependent on contributory behaviour.\r\n\r\nI recommend that rather than just hashing `ClientHello.random`, a pseudo-message be constructed that includes the random, the server advertisement (in its entirety), the client's key share in some form, and maybe the prologue of the esni extension as well.  Essentially the entire mini-protocol we're using.",
      "createdAt": "2018-07-05T05:12:12Z",
      "updatedAt": "2018-10-21T20:35:43Z",
      "closedAt": "2018-10-21T20:35:43Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "+1\r\n\r\nClarification question: and we will be using Derive-Secret to extract the keys to encrypt the ESNI extension? I think we should, so as to align the key derivation process to the norm.",
          "createdAt": "2018-07-05T07:27:14Z",
          "updatedAt": "2018-07-05T07:27:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, using Derive-Secret would be best, I think. Try to keep the entire process aligned with existing practice.",
          "createdAt": "2018-07-05T09:54:27Z",
          "updatedAt": "2018-07-05T09:54:27Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "We didn't do Derive-Secret, but otherwise we did this.",
          "createdAt": "2018-10-21T20:35:11Z",
          "updatedAt": "2018-10-21T20:35:11Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWUzMzg0MjkzNTg=",
      "title": "Use different client key shares for ESNI and TLS KE?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/67",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Using the same key share looked like a good idea, but it's actually a real pain to implement because you need to get pretty involved with the TLS 1.3 key exchange.\r\n\r\nAnother approach would be to have separate keys but bind the ClientHello.KeyShare extension into the ESNI extension. I had thought of putting a hash in the extension plaintext but @martinthomson points out that if you use it as AAD, then the client-facing server will automatically detect mismatch\r\n\r\n",
      "createdAt": "2018-07-05T05:14:20Z",
      "updatedAt": "2018-10-21T20:43:09Z",
      "closedAt": "2018-10-21T20:43:09Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Using the same key share looked like a good idea, but it's actually a real pain to implement because you need to get pretty involved with the TLS 1.3 key exchange.\r\n\r\nI am not sure if we are going to have such pain in general. In my view, what you can do is as follows:\r\n* construct encrypted_server_name extension\r\n* construct ClientHello, with passing in the ESNI extension and the key-exchange context that was used for constructing the extension as the arguments\r\n  * add the key-exchange context being passed in to ClientHello\r\n  * omit constructing a key-exchange context if the id of the context to-be-constructed matches that of the supplied context\r\n\r\nTo me, they seem to be fairly limited change.\r\n\r\nGenerally speaking, I think the question of if we should have different key shares depends on if we want to apply different crypto to the ESNI and the TLS application payload. My preference is to use single crypto whenever possible for simplicity and in hope that we can reuse ESNIKeys for other purposes in the future.",
          "createdAt": "2018-07-05T05:56:41Z",
          "updatedAt": "2018-07-05T05:56:52Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I had thought of putting a hash in the extension plaintext but @martinthomson points out that if you use it as AAD, then the client-facing server will automatically detect mismatch\r\n\r\n:+1:\r\n\r\nEDIT: Well, but then a server cannot use the digest to find the corresponding ESNIKeys (and the private key). So while I agree that using it as AAD makes sense, I do not think that we can omit the hash. We could send something other than a hash (e.g., ID) though.",
          "createdAt": "2018-07-05T06:20:02Z",
          "updatedAt": "2018-07-05T06:22:16Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, there are two values here:\r\n\r\n1. The ESNIKeys hash, which I agree has to be in the clear.\r\n2. The hash of KeyShares to prevent substitution attacks.\r\n\r\n@kazuho: I agree it's doable, as I just got my POC working. Yes, the CH is as you say, which is modestly disruptive. On the server side it's a bit disruptive because of the way NSS handles extensions, which is to say in-order. So, ESNI could come either before or after KeyShares. I could refactor this of course.\r\n\r\nIt also affects negotiation, so if the client didn't pick the server's most preferred group, you have to refrain from sending HRR, which is a bit of a pain.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2018-07-05T14:05:46Z",
          "updatedAt": "2018-07-05T14:05:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for the clarification.\r\n\r\nI can understand the pain on the server-side. Current approach of ESNI changes the negotiation from client-offers-a-list-server-chooses-one, to server-offers-a-list-client-chooses-one.\r\n\r\nI think that it might be fine to revert to the TLS 1.3 way of negotiation. Actually we might be required to do that, if we want to prevent a client-facing server downgrading the crypto in the split server scenario.\r\n\r\nOTOH, I am not sure if we would want to use a _separate_ key share for ESNI, because that would require additional CPU cost. My benchmark tells me that in case of X25519, key generation takes about half the time of key derivation. That means that if we are going to have separate key shares but the algorithm collides, the client will be spending 17% more CPU cycles (i.e. 1 key generation + 2 derivations vs. 2 key generations and 2 derivations).\r\n\r\nConsidering the cost, I think that we'd be tempted to try reuse the key-share for two purposes (i.e. ESNI and TLS handshake), even if we define separate key exchange fields for the two.\r\n\r\nAnd that in turn make me wonder what the value is for having separate key exchange fields.\r\n\r\nTo summarize, I do not oppose to allowing client send multiple key shares or allowing server send HRR when ESNI is involved, but I prefer using the value of the KeyShares extension for carrying the ECDH key being used to encrypt ESNI.",
          "createdAt": "2018-07-05T16:06:35Z",
          "updatedAt": "2018-07-05T16:06:35Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> To summarize, I do not oppose to allowing client send multiple key shares or allowing server send HRR when ESNI is involved, but I prefer using the value of the KeyShares extension for carrying the ECDH key being used to encrypt ESNI.\r\n\r\nFWIW, I've created #70 that implements this, hoping that having a PR would help us evaluate the approach.",
          "createdAt": "2018-07-05T23:20:56Z",
          "updatedAt": "2018-07-05T23:20:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed",
          "createdAt": "2018-10-21T20:43:09Z",
          "updatedAt": "2018-10-21T20:43:09Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWUzMzg1MDgxMDI=",
      "title": "Limit this to DNS names",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/68",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Extensibility failed for SNI, no point in repeating that failure.  This is less complex:\r\n\r\n```\r\n   struct {\r\n       opaque domain_name<1..255>;\r\n       opaque zeros[ESNIKeys.padded_length - length(sni)];\r\n   } PaddedServerNameList;\r\n```\r\n\r\n",
      "createdAt": "2018-07-05T10:03:54Z",
      "updatedAt": "2020-10-16T17:14:14Z",
      "closedAt": "2019-07-03T20:30:29Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Are there other ways we expect servers to select certificates? I can imagine a scenario where clients pin server leaf certificates, and hint servers to the right leaf certificate by sending the leaf SPKI hash in the SNI. Would we want to rule something like that out?",
          "createdAt": "2019-01-19T01:19:07Z",
          "updatedAt": "2019-01-19T01:19:07Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWUzMzg1OTY5MDU=",
      "title": "ESNIKeys can be used for Downgrade",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/69",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Say that you have a server whose policy is that it will accept any KeyShare that is in the overlap between the client and server supported_groups (this isn't really an advisable policy). An on-path to DNS attacker can force you into the weakest joint group by creating an invalid ESNIKeys structure with a key in that group. The client will then send a KeyShare in that group, and you have been undetectably downgraded. Note that this will lead to suppression of SNI (because the client will be encrypting), but many servers don't require SNI. This works even against a non-ESNI servers.\r\n\r\nThere's also a weaker attack in which the client-facing server just sends a weaker share in ESNIKeys. This will be very hard for the server to detect.\r\n\r\nThis doesn't seem ideal, and I'm not quite sure how to remove it. This seems like an argument for #67 if we can make that work.\r\n\r\nThanks to @tvdmerwe for discussions leading to this.\r\n\r\n@kazuho: ^^\r\n",
      "createdAt": "2018-07-05T14:23:23Z",
      "updatedAt": "2018-10-21T20:35:33Z",
      "closedAt": "2018-10-21T20:35:33Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "See also the big disclaimer at the top :)",
          "createdAt": "2018-07-05T14:25:41Z",
          "updatedAt": "2018-07-05T14:25:41Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> An on-path to DNS attacker can force you into the weakest joint group by creating an invalid ESNIKeys structure with a key in that group. The client will then send a KeyShare in that group, and you have been undetectably downgraded.\r\n\r\nI do not think that the attack works against servers that support ESNI. The server will fail to find the private key that matches the ESNIKeys being used by the client (based on the value of record_digest), and the handshake will fail (that is the defense we implemented in #24).\r\n\r\n> This works even against a non-ESNI servers.\r\n\r\nI think that this is true. One way to fix the issue will be to use the value of ESNIKeys as an input to the Key Schedule (see #66), but a fix like that will not work with unmodified hidden server in Split mode. \r\n\r\nHaving that said, I am not sure if this is kind of an attack we need to fix. An attacker that can tamper the DNS responses can mount a DoS attack in a simpler way: send a negative response to an A query. Our model of sending unauthenticated ESNIKeys over DNS is based on the perception that DoS or preventing ESNI from working is possible when unauthenticated transmission of DNS is involved, but that does not open _new_ attack vectors.\r\n\r\n> There's also a weaker attack in which the client-facing server just sends a weaker share in ESNIKeys. This will be very hard for the server to detect.\r\n\r\nThis is true. I think the question here is if we want to permit using different key-shares / cipher-suites for ESNI and application data. As you point out, it relates to #67.",
          "createdAt": "2018-07-05T15:25:50Z",
          "updatedAt": "2018-07-06T00:06:44Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with the new structure.",
          "createdAt": "2018-10-21T20:35:33Z",
          "updatedAt": "2018-10-21T20:35:33Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWUzNDAzOTE3OTc=",
      "title": "don't base 64 encode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/74",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "dns records are 8 bit clean and rfc 6763 is an example of a TXT record carrying arbitrary data\r\n\r\n",
      "createdAt": "2018-07-11T20:22:17Z",
      "updatedAt": "2019-03-06T22:44:27Z",
      "closedAt": "2019-03-06T22:44:26Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1:\r\n\r\nBase64 is not only complication. It is a space overhead for a large object like ESNIKeys. Seeing corruption of binary will be rare; we can detect them by validating the checksum and fallback to non-ESNI in such case. So why not go for binary?\r\n\r\nFWIW, base64 was introduced in #18.",
          "createdAt": "2018-07-11T21:47:07Z",
          "updatedAt": "2018-07-12T03:38:17Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is solved in #73 which removes base64 with new ESNI RR type.",
          "createdAt": "2018-07-12T12:09:29Z",
          "updatedAt": "2018-07-12T12:09:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We only added this since TXT records were claimed to not work well with binary, per Christian\u2019s suggestion. I\u2019m fine either way. ",
          "createdAt": "2018-07-12T12:53:32Z",
          "updatedAt": "2018-07-12T12:53:32Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the info. I found https://github.com/ekr/draft-rescorla-tls-esni/issues/14#issuecomment-388573921, in which @huitema asks:\r\n> I really have two concerns, the maximum length and the char requirement. The latter may be an harder issue. For example, can I set a TXT record to contain binary data if I use Amazon's Route 53 service?\r\n\r\nWe know that we can store more than 128 octets in TXT record, and that we have a precedent that uses TXT to store binary data, as @mcmanus has pointed out.\r\n\r\nRegarding configurability, my understanding is that RFC 1035 defines how binary TXT records can be specified in a zone file, and therefore many DNS server \"softwares\" support having such records. Googling also tells me that managed DNS services like Route 53 and Azure DNS provide the capability, although surprisingly they use different escape sequences ([Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/ResourceRecordTypes.html#TXTFormat) uses `\\` + 3 octal, [Azure](https://docs.microsoft.com/en-US/azure/dns/dns-faq) uses `\\` + 3 decimal).",
          "createdAt": "2018-07-12T14:33:32Z",
          "updatedAt": "2018-07-12T14:33:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not think it\u2019s a complication, and I\u2019m not convinced space is an issue as per your comment above.",
          "createdAt": "2018-07-12T14:58:53Z",
          "updatedAt": "2018-07-12T14:58:53Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "only tangentially related - @kazuho do you know why your examp1e.net txt record is broken into 127 char strings instead of 255? Is there a bug being worked around somewhere?",
          "createdAt": "2018-07-12T15:15:10Z",
          "updatedAt": "2018-07-12T15:15:10Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus Oh I did not notice that. I am using tinydns (of djbdns), and it seems like tinydns works that way (see https://github.com/abh/djbdns/blob/master/tinydns-data.c#L402).",
          "createdAt": "2018-07-12T15:53:20Z",
          "updatedAt": "2018-07-12T15:53:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood The issue about the size is that with base64 we might hit the 512-octet threshold when publishing keys of multiple strengths.\r\n\r\nAs an example, query for _esni.esni.examp1e.net currently returns a 186-byte response, which contains just secp256r1 key. If we add secp384r1 and secp521r1, I'd assume that the size will come near to 490 octets. In other words, for longer hostnames we will hit the 512-octet threshold if we publish three keys.\r\n\r\nIf we avoid the base64 encoding, we will have enough room to store 3 ECDH keys that can provide 128-, 192-, 256-bit-level security.\r\n\r\nI do not think this argument is strong enough to prohibit the use of base64 for the following reasons:\r\n\r\n* we will be using DoH / DNS over TLS between the client and the resolver\r\n* we might be using DNS over UDP that has the 512-octet threshold between the resolver and the authoritative server, but we would want that to migrate to DNSSEC or something even better\r\n* we might be just fine with publishing only two keys: X25519, X448\r\n\r\nBut it does make me prefer not to have the overhead of base64, if that is possible.",
          "createdAt": "2018-07-12T16:09:19Z",
          "updatedAt": "2018-07-12T16:09:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T22:44:26Z",
          "updatedAt": "2019-03-06T22:44:26Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWUzNDEzMjM3MDI=",
      "title": "iana registry for underscore scoped name",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/75",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/draft-ietf-dnsop-attrleaf/\r\n\r\nis in wglc and seems likely to become a standards track doc.\r\n\r\nIt establishes a registry for undesrscore scoped names\r\n```\r\n      \"Per\" [Attrleaf] \"please add the following entry to the DNS\r\n      Underscore Global Scoped Entry Registry:\"\r\n\r\n   +--------+----------------+-----------------------------------------+\r\n   | RR     | _NODE NAME     | REFERENCE                               |\r\n   | Type   |                |                                         |\r\n   +--------+----------------+-----------------------------------------+\r\n   | TXT    | _esni          | this document                           |\r\n   +--------+----------------+-----------------------------------------+\r\n```\r\n\r\nit means a blocking reference to ATTRLEAF, but that doesn't seem like a problem time wise",
      "createdAt": "2018-07-15T14:05:39Z",
      "updatedAt": "2018-07-15T14:36:02Z",
      "closedAt": "2018-07-15T14:36:02Z",
      "comments": []
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWUzNDI4NjExMjI=",
      "title": "_esni prefix is challenging for DNS wildcard syntax with TXT type",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/79",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "if you dynamically syntehsize a whole bunch of names in example.com you would probably use a *.example.com a/aaaa configuration to do so and give them all the same addresses.\r\n\r\nbut you can't do the same things for TXT records with the _esni prefix..  basically _esni.*.example.com doesn't do the trick (rfc 4592).\r\n\r\ninitially I viewed this as a configuration and implementation issue because queries and responses do not carry the * at all - the records are synthesized on demand from this config.\r\n\r\nhowever, the wildcard is part of AXFR which forms an open interface between resolvers so its syntax and meaning is quite reasonably standardized and should be considered.\r\n",
      "createdAt": "2018-07-19T19:34:14Z",
      "updatedAt": "2019-03-06T22:43:23Z",
      "closedAt": "2019-03-06T22:43:23Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> however, the wildcard is part of AXFR which forms an open interface between resolvers\r\n\r\nMinor point but I am not sure if AXFR is something that is exposed to the resolvers. My understanding is standardized interface for synchronizing authoritative servers. So this will be an issue only for websites that use a DNS that either depends on AXFR (or in other ways depend on the vocabulary of the AXFR).\r\n\r\nI agree that it would be preferable to address the issue.",
          "createdAt": "2018-07-19T19:55:58Z",
          "updatedAt": "2018-07-19T19:55:58Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "my thought here is that axfr represents an interface between, potentially,\ndifferent implementations so we should try and respect that to whatever\nextent is possible.\n\nOn Thu, Jul 19, 2018 at 3:55 PM, Kazuho Oku <notifications@github.com>\nwrote:\n\n> however, the wildcard is part of AXFR which forms an open interface\n> between resolvers\n>\n> Minor point but I am not sure if AXFR is something that is exposed to the\n> resolvers. My understanding is standardized interface for synchronizing\n> authoritative servers. So this will be an issue only for websites that use\n> a DNS that either depends on AXFR (or in other ways depend on the\n> vocabulary of the AXFR).\n>\n> I agree that it would be preferable to address the issue.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/issues/79#issuecomment-406395145>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAP5s4s6W1bSbCrcAOda5E9l00lvVmO5ks5uIORPgaJpZM4VW-J6>\n> .\n>\n",
          "createdAt": "2018-07-19T20:08:48Z",
          "updatedAt": "2018-07-19T20:08:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My view of the issue is that we can support all the models that we need to support if we adopt #73 so that ESNIKeys will be distributed using a dedicated type with a prefix.\r\n\r\nThe patterns we need to consider are the combination of three types of DNS records (i.e. single-host, APEX, wildcard) and a boolean indicating if DNS is maintained by someone other than the CDN.\r\n\r\nThe table below illustrates how you could configure the DNS on each case. There are certain cases in which you could use CNAME instead of A / ESNI.\r\n\r\n|**DNS operated by**|**single-host**|**APEX**|**wildcard**|\r\n|:---|:---|:---|:---|\r\n|**CDN**|host IN A addr<br>_esni.host IN ESNI ...|@ IN A addr<br>_esni IN ESNI ...|* IN A addr<br>* IN ESNI ...<sup>1</sup>|\r\n|**not CDN**|host IN CNAME addr<br>_esni.host CNAME _esni.cdn|@ IN A cdn-ipaddr<br>_esni IN CNAME _esni.cdn|* IN CNAME cdn<sup>1<sup>|\r\n\r\n1: You will be required to create _esni records for all hosts that you specify explicitly, if it is necessary to disable ESNI for those hosts (or if those hosts use different ESNI keys).",
          "createdAt": "2018-07-19T22:55:42Z",
          "updatedAt": "2018-07-19T22:57:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T22:43:23Z",
          "updatedAt": "2019-03-06T22:43:23Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "MDU6SXNzdWUzNDMwOTIxNDE=",
      "title": "Add consolidations considerations section",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/80",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-20T12:38:51Z",
      "updatedAt": "2020-10-16T17:14:14Z",
      "closedAt": "2019-07-03T00:11:14Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you explain what you mean about this? Or submit a PR",
          "createdAt": "2018-10-21T20:46:21Z",
          "updatedAt": "2018-10-21T20:46:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr I missed your comment.... in October. Oops. Closing as NTBF. We can add text if required later.",
          "createdAt": "2019-07-03T00:11:14Z",
          "updatedAt": "2019-07-03T00:11:14Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "MDU6SXNzdWUzNDU0OTU2MDE=",
      "title": "Mix client KeyShare into AEAD to prevent malleability",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/81",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See \r\nhttps://mailarchive.ietf.org/arch/msg/tls/rc_tgkgVIeB4yeNCgPcyPzRnrBI",
      "createdAt": "2018-07-29T02:37:15Z",
      "updatedAt": "2018-10-21T20:34:12Z",
      "closedAt": "2018-10-21T20:34:11Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Done.",
          "createdAt": "2018-10-21T20:34:11Z",
          "updatedAt": "2018-10-21T20:34:11Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWUzNDU0OTU2ODI=",
      "title": "Consider new extension that permits server to supply new ESNI key upon mismatch",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/82",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the connect fails when a mismatch occurs. An alternative strategy might be to return a new ESNI key that is then used for a subsequent connection.",
      "createdAt": "2018-07-29T02:39:04Z",
      "updatedAt": "2019-02-26T21:14:12Z",
      "closedAt": "2019-02-26T21:14:12Z",
      "comments": [
        {
          "author": "yfdyh000",
          "authorAssociation": "NONE",
          "body": "How to understand the reliability of the public key from server?",
          "createdAt": "2018-09-14T18:01:17Z",
          "updatedAt": "2018-09-14T18:01:17Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWUzNDU0OTU3Mzk=",
      "title": "Discuss query strategies and how to deal with loss",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/83",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The order of DNS queries may matter in systems that use Happy Eyeballs. Also, should TLS connections block until ESNI key queries come back? What if they never come back?",
      "createdAt": "2018-07-29T02:40:53Z",
      "updatedAt": "2018-08-14T17:13:09Z",
      "closedAt": "2018-08-14T17:13:09Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "can you elaborate on what you're thinking about wrt he? (assuming the inaddr.arpa plan is off the table)",
          "createdAt": "2018-08-05T00:47:26Z",
          "updatedAt": "2018-08-05T00:47:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Basically addressed in #86.",
          "createdAt": "2018-08-14T17:13:09Z",
          "updatedAt": "2018-08-14T17:13:09Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWUzNDYzMjgyMTc=",
      "title": "Supporting multiple protocols text is slightly misleading",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/84",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Replace \r\n\r\n\"It only affects connection routing, server certificate selection, and client certificate verification.\" \r\n\r\nwith \r\n\r\n\"It may affect connection routing, server certificate selection, and client certificate verification.\" ",
      "createdAt": "2018-07-31T19:33:47Z",
      "updatedAt": "2020-10-16T17:14:14Z",
      "closedAt": "2019-07-03T00:15:11Z",
      "comments": [
        {
          "author": "yfdyh000",
          "authorAssociation": "NONE",
          "body": "https://ekr.github.io/draft-rescorla-tls-esni/draft-rescorla-tls-esni.html#rfc.section.7.2.8\r\nIt is relative to \"This design has no impact on application layer protocol negotiation.\", so \"only\" is more explicit.",
          "createdAt": "2018-09-14T18:05:32Z",
          "updatedAt": "2018-09-14T18:05:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed in #87 and I forgot to close. ",
          "createdAt": "2019-07-03T00:15:11Z",
          "updatedAt": "2019-07-03T00:15:11Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWUzNTIwMTIwODc=",
      "title": "DNS record disadvantage & Purpose enhancement & My suggestion",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/88",
      "state": "CLOSED",
      "author": "JemmyLoveJenny",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I don't know that I can give out my advice here before, so I had written an e-mail to draft-rescorla-tls-esni@ietf.org and that's my first time to send an email to IETF. I don't know whether sending an e-mail is the right thing, so I would paste it here again.\r\n\r\nI'm not a native English speaker, I would apologize for my poor English first.\r\n\r\n\r\n### DNS record disadvantage\r\n\r\n#### 1.Impossible for wildcard A or AAAA record\r\n\r\nIt isn't possible for us to set a txt record for wildcard A or AAAA record (_esni.*.example.com. 60S IN TXT \"...\" \"...\"). \r\nThe same problem as https://github.com/ekr/draft-rescorla-tls-esni/issues/79 mentioned.\r\n\r\n#### 2.Publishing a public key using DNS is very inconvenient and insecure. \r\n\r\nIn general, we can't change the DNS record very conveniently (except some DNS which provide API), so that most domain owners won't change the key very often. \r\n\r\nAnd in some cases, domain owners host their site at host service providers (I don't know how to explain that in English. Host service provider use one physical or virtual server to host many sites) once the provider want to change the ESNI public key, all owners on this server need to change their txt record on time, which is very inconvenient and nearly impossible.\r\n\r\nThe lack of frequently changing public key and the lack of Perfect Forward Security only provide us little security.\r\n\r\n#### 3.DNS record limited only exist domains can enable ESNI\r\n\r\nAs DNS record is needed to be set, only the owner of a exist and valid domain can enable ESNI.\r\n\r\nHowever, sometimes we want to use encrypted-sni as a private entry. For example, I configured my server that client hello with the sni \"vps.panel\" would lead to the vps control panel ( I issued a cert for \"vps.panel\" from my own PKI ). Though I configured that the server must verify my identity using a client certificate, I don't want this private sni to be known to the public. But your draft's method won't allow this use case as \"vps.panel\" isn't a valid domain name, so that I won't be able to own this domain and set a DNS record for it.\r\n\r\n#### 4.Local DNS (hosts) won't work\r\n\r\nThe hosts file can only take the place of A and AAAA record and won't be able to set public key in hosts in the near future.\r\n\r\n#### 5.Requirements to the server is too high\r\n\r\nThis ESNI draft requires that the server can the decrypt the sni which is encrypted by any public key. This means that the server has to take hold all ESNI private keys. However, I think that it's not proper.  \r\nTo CDN service provider like Cloudflare, it means that one Cloudflare server has to storage all private ESNI keys of the websites hosted on it.  \r\nIn my opinion, the browser should encrypt the sni using all public keys found in the DNS record and add a few invalid ESNI along with those, to prevent the attacker identify the real sni from the number of public keys.\r\n\r\n\r\n### Purpose Enhancement - Wall-resistent\r\n\r\nIn some countries (e.g. China, North Korea, Iran) , people may want to use ESNI to break the government's GreatFireWall, which blocks people from visiting some website.\r\n\r\nThe wall isn't just a wall, but a very complicated system which can modify DNS resolve result ( DNSSEC isn't common ). They can simply block all _esni txt record, so that all browsers can' get the public key and downgrade to cleartext-sni.\r\n\r\nIf ESNI can be used with SNI Proxy, it would be a good solution to break the wall. However the DNS record limited only the owner can enable ESNI ( Another disadvantage of DNS :D )\r\n\r\n\r\n### My suggestions\r\n\r\nI think some ideas of https://datatracker.ietf.org/doc/draft-ietf-tls-sni-encryption/ is quite good. One good idea is to use a certificate to authenticate the Client-Facing Server instead of publishing a public key. My main idea is to introduce a series of HTTP headers like HSTS and HPKP. I will give an example below:\r\n\r\nFirstly, I would introduce these headers\r\n( These names may be not proper due to my poor English )\r\n\r\n```\r\nESNI:(preload);(includeSubdomains);max-age=??\r\nIf ESNI header presents in the response, it means this domain enables ESNI. Otherwise, the browser MUST ignore other ESNI-* headers.\r\ne.g.\r\nESNI:preload;includeSubdomains;max-age=31536000\r\n\r\nESNI-Resolve:{address};max-age=??\r\n{address} can be either FQDN or IP(s) the purpose is to hide the real domain during DNS resolve. The server MUST keep this header up-to-date. This header just like a cacheable CNAME record.\r\ne.g. \r\nESNI-Resolve: server233.domain-cdn.com;max-age=31536000\r\nESNI-Resolve: 0.0.0.0/16;max-age=2592000\r\nESNI-Resolve: 1.1.1.1;max-age=2592000\r\n\r\nESNI-Trust:{address or pin-hash};max-age=??\r\n{address} is the same as above. The only difference is that the FQDN can contain wildcard.\r\n{pin-hash} is similar to HPKP's pin-hash.\r\nCan have more than one this header in the HTTP Response. (Explain later)\r\ne.g.\r\nESNI-Trust:fqdn{ *.domain-cdn.com};max-age=31536000\r\nESNI-Trust:ip{0.0.0.0/16};max-age=31536000\r\nESNI-Trust:pin-hash{X523zEOQCuEJeU6PzewOGkKCRX+YLvfAsCYJbQubCuE=};max-age=31536000\r\n\r\n\r\nESNI-Policy:{policy};max-age=??\r\n{policy} can be \"force-encrypted-sni\", \"retry-clear-sni\", \"allow-dns-re-resolve\", \"disallow-dns-re-resolve\" defines the action if error happens using ESNI. \r\nCan have more than one this header in the Response. (Explain below)\r\n```\r\n\r\nIt's impossible to have more than one header with the same name, but we may construct these in to a structure and encode (e.g.base64) into one header. The header may be very big, but don't worry, only the first response contains it, HTTP2 will automatically compress them into a few bits in the later response.\r\n\r\nWhen the first time I visit https://www.example.com , I just do the normal tls1.3 hand shake with clear-text sni. The server just do what it should do, but the response MUST contain those ESNI headers if ESNI is enabled. The browser MUST remember these headers ( unless in incognito mode )\r\n\r\nWhen the second time I visit https://www.example.com , the browser SHOULD NOT query DNS resolve for www.example.com, instead, it should visit the FQDN/IP mentioned in the ESNI-Resolve header. And the browser MUST NOT send clear-text sni in the ClientHello, instead, send a CH without sni or a special CH indicates using ESNI.  The Client-Facing Server  send back certificate, the browser validates the certificate and makes sure the certificate contains at least one FQDN/IP mentioned in the ESNI-Trust header. If mismatch, check the ESNI-Policy and determine whether to retry or not. \r\nAnd then re-handshake with the server with encrypted-ClientHello in the 0RTT data or another CH extension. \r\n( similar to draft-ietf-tls-sni-encryption method )\r\n\r\nMy suggestions' advantages and disadvantages are nearly the same as draft-ietf-tls-sni-encryption method. It provides PFS, don't need to change the Split-Mode Server and solved some part of DNS sniffing. But the disadvantage is obvious too, the first hand shake can't be encrypted and the ESNI-Resolve may become incorrect over time. It needs to handshake twice, however, it provided PFS and I think it worth it. And if multiple sites are hosted on the same server (e.g.CDN, Host Service Provider), we just need to do the second handshake, which eliminate the risk of DoS attack in some level.... And I think 0RTT symmetric decryption is better than asymmetric decryption.\r\nSetting max-age too big or too small both have some risks, and I don't know how to solve it.\r\n\r\n**If you don't like the idea of authenticating the Client-Facing Server, you can simply replace the ESNI-Trust header's content into a public key and use your method. But I don' think set a static public key is a good idea ( explained in some part of DNS disadvantage ).**\r\n\r\nAll in all, we can't have both efficiency, performance and security,  reliability. You should make up your mind and choose whether to provide perfect security or perfect performance. I prefer the former.\r\n\r\nI know that my idea is similar to draft-ietf-tls-sni-encryption than yours. However, you are the candidate for TLS WG, so I hope you can think it over. But I do agree with your idea that \"no need to don't stick out\" or simply \"we can stick out\" :D",
      "createdAt": "2018-08-20T07:15:32Z",
      "updatedAt": "2018-10-21T20:44:31Z",
      "closedAt": "2018-10-21T20:44:31Z",
      "comments": [
        {
          "author": "yfdyh000",
          "authorAssociation": "NONE",
          "body": "> so that all browsers can' get the public key and downgrade to cleartext-sni.\r\n\r\nhttps://github.com/ekr/draft-rescorla-tls-esni/blob/master/draft-ietf-tls-esni.md#misconfiguration prevent this case happening.\r\n\r\n> My main idea is to introduce a series of HTTP headers like HSTS and HPKP. \r\n> When the first time I visit https://www.example.com , I just do the normal tls1.3 hand shake with clear-text sni.\r\n\r\nThis introduces exposure and interception opportunities; a TLS connection that remains connected may not require an external SNI. (I am not sure)\r\n\r\nTLS also works with protocols other than HTTP(S). If the ESNI relies on HTTP headers, it is HTTPS only.",
          "createdAt": "2018-09-14T17:45:18Z",
          "updatedAt": "2018-09-14T17:45:18Z"
        },
        {
          "author": "JemmyLoveJenny",
          "authorAssociation": "NONE",
          "body": "@yfdyh000 \r\n> This introduces exposure and interception opportunities; a TLS connection that remains connected may not require an external SNI. (I am not sure)\r\n> \r\n> TLS also works with protocols other than HTTP(S). If the ESNI relies on HTTP headers, it is HTTPS only.\r\n\r\nTo solve this problem, we can simply change from HTTP headers to TLS extensions. In TLS1.3, handshake extensions are encrypted as well. The only thing need to be done is defining the structure of these settings.",
          "createdAt": "2018-09-15T08:51:53Z",
          "updatedAt": "2018-09-15T08:51:53Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Not seeing much support for removing DNS here, so closing this issue.",
          "createdAt": "2018-10-21T20:44:31Z",
          "updatedAt": "2018-10-21T20:44:31Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWUzNjI5ODY2OTg=",
      "title": "Should the server send the SNI confirmation extension?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/97",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-23T23:20:42Z",
      "updatedAt": "2018-10-21T20:33:05Z",
      "closedAt": "2018-10-21T20:33:05Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed when we added the nonce",
          "createdAt": "2018-10-21T20:33:05Z",
          "updatedAt": "2018-10-21T20:33:05Z"
        }
      ]
    },
    {
      "number": 99,
      "id": "MDU6SXNzdWUzNjg0MzcwOTc=",
      "title": "Add a reference to draft-ietf-dns-attrleaf",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/99",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As well as the IANA registrations",
      "createdAt": "2018-10-09T23:27:53Z",
      "updatedAt": "2018-10-21T22:21:25Z",
      "closedAt": "2018-10-21T22:21:25Z",
      "comments": []
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWUzNzMwMTI3ODU=",
      "title": "Extension as vector of ClientEncryptedSNI structures",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/103",
      "state": "CLOSED",
      "author": "roelfdutoit",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Please consider changing the ESNI client extension to a vector of ESNI values.  This could be used for server-side redundancy and key rollover.  I understand that only one of the entries would be ack'd in EE, and that we would have to think through the possible attacks on the mechanism due to the change.\r\n",
      "createdAt": "2018-10-23T13:54:25Z",
      "updatedAt": "2019-07-03T21:06:44Z",
      "closedAt": "2019-07-03T21:06:44Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@roelfdutoit can you please bring this issue to the list for further discussion?",
          "createdAt": "2019-07-03T03:52:22Z",
          "updatedAt": "2019-07-03T03:52:22Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWUzNzM3Mzc3MDQ=",
      "title": "remove _esni prefix because it makes CNAME alias too hard",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/105",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "issue #7 briefly discussed the choice of a _esni DNS prefix for the TXT record. I think we should revisit that.\r\n\r\nMy primary concern is that using 2 different names for the addressing and key information makes DNS aliasing un-necessarily complicated.\r\n\r\nConsider the case where www.example.com is a customer of bigHoster.com and bigHoster.com is deploying ESNI for all its customers.\r\n\r\nA classic way to do this is to have www.example.com be a CNAME for host1.bighoster.com\r\n\r\nunfortunately to use bighoster.com's new ESNI infrastructure www.example.com would need to add a CNAME record for _esni.www.example.com as well. So the ESNI deployment requires DNS changes outside of the org deploying ESNI, which is going to limit its deployment, which in turn is going to limit the breadth of its anonymity pool. :(\r\n\r\nAdditionally, I've been told that anecdotally putting names under a CNAME is legal but error prone. RFC 1912 seems to have some language that suggests its not even legal (though that is informational).\r\n\r\nIf the ESNI information were instead stored without a prefix then the alias would automatically apply as the CNAME applies to all the RR's of a hostname.\r\n\r\nPart of the reason for choosing the prefix was to avoid collisions in the TXT space, so it makes sense to also reopen #40 and use a non TXT RR type if we drop the prefix. I think the consensus is moving towards that being fine.\r\n\r\nThis would also resolve #79 to harmonize esni with existing dns deployments.\r\n\r\n",
      "createdAt": "2018-10-25T01:31:36Z",
      "updatedAt": "2019-03-06T00:55:58Z",
      "closedAt": "2019-03-06T00:55:58Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I forgot to acknowledge the downside here is with apex records. You can't cname an apex record, so the normally annoying second cname with the prefix is actually the only thing the apex can use natively as an alias and this proposal gives that up.\r\n\r\notoh apex records inline someone's A records (usually a single provider's anycast) already so they can  do the same thing with esni.. and/or we could allow some kind of delegation explicitly as part of the new rrtype (i.e. delegation within the new rrtype data, not via cname)",
          "createdAt": "2018-10-25T01:35:32Z",
          "updatedAt": "2018-10-25T01:35:32Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "also see pr #73 ",
          "createdAt": "2018-10-25T01:36:59Z",
          "updatedAt": "2018-10-25T01:36:59Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> unfortunately to use bighoster.com's new ESNI infrastructure www.example.com would need to add a CNAME record for _esni.www.example.com as well. So the ESNI deployment requires DNS changes outside of the org deploying ESNI, which is going to limit its deployment, which in turn is going to limit the breadth of its anonymity pool. :(\r\n\r\nI am not sure if I agree with the problem statement.\r\n\r\nTo me it seems that the argument is based on the assumption that bighoster.com is the one to decide if ESNI should be applied for www.example.com. I am not sure if all of us would be happy with that assumption.\r\n\r\nThe alternative approach here is to give the owner of each hostname the freedom of deciding whether the hostname should be covered by ESNI. Current design allows the hosting companies to adopt that model, by using the DNS configuration that the hostname owner controls as the switch.",
          "createdAt": "2018-10-25T02:49:22Z",
          "updatedAt": "2018-10-25T03:48:22Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ESNI is already a property of the server not the origin name.. in the same way the version of TLS or the cipher suite set is a property of the server.. or the level of http. All necessarily under the control of bighoster.com because it reflects whatever is available on their infrastructure.\r\n\r\nbighoster may commonly allow their customers to configure this stuff on a per customer or service basis, but that's a bit of a different take and not incompatible with the approach here.",
          "createdAt": "2018-10-25T14:04:12Z",
          "updatedAt": "2018-10-25T14:04:12Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus While that might be true, I am not sure if removing the `_esni` prefix and introducing ESNIInclude (#110) is worth the additional complexity and overhead.\r\n\r\nAssuming that we merge #109, #79 becomes a non-issue. Because a wildcard will much all names with the designated type, including the `_esni` prefix.\r\n\r\nFor example, the following configuration will support ESNI for all the hostnames under example.com, like `a.example.com`, `b.c.example.com`, because any query for `_esni.*.example.com` resolves to `*.example.com`.\r\n\r\n```\r\n*.example.com. IN A 192.0.2.1\r\n*.example.com IN ESNI ...\r\n```\r\n\r\nSo the only downside is that using prefix and a dedicated RR type at the same time might look strange. But it's practical.\r\n\r\nI am not sure if we would prefer to require alias resolution for every ESNI client.\r\n\r\nImplementation wise, it's about reimplementing what DNS recursor usually does in the stub resolver. You need to do things like detecting too many redirects and/or loops.\r\n\r\nThere would also be a performance degradation, because each client needs to do the recursive lookup, while with the prefix we can rely on the recursive resolvers to do it and cache it for other clients.\r\n\r\nTo reiterate, I wonder if there is any *practical* reason to reinvent the wheel.",
          "createdAt": "2018-11-02T04:09:19Z",
          "updatedAt": "2018-11-02T04:11:58Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "Stretching the bounds of my DNS knowledge here, but I *think* this makes divergence between the A/AAAA and ESNIKeys records much less likely.  That is, when www.example.com is served by both CDN A and CDN B, the DNS will return `www.example.com CNAME www.example.com.cdnalpha.com` or `www.example.com CNAME www.example.com.cdnbeta.com`.  If both things are record types on the same hostname, then the divergence only happens when the queries happen on opposite sides of a cached CNAME record expiring and getting the opposite answer the next time around.\r\n\r\nBut if they're separate hostnames, as in the current doc, it's entirely possible to get opposite CNAME records cached, and you've diverged for all clients of the caching resolver for the TTL of the shorter CNAME record.  That's a far worse probability of divergence.",
          "createdAt": "2019-03-01T23:06:17Z",
          "updatedAt": "2019-03-01T23:06:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144. Closing. ",
          "createdAt": "2019-03-06T00:55:58Z",
          "updatedAt": "2019-03-06T00:55:58Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWUzNzQyNzU1MTQ=",
      "title": "Unclear sentence in section 7.1 \"Why is cleartext DNS OK?\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/107",
      "state": "CLOSED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The second paragraph of this section currently contains:\r\n\r\n```\r\nClearly, DNSSEC (if the client validates and hard fails) is a defense against\r\nthis form of attack, but DoH/DPRIVE are also defenses against DNS attacks\r\nby attackers on the local network, which is a common case where SNI.\r\n```\r\n\r\nClearly, the sentence abruptly ends.\r\n\r\nMoreover, the sentence could probably be split in two, at the \"but\". This should make it easier to read.",
      "createdAt": "2018-10-26T08:19:00Z",
      "updatedAt": "2018-11-26T22:13:21Z",
      "closedAt": "2018-11-26T22:13:21Z",
      "comments": [
        {
          "author": "Eudi4H",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Nick Lamb [comments](https://www.ietf.org/mail-archive/web/tls/current/msg27298.html) on the same passage:\r\n> In section 7.1 the -02 draft says:\r\n>> Clearly, DNSSEC (if the client validates and hard fails) is a defense against this form of attack, but DoH/DPRIVE are also defenses against DNS attacks by attackers on the local network, which is a common case where SNI.\r\n>\r\n> Where SNI what?\r\n>\r\n> I'd be tempted to just say that yes, an active adversary can force you to choose between privacy and connectivity, and hard fail DNSSEC is the only existing way to choose privacy.\r\n> \r\n> The current text feels more like an attempt by people who don't want to face the Dancing Pig problem to justify why their latest seat-belt that snaps in a crash (to borrow Adam Langley's phrase) is a good idea anyway. But regardless of whether I'm correct about that, the sentence is confusing as it stands now.",
          "createdAt": "2018-11-26T22:08:54Z",
          "updatedAt": "2018-11-26T22:08:54Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "MDU6SXNzdWUzNzQ0NDY5MTg=",
      "title": "Use ESNI RRType instead of TXT",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/109",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "PR #73 from @ghedo implements the ESNI RRType, but there doesn't seem to be another issue currently open to track discussion of it.\r\n\r\n* a new RRType allows the removal of the _esni prefix (#105 and #79)\r\n* reusing TXT has the potential for conflicts with other uses even with the prefix. (imagine the definition of a TXT record that simply applied to all DNS entries)\r\n* while both TXT and ESNI are 8 bit clean, some people are surprised to learn that about TXT so using a new type may be more robust. Some generic tools processing TXT records would benefit from this.\r\n* TXT is a set of  <= 255 byte strings, defining a new type removes that complexity and reduces overhead\r\n* There was initially concern about the viability of new RRTypes, but I believe people are more comfortable with that now than when the text was drafted.",
      "createdAt": "2018-10-26T15:58:31Z",
      "updatedAt": "2019-03-06T00:55:27Z",
      "closedAt": "2019-03-06T00:55:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T00:55:27Z",
          "updatedAt": "2019-03-06T00:55:27Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWUzNzQ0NTIyMDA=",
      "title": "ESNIInclude",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/110",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "issues #105 and #79 advocate for the removal of the _esni prefix.\r\n\r\nA significant side effect of that is that it becomes impossible to use a CNAME at the apex of a zone in order to refer to ESNIKeys of a server operated elsewhere. Inlining keys, as is often done with A/AAAA at the apex, is not plausible due to key rotation.\r\n\r\nThe issue can largely be mitigated with the introduction of an inclusion mechanism directly in the TXT/ESNI record.\r\n",
      "createdAt": "2018-10-26T16:13:11Z",
      "updatedAt": "2019-11-02T01:02:56Z",
      "closedAt": "2019-11-02T01:02:56Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed by #136 and follow up changes. Closing as such. Please reopen if necessary!",
          "createdAt": "2019-06-19T16:53:07Z",
          "updatedAt": "2019-06-19T16:53:07Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't believe #136 resolves this.\r\n\r\n136 effectively requires the address and ESNI information to be stapled together (which I still find objectionable). The issue here is that the apex cannot use a CNAME to delegate to the actual third party provider's ESNI record.. typically it just includes an A/AAAA record at the apex and hopes the pointer doesn't go stale. That's bad enough for A/AAAA but it would be terrible for ESNI because it means copying keying information and hoping it doesn't go stale between two different entities.\r\n\r\n@chris-wood can you reopen?",
          "createdAt": "2019-06-27T20:21:01Z",
          "updatedAt": "2019-06-27T20:21:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure! Sorry for the misunderstanding. We can probably update this PR to make use of the new DNS-specific extensions.",
          "createdAt": "2019-06-28T15:12:59Z",
          "updatedAt": "2019-06-28T15:12:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #187.",
          "createdAt": "2019-11-02T01:02:56Z",
          "updatedAt": "2019-11-02T01:02:56Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWUzNzcwMjM2Njk=",
      "title": "Requirements on backend servers in Split Mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/113",
      "state": "CLOSED",
      "author": "Eudi4H",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As of 7bd60fc, Section 3.1 says that in Split Mode, \"the backend server can be an unmodified TLS 1.3 server.\"\r\n\r\nBut I feel that statement is contradicted by:\r\n- Section 5.4: \"In Split Mode, the backend server must know PaddedServerNameList.nonce to echo it back in EncryptedExtensions and complete the handshake. ... backend servers function the same as servers operating in Shared mode.\"\r\n- Section 7.3: \"...the backend server also only has one identity.\"\r\n- Appendix B: \"When operating in Split mode, backend servers will not have access to PaddedServerNameList.sni or ClientESNIInner.nonce...\"\r\n\r\nA standard TLS 1.3 server that has more than one identity (i.e., requires plaintext SNI) won't work as a backend server. Even if the backend server has only one identity and ignores the forwarded encrypted_server_name extension, and therefore returns a default certificate, it seems that the connection will still fail because of the requirement in Section 5.1 that the client \"MUST check that ClientESNIInner.nonce matches the value of the 'encrypted_server_name' extension provided by the server.\" So I propose removing or amending the statement in Section 3.1. I don't see a way to deploy a Split-Mode topology without making the backend server ESNI-aware and doing some exchange along the lines of Appendix B, but I might have missed something.\r\n\r\nAm I correct in thinking that the current Cloudflare deployment is Shared Mode, not Split Mode, despite that Figure 2 looks more like a typical CDN topology? Because the TLS gets terminated at the Cloudflare CDN edge server, and the connection to the Cloudflare customer's web server is done with an independent connection.",
      "createdAt": "2018-11-03T04:59:57Z",
      "updatedAt": "2019-05-09T06:31:15Z",
      "closedAt": "2019-05-09T06:31:15Z",
      "comments": [
        {
          "author": "Eudi4H",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of #130.",
          "createdAt": "2019-05-09T06:31:15Z",
          "updatedAt": "2019-05-09T06:31:15Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "MDU6SXNzdWUzNzcxMzQ4MjM=",
      "title": "Compress server name in ClientHello",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/116",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "In a large-scale server deployment that benefits the most from ESNI (due to the size of the umbrella under which you would hide the domain names), it is often the case that the largest length of the server name to be supported is *unknown*. That leads such server deployments to use a padded_length of 260 because the longest valid DNS name is 253 characters, bloating the ClientHello.\r\n\r\nIt is beneficial to apply a lightweight compression algorithm to the server name to reduce the overhead.\r\n\r\nSome points to consider:\r\n* We cannot use a pre-learnt dictionary, because what we care is the longest possible length. Compression algorithm using a pre-learnt dictionary assigns longer symbols for rarely used patterns, which means that the worst case is longer than the non-compressed string.\r\n* We can use an adaptive compression algorithm (e.g. lz77, brotli), however they also would not compress well if the server-name is a random-looking string.",
      "createdAt": "2018-11-04T09:13:59Z",
      "updatedAt": "2019-11-05T20:10:41Z",
      "closedAt": "2019-11-05T20:10:41Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Considering the two points, one practical solution will be to map the valid characters of a DNS name (i.e. `a`-`z`,`0`-`9`,`.`,`-`,`_`) to integers between 0 to 38, and encode three characters into a 16-bit value (39<sup>3</sup>=59319).\r\n\r\nBy applying the conversion, the worst length changes from 253 to 169 (i.e. `ceil(253/3*2)`), giving us 84 bytes back.",
          "createdAt": "2018-11-04T09:17:34Z",
          "updatedAt": "2018-11-05T00:11:40Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "To put it another way, the entropy we have when the set of server names is unknown is 39<sup>253</sup> ~ 256<sup>167.2</sup>.\r\n\r\nI do not think that we can go far below this limit by using contexts between the characters, because there aren't many patterns that are forbidden (two consecutive dots is (possibly one of the) rare pattern that never appears).\r\n\r\nConsidering that, using `mod 39` to squeeze three characters into 16 bit to achieve 256<sup>169</sup> is reasonable.",
          "createdAt": "2018-11-05T02:36:31Z",
          "updatedAt": "2018-11-05T02:36:31Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "The valid characters in a DNS host name are [a-zA-Z0-9-] so 63.\r\n\r\nYou can represent each 8-bit character in the above set using 6 bits and group 4 characters together to form 24 bits.\r\nYou can then represent the 24 bits as 3 8-bit characters.\r\nThis is basically the Base64 decoding process.\r\nThe output is 3/4 of the input which means you gain 25%.\r\n\r\nBut then ServerName in ClientESNIInner won't be the same as the ServerName defined in RFC 3546 and it probably won't be printable.",
          "createdAt": "2019-03-08T00:24:04Z",
          "updatedAt": "2019-03-08T00:58:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho how do you want to proceed here?",
          "createdAt": "2019-11-04T20:48:37Z",
          "updatedAt": "2019-11-04T20:48:37Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I think we should close this with no action.",
          "createdAt": "2019-11-05T06:03:32Z",
          "updatedAt": "2019-11-05T06:03:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good! Closing.",
          "createdAt": "2019-11-05T20:10:41Z",
          "updatedAt": "2019-11-05T20:10:41Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWUzNzcyODUwNzA=",
      "title": "easy to miss validity intervals",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/117",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@hardie notes that the not_before and not_after fields are there and described, but not really part of the operational notes.  Having something there that talks about these, particularly as it relates to clock skew, would be valuable.",
      "createdAt": "2018-11-05T07:52:04Z",
      "updatedAt": "2019-06-17T18:17:54Z",
      "closedAt": "2019-06-17T18:17:54Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "(My ~monthly login into github.com - this'd be better on the TLS WG list, and I will send mail on this sometime but anyway...)\r\nThe not-before and not-after fields are a mistake.\r\nSame as turned out true for x.509.\r\nI was just doing testing where FF nightly barfed on ESNIKeys I'd published for only that non-reason. (There is no overall security win in so-doing, in general.)\r\nCreating a tangle between the cadence at which one updates DNS, the ESNIKeys-internal \"lifetime\" of a key, the DNS TTL and server-state is basically just pointless nonsense. \r\nLet's delete those fields from ESNIKeys before we're done and just rely on DNS for what it already does.",
          "createdAt": "2019-06-10T22:49:18Z",
          "updatedAt": "2019-06-10T22:49:18Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Now that #124 has been merged, I agree that there is less need for not_before and not_after fields. Previously, a client using an expired key led to connection failure, and therefore having these fields were necessary.",
          "createdAt": "2019-06-11T02:49:02Z",
          "updatedAt": "2019-06-11T02:49:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by removing these fields with #161.",
          "createdAt": "2019-06-17T18:17:49Z",
          "updatedAt": "2019-06-17T18:17:49Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "MDU6SXNzdWUzNzc0MDY4OTc=",
      "title": "Is there a debug/development server to test client side implementation",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/118",
      "state": "CLOSED",
      "author": "mosajjal",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We've recently developed a PoC for ESNI and we're having trouble pinning down what we're doing wrong since the test URL (https://cloudflare.com/cdn-cgi/trace) is still showing sni=off. \r\n\r\nI was wondering if CloudFlare is considering running a test/debug server to help us facilitate the development of various clients. ",
      "createdAt": "2018-11-05T13:46:41Z",
      "updatedAt": "2020-10-13T12:40:32Z",
      "closedAt": "2019-06-02T15:08:29Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Same here - well, sorta, I've just got to where I've an openssl [build](https://github.com/sftcd/openssl/tree/master/esnistuff)  sending a CH with the ESNI extension in that seems maybe correctish;-)\r\n\r\nWould be great if there was a public server to bang against.",
          "createdAt": "2018-11-20T21:26:09Z",
          "updatedAt": "2018-11-20T21:26:09Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://www.cloudflare.com/ssl/encrypted-sni/ supports the latest, Firefox does too (if you turn on all the right options, which I can share if necessary).",
          "createdAt": "2018-11-20T21:50:15Z",
          "updatedAt": "2018-11-20T21:50:15Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ta - was trying cloudflare.net - www.cloudflare.com seems to get me a bit further. Off to debug so:-)",
          "createdAt": "2018-11-20T21:56:31Z",
          "updatedAt": "2018-11-20T21:56:31Z"
        },
        {
          "author": "mosajjal",
          "authorAssociation": "NONE",
          "body": "[this](https://www.cloudflare.com/cdn-cgi/trace)  address is also good. But I'm looking for a debug server because my request's ESNI gets ignored by the server and I can't figure out why. ",
          "createdAt": "2018-11-21T04:43:53Z",
          "updatedAt": "2018-11-21T04:43:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, since this is not an issue with the draft. Moved initial implementation list to https://github.com/tlswg/draft-ietf-tls-esni/wiki/ESNI-Implementations.",
          "createdAt": "2019-06-02T15:08:29Z",
          "updatedAt": "2019-06-02T15:08:29Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hiya, I just put up a server based on my openssl code; see https://defo.ie/ for details. (I would've tried edit the wiki but didn't see a button;-)",
          "createdAt": "2019-06-14T15:04:00Z",
          "updatedAt": "2019-06-14T15:04:00Z"
        },
        {
          "author": "avened",
          "authorAssociation": "NONE",
          "body": "Hello. There is a test server with ESNI support available at https://tls13.1d.pw/ (TLS 1.3 only).",
          "createdAt": "2019-11-04T16:33:15Z",
          "updatedAt": "2019-11-04T16:33:15Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hiya, that works with my ``openssl s_client`` client... so long as you don't send me an HRR! (Which you seem to be doing about every 2nd time?) If you do send me an HRR, then my side doesn't do the right thing yet - my code admittedly did have a \"TODO: ... implement ... handling HRR\" comment;-) ",
          "createdAt": "2019-11-06T21:28:56Z",
          "updatedAt": "2019-11-06T21:28:56Z"
        },
        {
          "author": "avened",
          "authorAssociation": "NONE",
          "body": "Actual probability of HRR being sent depends on key shares received from client (but, yes, it can be near 1/2). What concerns HRR + ESNI - interestingly, the same happened in NSS and Firefox, I've encountered it while testing browsers against this same test server (fixed in NSS 3.43 release).",
          "createdAt": "2019-11-06T22:02:20Z",
          "updatedAt": "2019-11-06T22:02:20Z"
        },
        {
          "author": "ValZapod",
          "authorAssociation": "NONE",
          "body": "@avened Is there some source code of your server available? Or is it already here https://github.com/tlswg/draft-ietf-tls-esni/wiki/ESNI-Implementations? \u041a\u043b\u0430\u0441\u0441\u043d\u0430\u044f \u0448\u0442\u0443\u043a\u0430 \u043a\u0441\u0442\u0430\u0442\u0438.",
          "createdAt": "2020-10-13T08:24:59Z",
          "updatedAt": "2020-10-13T08:24:59Z"
        },
        {
          "author": "avened",
          "authorAssociation": "NONE",
          "body": "@ValZapod \r\n> Is there some source code of your server available? https://github.com/tlswg/draft-ietf-tls-esni/issues/118#issuecomment-707579615\r\n\r\nNo, not yet.\r\n\r\n> \u041a\u043b\u0430\u0441\u0441\u043d\u0430\u044f \u0448\u0442\u0443\u043a\u0430 \u043a\u0441\u0442\u0430\u0442\u0438.\r\n\r\n\u0421\u043f\u0430\u0441\u0438\u0431\u043e!",
          "createdAt": "2020-10-13T12:40:32Z",
          "updatedAt": "2020-10-13T12:40:32Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "MDU6SXNzdWUzODM4NDMzMzU=",
      "title": "record_digest input bytes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/119",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The I-D says: \"record_digest : A cryptographic hash of the ESNIKeys structure from which the ESNI key was obtained, i.e., from the first byte of \"checksum\" to the end of the structure. This hash is computed using the hash function associated with suite.\"\r\n\r\nFrom looking at the NSS code it appears that the record_digest input is actually the entire ESNIKeys (after base64 decode) including the version and checksum. Is that correct?\r\n\r\nIOW, does the following also produce the right value (for CF and sha256)?\r\n\r\n``dig +short txt _esni.www.cloudflare.com  | sed -e 's/\"//g' | base64 -d | openssl sha256``",
      "createdAt": "2018-11-23T14:27:47Z",
      "updatedAt": "2019-07-03T03:51:26Z",
      "closedAt": "2019-07-03T03:51:26Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "#163 proposes removing the checksum, which should clear this up. ",
          "createdAt": "2019-07-03T01:16:34Z",
          "updatedAt": "2019-07-03T01:16:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing since #163 landed. @sftcd, please re-open if this is still an issue!",
          "createdAt": "2019-07-03T03:51:26Z",
          "updatedAt": "2019-07-03T03:51:26Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "MDU6SXNzdWUzODkzODExMjM=",
      "title": "Can the ESNI values change upon HRR?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/121",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "needs WG discussion"
      ],
      "body": "RFC 8446 requires us to specify if the contents of ESNI can change upon a HRR.\r\n\r\nIn case of ESNI, the payload of the extension obviously can change, because the AAD (i.e. ClientHello.KeyShareClientHello) can change. However, we haven't specified if other values (e.g., ClientESNIInner.nonce) can.\r\n\r\nIMO, we should prohibit needless changes.\r\n\r\nTo clarify, all the non-encrypted portion and the encrypted payload of ESNI MUST be consistent between the first ClientHello and the second one.",
      "createdAt": "2018-12-10T16:28:25Z",
      "updatedAt": "2020-10-16T17:14:14Z",
      "closedAt": "2020-03-09T21:58:12Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d ",
          "createdAt": "2018-12-10T16:56:17Z",
          "updatedAt": "2018-12-10T16:56:17Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "Bad idea.  Causing the encrypted ESNI to change such that observers cannot determine if this is a request for the same or a different back end name is a major security feature of the mechanism.  If a popular CDN such a cloudflare or S3 enables ESNI on their front end servers, observers should not be able to detect if repeated requests from a client are the usual pattern of retrieving common noise from web frameworks, random surfing of many sites or a long visit to a banned site.  ESNI servers (and only ESNI servers) would deal with recognizing that requests are actually resuming the same session despite the camouflage differences.\r\n",
          "createdAt": "2019-03-01T18:51:41Z",
          "updatedAt": "2019-03-01T18:51:41Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@jb-wisemo \r\n> Causing the encrypted ESNI to change such that observers cannot determine if this is a request for the same or a different back end name is a major security feature of the mechanism.\r\n\r\nI do not get that. When HRR is used on TCP, the fact that the 1st CH and 2nd CH (sent in HRR) specify the same server name will be evident from the fact that they are sent on a single TCP connection. In case of HRR used with cookies, an observer will be able to track the pair by using cookies.",
          "createdAt": "2019-03-02T21:45:06Z",
          "updatedAt": "2019-03-02T21:45:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is addressed in #207.",
          "createdAt": "2020-03-08T00:33:40Z",
          "updatedAt": "2020-03-08T00:33:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #207.",
          "createdAt": "2020-03-09T21:58:12Z",
          "updatedAt": "2020-03-09T21:58:12Z"
        }
      ]
    },
    {
      "number": 123,
      "id": "MDU6SXNzdWUzOTA4Mjg3Nzk=",
      "title": "Encrypted nonce in ClientESNIInner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/123",
      "state": "CLOSED",
      "author": "roelfdutoit",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Would you consider a PR for encrypting the ClientESNIInner nonce?\r\n\r\nWhat I have in mind is the following:\r\n`struct {\r\n       EncryptedNonce enc_nonce;\r\n       PaddedServerNameList realSNI;\r\n   } ClientESNIInner;`\r\n.. where:\r\n`nonceAAD = ClientHello.KeyShareClientHello || realSNI`\r\n`EncryptedNonce = AEAD-Encrypt(nonce_key, nonce_iv, nonceAAD, nonce)`\r\n.. and:\r\n`nonce_key = HKDF-Expand-Label(Zx, \"nonce key\", Hash(ESNIContents), key_length)`\r\n`nonce_iv = HKDF-Expand-Label(Zx, \"nonce iv\", Hash(ESNIContents), iv_length)`\r\n\r\nThe use case is an escrow system where the client wants to allow **read-only** visibility of the real SNI value by only sharing {key,iv} and keeping {nonce_key,nonce_iv} and Zx secret.   Only the real server would be able to acknowledge 'nonce' in EncryptedExtensions.",
      "createdAt": "2018-12-13T19:38:59Z",
      "updatedAt": "2019-07-03T21:06:27Z",
      "closedAt": "2019-07-03T21:06:27Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a change which is very hard to analyze with limited value,\nso I would not be in favor.\n\nOn Thu, Dec 13, 2018 at 11:39 AM Roelof DuToit <notifications@github.com>\nwrote:\n\n> Would you consider a PR for encrypting the ClientESNIInner nonce?\n>\n> What I have in mind is the following:\n> struct { EncryptedNonce enc_nonce; PaddedServerNameList realSNI; }\n> ClientESNIInner;\n> .. where:\n> nonceAAD = ClientHello.KeyShareClientHello || realSNI\n> EncryptedNonce = AEAD-Encrypt(nonce_key, nonce_iv, nonceAAD, nonce)\n> .. and:\n> nonce_key = HKDF-Expand-Label(Zx, \"nonce key\", Hash(ESNIContents),\n> key_length)\n> nonce_iv = HKDF-Expand-Label(Zx, \"nonce iv\", Hash(ESNIContents), iv_length)\n>\n> The use case is an escrow system where the client wants to allow\n> *read-only* visibility of the real SNI value by only sharing {key,iv} and\n> keeping {nonce_key,nonce_iv} and Zx secret. Only the real server would be\n> able to acknowledge 'nonce' in EncryptedExtensions.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/123>, or mute the\n> thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oU3KagiPrj04JxnWI89FlD92g9EQks5u4qzTgaJpZM4ZSSdw>\n> .\n>\n",
          "createdAt": "2018-12-13T19:44:37Z",
          "updatedAt": "2018-12-13T19:44:37Z"
        },
        {
          "author": "roelfdutoit",
          "authorAssociation": "NONE",
          "body": "PR created:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/147",
          "createdAt": "2019-03-07T23:33:48Z",
          "updatedAt": "2019-03-07T23:33:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @roelfdutoit, can you elaborate on the motivations for this change? In what scenario would the client wish to share the SNI with a third party?",
          "createdAt": "2019-03-08T00:41:18Z",
          "updatedAt": "2019-03-08T00:41:18Z"
        },
        {
          "author": "roelfdutoit",
          "authorAssociation": "NONE",
          "body": "Enterprise network security solutions are evolving, especially in the area of monitoring and analytics, and SNI is a valuable attribute in such an environment.  A client would share the ESNI {key,iv} with configured enterprise monitoring devices (NGFW, IPS, Proxy, IDS, DLP, etc) and this becomes critical in a zero trust network.  There is a lot of focus on using ESNI in a CDN world, but the mechanism would also be very valuable for enterprises that host multiple proprietary services - again, in a zero trust environment.  Those proprietary services and applications must be monitored at different points in the enterprise network, requiring access to the true SNI.  The PR would provide a responsible way to share the true SNI, without the need for traditional TLS intercept - assuming a secure sharing mechanism is used.",
          "createdAt": "2019-03-08T02:44:07Z",
          "updatedAt": "2019-03-08T02:44:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@roelfdutoit can you please bring this issue to the list for further discussion?",
          "createdAt": "2019-07-03T03:52:36Z",
          "updatedAt": "2019-07-03T03:52:36Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "MDU6SXNzdWUzOTUwODkzNTI=",
      "title": "Do not send cached_info cert type when using ESNI",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/126",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "An adversary who observes the certificate fingerprint could confirm certificates previously fetched by a ESNI-compatible client.",
      "createdAt": "2019-01-01T14:46:54Z",
      "updatedAt": "2019-03-16T03:37:43Z",
      "closedAt": "2019-03-16T03:37:43Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #127.",
          "createdAt": "2019-03-16T03:37:43Z",
          "updatedAt": "2019-03-16T03:37:43Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "MDU6SXNzdWU0MDA5NDQxODc=",
      "title": "Consider dropping split mode altogether",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/130",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "The mechanism to make split mode work in practice requires non-trivial changes to both the fronting server and origin. Moreover, as the main (mass user base) benefit for ESNI is shared mode, perhaps we should consider dropping split mode.",
      "createdAt": "2019-01-19T01:14:24Z",
      "updatedAt": "2019-09-28T14:41:38Z",
      "closedAt": "2019-09-28T14:41:38Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I would not be in favor of this change. There are real uses for split mode and we should try to address them",
          "createdAt": "2019-01-19T03:00:16Z",
          "updatedAt": "2019-01-19T03:00:16Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm in favor of removing split mode from this draft, the added complexity is not necessarily worth it.",
          "createdAt": "2019-01-20T00:33:47Z",
          "updatedAt": "2019-01-20T00:33:47Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought about this some and decided that:\r\n * Split mode is valuable and worth supporting.\r\n * It needs more specification than can reasonably fit in this draft.\r\n * It's part of a larger problem related to load balancers.\r\n\r\nSo I wrote a [new draft on this topic](https://tools.ietf.org/html/draft-schwartz-tls-lb-00).  My hope is that we can remove the detailed discussion of split mode here and replace it with a reference to that draft.\r\n\r\nThere's one thing I'd like to resolve before sending that draft to the TLS list: That draft is derived from the brief proposal in this draft to use a PSK to transfer `Z` between the servers.  I'm not 100% sure who proposed that design, but in my draft I added an acknowledgement to @ekr after looking through the version history here.  I'd like to make sure that credit is correct, and I'm happy to add whoever came up with that to the authors list.",
          "createdAt": "2019-06-28T15:03:31Z",
          "updatedAt": "2019-06-28T15:03:31Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "1. I am not in favor of removing the discussion of split mode from this\ndocument, though I am fine to have detail elsewhere.\n2. I think I was the person who proposed the PSK idea, but honestly, it's\npretty obvious so I'm not worried about credit and if someone else thinks\nthey were first, I'm not going to argue,\n\nOn Fri, Jun 28, 2019 at 8:03 AM Benjamin M. Schwartz <\nnotifications@github.com> wrote:\n\n> I thought about this some and decided that:\n>\n>    - Split mode is valuable and worth supporting.\n>    - It needs more specification than can reasonably fit in this draft.\n>    - It's part of a larger problem related to load balancers.\n>\n> So I wrote a new draft on this topic\n> <https://tools.ietf.org/html/draft-schwartz-tls-lb-00>. My hope is that\n> we can remove the detailed discussion of split mode here and replace it\n> with a reference to that draft.\n>\n> There's one thing I'd like to resolve before sending that draft to the TLS\n> list: That draft is derived from the brief proposal in this draft to use a\n> PSK to transfer Z between the servers. I'm not 100% sure who proposed\n> that design, but in my draft I added an acknowledgement to @ekr\n> <https://github.com/ekr> after looking through the version history here.\n> I'd like to make sure that credit is correct, and I'm happy to add whoever\n> came up with that to the authors list.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/130?email_source=notifications&email_token=AAIPLINHQPO5SJFANUDLRF3P4YR4JA5CNFSM4GRDQ36KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODY2KNDA#issuecomment-506766988>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAIPLILIAK7IRVQRIZ3HQDTP4YR4JANCNFSM4GRDQ36A>\n> .\n>\n",
          "createdAt": "2019-06-28T16:32:15Z",
          "updatedAt": "2019-06-28T16:32:15Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One discrepancy is whether the frontend shares the Z value with the backend or the ClientESNIInner. The new draft says the latter and the appendix in the ESNI draft says the former.\r\n\r\nWas there a particular reason to send Z? All else equal, ClientESNIInner seems much more straightforward to deploy and reason about. Frontend and backend need to coordinate on which ESNI encryption schemes to support if sending Z. It also feels odd to send along a raw unKDFed key exchange secret like that, but maybe it's fine?\r\n\r\n[Edit: I wrote \"do not need\" originally when I should have written \"need\".]",
          "createdAt": "2019-06-28T16:40:29Z",
          "updatedAt": "2019-06-28T16:41:03Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I suggested Z on the theory that it would make it hard to lie about\nClientESNIInner. I haven't thought through it all in detail, though.\n\nOn Fri, Jun 28, 2019 at 9:40 AM David Benjamin <notifications@github.com>\nwrote:\n\n> One discrepancy is whether the frontend shares the Z value with the\n> backend or the ClientESNIInner. The new draft says the latter and the\n> appendix in the ESNI draft says the former.\n>\n> Was there a particular reason to send Z? All else equal, ClientESNIInner\n> seems much more straightforward to deploy and reason about. Frontend and\n> backend do not need to coordinate on which ESNI encryption schemes to\n> support if sending Z. It also feels odd to send along a raw unKDFed key\n> exchange secret like that, but maybe it's fine?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/130?email_source=notifications&email_token=AAIPLIIZ6L5ZNA73CCD2GB3P4Y5H5A5CNFSM4GRDQ36KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODY2SNKI#issuecomment-506799785>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIJ2KE2AHR4J6D4ZCHTP4Y5H5ANCNFSM4GRDQ36A>\n> .\n>\n",
          "createdAt": "2019-06-28T16:45:25Z",
          "updatedAt": "2019-06-28T16:45:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(Late filling this out...)\r\n\r\nDiscussed in Montreal: we don't need to remove it -- we simply shouldn't make it impossible to implement, and the draft as of now achieves that goal. So, I'm closing this issue.",
          "createdAt": "2019-09-28T14:41:11Z",
          "updatedAt": "2019-09-28T14:41:36Z"
        }
      ]
    },
    {
      "number": 131,
      "id": "MDU6SXNzdWU0MDczOTYwOTc=",
      "title": "Proposal: ESNI record Implies TLS support",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/131",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "Proposal:\r\nThe ESNI DNS record specification, wherever it ends up, should have the following requirement:\r\n\"If a domain or endpoint publishes an ESNI DNS record, then that domain MUST be accessible over TLS.\"\r\n\r\nThis is almost trivial (why would you publish an ESNI record if you don't have TLS support?), but it would be tremendously useful for browsers, as a way to learn that the specified domain supports HTTPS before attempting a connection.  If DNS records are fetched over a secure channel, this would enable HSTS-like behavior without an insecure bootstrap or a preload list.",
      "createdAt": "2019-02-06T19:34:35Z",
      "updatedAt": "2019-07-03T00:10:21Z",
      "closedAt": "2019-07-03T00:10:21Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A domain name that has ESNI keys is very likely to support TLS, but you can't assume that is supports HTTPS on port 443 - they could be using TLS for something else.",
          "createdAt": "2019-02-06T19:47:06Z",
          "updatedAt": "2019-02-06T19:47:06Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That depends on how we define the ESNI record.  For example, we could insert a port in the name (like SRV), or include a list of the applicable ports in the record contents.  (Or we could just declare that ESNI implicitly blacklists port 80, which I believe is what you are arguing against.)\r\n\r\nIt's up to us.",
          "createdAt": "2019-02-06T19:58:19Z",
          "updatedAt": "2019-02-06T19:58:19Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "By default, http and https are different origins. HSTS is a opt-in signal that changes the behavior. \r\n\r\nConsidering that, I think that the discussion needs to happen the HTTPbis WG on if the WG should define an extension to ESNI.",
          "createdAt": "2019-02-08T08:02:14Z",
          "updatedAt": "2019-02-08T08:02:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is ESNI something you would use for protocols other than HTTP?",
          "createdAt": "2019-07-03T00:00:54Z",
          "updatedAt": "2019-07-03T00:00:54Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to think yes. Suppose, for instance, you had DoQ.",
          "createdAt": "2019-07-03T00:07:40Z",
          "updatedAt": "2019-07-03T00:07:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. @bemasc, this should probably go to httpbis for discussion! I'm closing for now.",
          "createdAt": "2019-07-03T00:10:21Z",
          "updatedAt": "2019-07-03T00:10:21Z"
        }
      ]
    },
    {
      "number": 132,
      "id": "MDU6SXNzdWU0MDk5NjcxMTM=",
      "title": "Interaction with Alternative Services is confusing",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/132",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft currently states:\r\n\r\n> In cases where the domain of the A or AAAA records being resolved do not match the SNI Server Name, such as when {{!RFC7838}} is being used, the SNI domain should be used for querying the ESNI TXT record.\r\n\r\nI'm confused about what this means. From reading RFC 7838, I'm not sure the SNI and DNS names do not match when you're querying an alternate name. In particular, RFC 7838 states:\r\n\r\n> For example, if the origin's host is \"www.example.com\" and an alternative is offered on \"other.example.com\" with the \"h2\" protocol, and the certificate offered is valid for \"www.example.com\", the client can use the alternative.\r\n\r\nWhich means, if I understand it correctly, the client will send \"other.example.com\" in the SNI when trying to query resources from it - the requirement is only that the certificate for \"other.example.com\" also cover \"www.example.com\".",
      "createdAt": "2019-02-13T19:36:27Z",
      "updatedAt": "2019-03-08T21:24:28Z",
      "closedAt": "2019-03-08T21:24:28Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. I'm parsing RFC 7838 the same way. I think we should drop this text.",
          "createdAt": "2019-02-16T00:41:15Z",
          "updatedAt": "2019-02-16T00:41:15Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The problem the text presents is real (though the resolution is arbitrary).\r\n\r\n> Which means, if I understand it correctly, the client will send \"other.example.com\" in the SNI when trying to query resources from it - the requirement is only that the certificate for \"other.example.com\" also cover \"www.example.com\".\r\n\r\nno.. that's a misread. See section 2.3 of 7838\r\n```\r\n Note that the SNI information provided in TLS by the client will be\r\n   that of the origin, not the alternative (as will the Host HTTP header\r\n   field value).\r\n```\r\n\r\nThe alternate is essentially just a cname for the origin. If host b is an alternate for origin a, in order to use the alternate you look up the DNS a/aaaa of b, do a TCP connect to b, and then use sni=a and expect a certificate valid for a. (indeed the point of the SNI is to tell the server what certificate you expect to see)\r\n\r\nWith esni you would continue to do all of those things, except of course sni=encrypted(a).. and the question becomes where do you find the key used for the encryption. Is it the ESNI DNS record of a (the origin) or b (the alternate host). That's the question the text is trying to resolve - it says to use a (the origin). I could make a case for either choice but I think the text needs to decide \r\n",
          "createdAt": "2019-02-17T01:59:38Z",
          "updatedAt": "2019-02-17T02:14:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus Would you mind suggesting some text with an example to clear this up?",
          "createdAt": "2019-02-19T17:11:54Z",
          "updatedAt": "2019-02-19T17:11:54Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mcmanus thanks for the clarification and pointer to s2.3 of 7838.\r\n\r\nAfter reading that I think the text in the ESNI draft looks fine. (I'd just add a pointer to s2.3 of 7838 instead of just 7838 to help prevent the confusion I had)",
          "createdAt": "2019-02-21T20:32:08Z",
          "updatedAt": "2019-02-21T20:32:17Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "MDU6SXNzdWU0MTA1MDgxNDI=",
      "title": "Always returning the same records is too restrictive",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/133",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The document currently states:\r\n\r\n> Servers operating in Split Mode SHOULD have DNS configured to return the same A (or AAAA) record for all ESNI-enabled servers they service. This yields an anonymity set of cardinality equal to the number of ESNI-enabled server domains supported by a given client-facing server. Thus, even with SNI encryption, an attacker which can enumerate the set of ESNI-enabled domains supported by a client-facing server can guess the correct SNI with probability at least 1/K, where K is the size of this ESNI-enabled server anonymity set. This probability may be increased via traffic analysis or other mechanisms.\r\n\r\nI think this is too restrictive. If I have 100000 names and 100 IPs and for all queries I randomly return four out of my 100 IPs chosen randomly, I still provide the same anonymity set but I violate the SHOULD. How about: `Content providers operating in Split Mode SHOULD ensure that the A and AAAA records for ESNI-enabled server names do not allow identifying the server name from the IP address. This can for example be achieved by always returning the same records for all ESNI-enabled names, or by having the function that picks addresses from a pool not depend on the server name. This yields an anonymity set...`",
      "createdAt": "2019-02-14T21:50:38Z",
      "updatedAt": "2019-06-02T15:13:39Z",
      "closedAt": "2019-06-02T15:13:39Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "Agreed.  At a minimum this should reference a set of A and AAAA records rather than \"the record\" (as many records across the A and AAAA rrsets is very common).\r\n\r\nI think @DavidSchinazi's proposed text is fine.",
          "createdAt": "2019-02-21T16:21:12Z",
          "updatedAt": "2019-02-21T16:21:12Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DavidSchinazi sgtm, do you plan to open a PR? I made https://github.com/ghedo/draft-ietf-tls-esni/commit/c9570cf4a00925bead63d46ecd6744288209146e but I think your wording is better.",
          "createdAt": "2019-06-01T10:52:28Z",
          "updatedAt": "2019-06-01T10:52:28Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Created #157",
          "createdAt": "2019-06-02T09:36:08Z",
          "updatedAt": "2019-06-02T09:36:08Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "MDU6SXNzdWU0MTA5MjY4OTU=",
      "title": "260 bytes is maybe a bit much?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/134",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Stephen Farrell pointed out on the list that 260 is rather a lot of waste to stick into the ClientHello.\r\nhttps://mailarchive.ietf.org/arch/msg/tls/kW_SWFamoj6IME4JzGseBKDyUV4\r\n\r\n260 characters is this large of a hostname:\r\n```\r\n>>> \"a\" * 260\r\n'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'`\r\n```\r\n\r\nIt's probably reasonable to recommend a smaller default value like 64 or 96 or 128. (Numbers pulled out of a hat. I have no data on how big it actually should be.)",
      "createdAt": "2019-02-15T20:15:01Z",
      "updatedAt": "2019-07-03T00:33:47Z",
      "closedAt": "2019-07-03T00:33:47Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah. The question is if we are happy with hostnames longer than the threshold (e.g., 64, 96, 128) sticking out. I think the current design of allowing the server to choose the correct value is the right approach.\r\n\r\nOTOH, regarding the size you'd use for greasing, I can understand the concern of wasting bytes. Maybe browsers can use smaller sized payloads when greasing the ESNI extension, under the premise that they would be sometimes using the maximum.\r\n\r\nThe size of the extension being different from when it is actually used does not matter in practice, because an observer can typically tell if ESNI was used by checking if the unencrypted SNI record contains the fallback domain name (here I assume that we adopt #134).",
          "createdAt": "2019-02-16T00:30:58Z",
          "updatedAt": "2019-02-16T00:30:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed that letting the server choose the correct value makes sense. But I think the specification should also be opinionated about this, so we don't get wildly different values for everyone, and so implementors have something to pick if they don't really care. The closely thing the spec currently has to an opinion is 260, which is kind of large.",
          "createdAt": "2019-02-16T00:35:58Z",
          "updatedAt": "2019-02-16T00:35:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Absent data that shows there's a tighter upper bound, I would prefer to keep the 260 recommendation and perhaps suggest that servers may choose something smaller if they know better. ",
          "createdAt": "2019-02-16T00:39:11Z",
          "updatedAt": "2019-02-16T00:39:11Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "According to RFC 1035 host names can be up to 255 octets.\r\nI don't think this has changed.\r\nSo if this document makes a recommendation it should cover the worst case.\r\n\r\nSomeone could argue for something more efficient.\r\nFor instance, if we were to do draw the distribution of name lengths we would find that the median is 13 characters. (An excellent number) Min is 4 and max is 117. (Source: https://scans.io/study/umich-https)\r\nBut this can change and the recommendation in this document will become outdated.\r\n\r\nMaybe add something like the following: \"servers COULD tailor the padding length to cover the longest name associated with the hosts they handle.\" (And keep the existing number)",
          "createdAt": "2019-03-08T06:14:27Z",
          "updatedAt": "2019-03-08T06:14:27Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the current text, the \"260\" number only matters for GREASE; anyone who actually publishes ESNIKeys SHOULD choose the smallest number that covers their names, \"rounded up to the nearest multiple of 16\".  Given @kontaxis's data, the most common choices will likely be 16 and 32.  This state of affairs makes GREASE less effective, because (1) it doesn't resemble real usage and (2) it isn't exercising the length \"joint\".\r\n\r\nAs a solution, I would propose recommending that GREASE clients choose a valid length at random.  If we want to get fancy we could say that the random choice may be non-uniform (to favor shorter ClientHellos) but should have at least x% chance of choosing each length option.\r\n\r\nAlso, instead of saying that the padded_length \"SHOULD\" be 16*N or 260, I think we should consider a \"MUST\", and/or a denser encoding (e.g. enum with values 0..16).  Otherwise, we have to figure out what clients should do if `padded_length` is huge.  (I wonder how that interacts with QUIC and DDoS...)",
          "createdAt": "2019-05-21T18:40:27Z",
          "updatedAt": "2019-05-21T18:40:27Z"
        },
        {
          "author": "mrsylerpowers",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another proposal is mentioned in #116 of just compressing these bits instead",
          "createdAt": "2019-06-10T16:14:07Z",
          "updatedAt": "2019-06-10T16:14:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben this should be fixed, with new recommendation text, via #162. Please re-open if not!",
          "createdAt": "2019-07-03T00:33:46Z",
          "updatedAt": "2019-07-03T00:33:46Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "MDU6SXNzdWU0MTMwMDU3MDU=",
      "title": "Extensible information in ESNIKey DNS record",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/135",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We may wish to have a way to indicate additional (extensible?) information relevant to establishing a connection alongside ESNIKeys in whatever record is introduced.  This increases the value of clients doing an additional DNS resolution in cases where it reduces future round-trips and reduces the need for subsequent DNS lookups.  In particular (and their might be others in the future):\r\n\r\n* Being able to indicate that an Alternate Service (such as QUIC can/should be used).  Being able to switch directly to QUIC out of DNS without adding in additional resolutions, the need to go via TCP, or RTTs would add significant value and motivation to implement for clients and servers.\r\n\r\n* Being able to indicate that HSTS should be used on a bareword hostname (ie, to default to HTTPS when no scheme is present).  This might unblock browsers from defaulting to HTTPS.\r\n\r\n",
      "createdAt": "2019-02-21T16:14:52Z",
      "updatedAt": "2019-02-21T16:17:36Z",
      "closedAt": "2019-02-21T16:17:36Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "There already is such a field:\r\n\r\n```\r\n    struct {\r\n        uint16 version;\r\n        uint8 checksum[4];\r\n        KeyShareEntry keys<4..2^16-1>;\r\n        CipherSuite cipher_suites<2..2^16-2>;\r\n        uint16 padded_length;\r\n        uint64 not_before;\r\n        uint64 not_after;\r\n        Extension extensions<0..2^16-1>;   <---- HERE\r\n    } ESNIKeys;````\r\n",
          "createdAt": "2019-02-21T16:17:36Z",
          "updatedAt": "2019-02-21T16:17:36Z"
        }
      ]
    },
    {
      "number": 138,
      "id": "MDU6SXNzdWU0MTU0MDkxMDQ=",
      "title": "Use ESNI in local discovery mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/138",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "I am looking at using ESNI for local private discovery. It would work as follow:\r\n\r\n1) Authorized clients know the ESNI public key of the private server, which is otherwise kept secret.\r\n\r\n2) Client initiates a DTLS session or a QUIC connection by broadcasting a message containing ESNI extension targeting the specific server.\r\n\r\n3) Servers only respond if the recognize their key and name in the extension.\r\n\r\nESNI almost works as is for that, but not quite. First, the \"record_digest\" component allows identification and tracking of the server. In the private discovery mode, we would want to either not use it at all, or incorporate a nonce in the digest.\r\n\r\nSecond, ALPN. But you know that.",
      "createdAt": "2019-02-28T01:50:14Z",
      "updatedAt": "2020-10-16T17:14:15Z",
      "closedAt": "2019-07-08T17:26:01Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Re: ALPN: Why can't that be public?  You aren't intending to try to keep the fact that this is local private discovery, are you?",
          "createdAt": "2019-02-28T03:13:31Z",
          "updatedAt": "2019-02-28T03:13:31Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ALPN: It depends. Model 1 would be discovery over DTLS, i.e. handshake followed by DNS/MDNS over DTLS. Model 2 would be discovery integrated in the application, say using QUIC. The first client initial packet would be broadcast, and then the connection just proceeds.",
          "createdAt": "2019-02-28T03:44:00Z",
          "updatedAt": "2019-02-28T03:44:00Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see, you are suggesting that - in model 2 - the connection is used for both discovery AND the application protocol.  I agree that the application protocol might be too revealing in that case.  \"h3\" might not be, but something more device-specific might leave nothing to the imagination.",
          "createdAt": "2019-02-28T03:51:46Z",
          "updatedAt": "2019-02-28T03:51:46Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Further analysis shows that even adding salt to the hash before computing the \"record digest\" will not help.  This is a defense in depth issue. The privacy of the discovery depends on keeping secret the \"discovery ESNI key\" of the service. If for some reason that key leaks, the attackers can mount active attacks and discover whether a target is present on a network. The record digest, even if it was salted, allows them to also perform passive attacks, such as looking at the digests in a log and checking whether they match a known key.\r\n\r\nThe simplest solution is to just omit the digest when using the ESNI extension for local discovery, e.g. when a DTLS or QUIC initial packet is received over a multicast address.",
          "createdAt": "2019-02-28T18:47:42Z",
          "updatedAt": "2019-02-28T18:47:42Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> The simplest solution is to just omit the digest when using the ESNI extension for local discovery, e.g. when a DTLS or QUIC initial packet is received over a multicast address.\r\n\r\nSounds correct to me. To me it seems that the trade-off here is trial-decryption vs. exposing the key identifier. In the proposed local discovery scheme, every node is expected to perform trial decryption. That's fine for the proposed scheme, but not for ordinary ESNI keys in which we need a key identifier to avoid trial decryption.",
          "createdAt": "2019-03-05T07:08:54Z",
          "updatedAt": "2019-03-05T07:08:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed by #166. @huitema, please reopen if that's not the case!",
          "createdAt": "2019-07-08T17:26:01Z",
          "updatedAt": "2019-07-08T17:26:01Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "MDU6SXNzdWU0MTYyMjg0NDU=",
      "title": "Associate the ESNI record with the client-facing server IP",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/139",
      "state": "CLOSED",
      "author": "jb-wisemo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "help wanted"
      ],
      "body": "To maximize the cover range for clients and simplify management of the ESNI records, it is more useful to associate the ESNI records with the server rather than the query domain name.  This has the additional benefit of allowing different client-facing servers to use different rotating private DH keys.\r\n\r\nThis eliminates the issues with CNAMEs, individual query domain holders having to make changes, DNS namespace issues etc.\r\n\r\nFor example a large hoster wishing to provide cover for some clients by having their primary / CDN front ends offer ESNI for all requests can then simply enable the code on their server then add the ESNI records.  They can even do this gradually over a large pool of servers, thus having some servers with different (or no) ESNI support during each careful rollout of ESNI software upgrades.\r\n\r\nIn practice the following conventions would be used:\r\n\r\n1. Any ESNI server IP must have exactly one PTR record (typically pointing to the hoster domain, such as a typical systematic CDN node DNS name).  Lets call this name ptrnam.dom\r\n\r\n2. The ESNI records would be under _esni.ptrnam.dom\r\n\r\n3. As with most PTR records ptrnam.dom is expected to have exactly one AAAA or A record pointing back at the same IP (if the starting IP is IPv6 only AAAA need to satisfy this, if IPv4 only A, the same ptrnam.dom can be used for one IPv4 and one IPv6 address if the ESNI records would be the same).\r\n\r\n4. For address-less server types such as tor hidden services, the ESNI records would be published via whatever DNS or DNS-like mechanism is used for that transport, or queried by sending a DNS query for the record to the target, allowing the target to respond within that transport.\r\n\r\nBenefits:\r\n\r\n- B1. Large client-facing servers such as CDNs and shared IP hosters can deploy ESNI without having to negotiate DNS changes with all their customers (in fact with any of their customers).\r\n\r\n- B2. Operators of large pools of client-facing servers such as CDNs can roll out ESNI support and ESNI implementation upgrades in a piecemeal and controlled manner similar to how other system updates are rolled out.  Simply because each IP address will have its own ESNI records.\r\n\r\n- B3. ESNI key rotation becomes much simpler as there is no need to synchronize it between different servers in a pool (except where a pure layer 1/2/3 load balancer shares a single IP among multiple physical/virtual servers, such as the layer 2 HALinux scheme).\r\n\r\n- B4. ESNI private key protection can be much stronger when it is not shared among all the servers.  The private key may be kept in protected hardware and/or in volatile RAM.  The latter case would require clients to fall back to a different A or AAAA record until the DNS entries for now forgotten keys to have expired, but only in case of a server crash or similar event.\r\n\r\n- B5. Client queries for ESNI records do not reveal the actual query domain that will be encrypted, only the IP address to which the ESNI extension will be sent.\r\n\r\n- B6. The whole discussion about _esni prefix or no _esni prefix becomes a lot simpler when there is no need to put ESNI records in every end query domain, only domains of the client-facing servers, allowing to keep the unprefixed TXT name space clean for existing uses such as SPF.\r\n\r\nDownsides:\r\n\r\n- P1: Clients will have to postpone the _esni DNS query until after receiving the answer to the A or AAAA query, thus adding an extra DNS roundtrip before the first connection to a name.  The usual DNS caching hierarchy should mitigate this.  In particular for popular CDNs, a client will typically use the same handful of IPs for lots of unrelated traffic, thus getting the ESNI records in its local cache.\r\n\r\n- P2: VM hosting/Physical hosting/connectivity providers not granting PTR name assignment control to IP address customers will cause the same problems as for other protocols (such as mail) and should thus be under the same or greater pressure to add that service.  However since the greatest ESNI benefit is with IPs shared among many unrelated domains, and the operators of such IPs typically have full IP space ownership or the leverage to get PTR records where normal customers cannnot, the effect on ESNI deployment should be limited.\r\n\r\n- P3: This may or may not make it easier to do spoofing attacks, as an MitM attacker can spoof DNS responses either for the A/AAAA records of a target query domain (pointing to servers entirely under the attackers control, including legitimate ESNI records for that server) OR spoof the ESNI records of a server address for which the attacker has obtained traffic intercept ability.  However these can be secured with the same DNS countermeasures already applicable to those DNS domains.\r\n\r\n- P4: query domains wishing to remain available in massively blocking markets (the kind that would not hesitate to block an entire CDN to stop access to a single web page) may have more difficulty opting out of ESNI so such blocking filters can recognize them as a permitted service.\r\n",
      "createdAt": "2019-03-01T18:35:45Z",
      "updatedAt": "2020-05-28T03:57:18Z",
      "closedAt": "2020-05-27T12:20:56Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This has been kicked around before and generally not selected based on the\ndownsides you identify - prinicipally the serialization issue as well as\npractical matters of control of PTR records. It also prohibits the use of\nmore than 1 key on an address - that's obviously a bad thing for the\nanonymity pool at its extreme, but some architectures might require more\nthan one pool.\n\nYou can fix the latter two issues by using another suggestion that has\npreviously been made: connect to the server and validate an IP based\ncertificate and then get the ESNI key via a REST API (or equivalent) - but\nthat is still likely too slow and comes with the challenges of IP based\ncertificate management.\n\nOn Fri, Mar 1, 2019 at 1:35 PM jb-wisemo <notifications@github.com> wrote:\n\n> To maximize the cover range for clients and simplify management of the\n> ESNI records, it is more useful to associate the ESNI records with the\n> server rather than the query domain name. This has the additional benefit\n> of allowing different client-facing servers to use different rotating\n> private DH keys.\n>\n> This eliminates the issues with CNAMEs, individual query domain holders\n> having to make changes, DNS namespace issues etc.\n>\n> For example a large hoster wishing to provide cover for some clients by\n> having their primary / CDN front ends offer ESNI for all requests can then\n> simply enable the code on their server then add the ESNI records. They can\n> even do this gradually over a large pool of servers, thus having some\n> servers with different (or no) ESNI support during each careful rollout of\n> ESNI software upgrades.\n>\n> In practice the following conventions would be used:\n>\n>    -\n>       1. Any ESNI server IP must have exactly one PTR record (typically\n>       pointing to the hoster domain, such as a typical systematic CDN node DNS\n>       name). Lets call this name ptrnam.dom\n>    -\n>       1. The ESNI records would be under _esni.ptrnam.dom\n>    -\n>       1. As with most PTR records ptrnam.dom is expected to have exactly\n>       one AAAA or A record pointing back at the same IP (if the starting IP is\n>       IPv6 only AAAA need to satisfy this, if IPv4 only A, the same ptrnam.dom\n>       can be used for one IPv4 and one IPv6 address if the ESNI records would be\n>       the same).\n>    -\n>       1. For address-less server types such as tor hidden services, the\n>       ESNI records would be published via whatever DNS or DNS-like mechanism is\n>       used for that transport, or queried by sending a DNS query for the record\n>       to the target, allowing the target to respond within that transport.\n>\n> Benefits:\n>\n>    -\n>\n>    B1. Large client-facing servers such as CDNs and shared IP hosters can\n>    deploy ESNI without having to negotiate DNS changes with all their\n>    customers (in fact with any of their customers).\n>    -\n>\n>    B2. Operators of large pools of client-facing servers such as CDNs can\n>    roll out ESNI support and ESNI implementation upgrades in a piecemeal and\n>    controlled manner similar to how other system updates are rolled out.\n>    Simply because each IP address will have its own ESNI records.\n>    -\n>\n>    B3. ESNI key rotation becomes much simpler as there is no need to\n>    synchronize it between different servers in a pool (except where a pure\n>    layer 1/2/3 load balancer shares a single IP among multiple\n>    physical/virtual servers, such as the layer 2 HALinux scheme).\n>    -\n>\n>    B4. ESNI private key protection can be much stronger when it is not\n>    shared among all the servers. The private key may be kept in protected\n>    hardware and/or in volatile RAM. The latter case would require clients to\n>    fall back to a different A or AAAA record until the DNS entries for now\n>    forgotten keys to have expired, but only in case of a server crash or\n>    similar event.\n>    -\n>\n>    B5. Client queries for ESNI records do not reveal the actual query\n>    domain that will be encrypted, only the IP address to which the ESNI\n>    extension will be sent.\n>    -\n>\n>    B6. The whole discussion about _esni prefix or no _esni prefix becomes\n>    a lot simpler when there is no need to put ESNI records in every end query\n>    domain, only domains of the client-facing servers, allowing to keep the\n>    unprefixed TXT name space clean for existing uses such as SPF.\n>\n> Downsides:\n>\n>    -\n>\n>    P1: Clients will have to postpone the _esni DNS query until after\n>    receiving the answer to the A or AAAA query, thus adding an extra DNS\n>    roundtrip before the first connection to a name. The usual DNS caching\n>    hierarchy should mitigate this. In particular for popular CDNs, a client\n>    will typically use the same handful of IPs for lots of unrelated traffic,\n>    thus getting the ESNI records in its local cache.\n>    -\n>\n>    P2: VM hosting/Physical hosting/connectivity providers not granting\n>    PTR name assignment control to IP address customers will cause the same\n>    problems as for other protocols (such as mail) and should thus be under the\n>    same or greater pressure to add that service. However since the greatest\n>    ESNI benefit is with IPs shared among many unrelated domains, and the\n>    operators of such IPs typically have full IP space ownership or the\n>    leverage to get PTR records where normal customers cannnot, the effect on\n>    ESNI deployment should be limited.\n>    -\n>\n>    P3: This may or may not make it easier to do spoofing attacks, as an\n>    MitM attacker can spoof DNS responses either for the A/AAAA records of a\n>    target query domain (pointing to servers entirely under the attackers\n>    control, including legitimate ESNI records for that server) OR spoof the\n>    ESNI records of a server address for which the attacker has obtained\n>    traffic intercept ability. However these can be secured with the same DNS\n>    countermeasures already applicable to those DNS domains.\n>    -\n>\n>    P4: query domains wishing to remain available in massively blocking\n>    markets (the kind that would not hesitate to block an entire CDN to stop\n>    access to a single web page) may have more difficulty opting out of ESNI so\n>    such blocking filters can recognize them as a permitted service.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/139>, or mute the\n> thread\n> <https://github.com/notifications/unsubscribe-auth/AAP5szSqBkYuhH39f6ZWOFhNfNZdY9dlks5vSXMCgaJpZM4bZlWX>\n> .\n>\n",
          "createdAt": "2019-03-01T18:59:29Z",
          "updatedAt": "2019-03-01T18:59:29Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "The PTR record problem is a real issue, but less so for the servers best placed to be anonymity pools.\r\n\r\nThere are other mechanisms of cause.  The key part is making ESNI a server property rather than an origin property, bypassing most of the issues with configuring each of the non-controversial origin domains that are just used as cover traffic.  Hard part is finding a hello content that doesn't stick out by using any values specific to using a controversial domain.  Per origin ESNI would stick out as most origins would feel pressured to not actively join the pool, while having to do something difficult or even pricey to stay out of the pool would be less easy to encourage via generic mass pressure.\r\n\r\nFor the following approaches compare to a normal first TLS connection:\r\n  Round 1: DNS query for A and DNS query for AAAA (happy eyeballs)\r\n  Round 2: TCP SYN\r\n  Round 3: TLS Handshake round 1\r\n\r\nWith the PTR based approach the parallelizing would go like this for first contact (later contacts benefit from DNS caching):\r\n\r\nRound 1: DNS query for A and DNS query for AAAA (happy eyeballs)\r\nRound 2: TCP SYN, DNS query for PTR and DNS query for ESNI keys directly in i*.arpa\r\nRound 3: DNS query for ESNI keys at PTR name (perhaps cached at nearby resolver).\r\n    This round is done only if\r\n     A: no ESNI record (not even an empty one) returned in round 2 AND\r\n     B: PTR name returned and contains the substring \"esni.\"  For example \r\n          example x1234.cdn.esni.example.net or x1234esni.example.net would cause queries of\r\n          _esni.example x1234.cdn.esni.example.net or _esni.x1234esni.example.net\r\nRound 4: TLS Handshake round 1\r\n\r\nRule 3 B would require ESNI client facing servers without ability to add arbitrary reverse records to at least be able to choose a PTR name of the magic form.  Note that the magic form contains no underscore but will only cost an extra DNS lookup returning NXDOMAIN if a non-ESNI server has that name form by chance.  The rule may require further refinement to deal with common provider practices.\r\n\r\nOne technique requiring less round trips than a full HTTP REST API would be to use a clever sequence of TLS extensions, signalling suites etc. to do everything in the TLS layer at the cost of extra TCP round trips compared to the current draft.\r\n\r\nA hybrid approach could go like this (first contact):\r\n\r\n  Round 1: DNS query for A and DNS query for AAAA (happy eyeballs)\r\n  Round 2: TCP SYN, DNS query for _esni.$reverseip.arpa\r\n\r\nIf _esni returned with \"no\" record:\r\n  Round 3: TLS Hello with the signalling suite and normal SNI, server responds normally\r\n\r\nIf _esni returned with key:\r\n   Round 3: TLS hello with ESNI as per draft-02\r\n\r\nIf _esni returned with \"ask\" record:\r\n   Round 3: TCP hello with invalid right-size data in ESNI extension, server sends keys in encrypted ESNI response.\r\n   Round 4: Send new hello with real ESNI extension inside encrypted stream, server forwards to origin server, once encrypted by origin server, client-side server drops the outer encryption and forwards remaining packets unchanged.\r\n\r\nIf no _esni record returned from DNS, server is actually ESNI:\r\n  Round 3: TLS Hello with a signalling suite and no SNI or ESNI, server sends keys in encrypted ESNI response.  In parallel a new TCP SYN.\r\n  Round 4: Send new hello with real ESNI extension inside encrypted stream, server forwards to origin server, once encryption activated by origin server, client-side server drops the outer encryption and forwards remaining packets unchanged.\r\n (Second TCP connection may be used or closed)\r\n\r\nIf no _esni record returned from DNS, server is not ESNI and has a default certificate matching desired SNI:\r\n  Round 3: TLS Hello with a signalling suite and no SNI or ESNI, server server responds normally using its default certificate, client uses the connection.  In parallel a new TCP SYN.\r\n (Second TCP connection may be used or closed)\r\n\r\nIf no _esni record returned from DNS, server is not ESNI and has a default certificate not matching desired SNI:\r\n  Round 3: TLS Hello with a signalling suite and no SNI or ESNI, server server responds normally using its default certificate, client aborts.  In parallel a new TCP SYN.\r\n  Round 4: TLS Hello with the signalling suite and normal SNI, server responds normally.  In parallel the first session is closed.\r\n\r\nIf no _esni record returned from DNS, server is not ESNI and has no default certificate:\r\n  Round 3: TLS Hello with a signalling suite and no SNI or ESNI, server aborts.  In parallel a new TCP SYN.\r\n  Round 4: TLS Hello with the signalling suite and normal SNI, server responds normally  In parallel the first session is closed.\r\n\r\n(Inclusion of the signalling suite after concluding its a non-esni server is to detect downgrade attacks)\r\n\r\nIntent is that the 4 round cases will be less common than the 3 round cases.  All subsequent contacts to same server IP (up to a cache period) will be simply:\r\n  Round 1: TCP SYN\r\n  Round 2: TLS Hello according to cached type and keys (with or without session resumption), Server responds as expected.\r\n\r\nNeither approach requires special IP address certificates.",
          "createdAt": "2019-03-01T23:11:31Z",
          "updatedAt": "2019-03-01T23:11:31Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> A hybrid approach could go like this (first contact):\r\n> \r\n> Round 1: DNS query for A and DNS query for AAAA (happy eyeballs)\r\n> Round 2: TCP SYN, DNS query for _esni.$reverseip.arpa\r\n> \r\n> If _esni returned with \"no\" record:\r\n> Round 3: TLS Hello with the signalling suite and normal SNI, server responds normally\r\n> \r\n> If _esni returned with key:\r\n> Round 3: TLS hello with ESNI as per draft-02\r\n\r\nI agree that this method does not introduce an additional round-trip for TCP. But it will for QUIC, and I do not think we'd want to have that overhead always for QUIC.",
          "createdAt": "2019-03-02T22:26:10Z",
          "updatedAt": "2019-03-02T22:26:10Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "Since QUIC is a new undeployed protocol running on UDP instead of TCP, it can move its SNI-like operation into the encrypted part and (where applicable) use some kind of in-protocol session resumption to switch from client-facing server public keys to origin server public keys.  QUIC can also design its own mechanism for providing an encrypted non-repeating origin server indication in the early client to server packets.",
          "createdAt": "2019-03-07T17:26:51Z",
          "updatedAt": "2019-03-07T17:26:51Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that QUIC is already using TLS 1.3, I'd prefer that it be able to share mechanisms.",
          "createdAt": "2019-03-07T17:34:19Z",
          "updatedAt": "2019-03-07T17:34:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is orthogonal to the contents of the draft. Namely, servers could maintain this sort of IP<->key association on their own without any client changes. Thus, closing as is. Please re-open if you think otherwise and have a suggested change for the document!",
          "createdAt": "2020-05-27T12:20:56Z",
          "updatedAt": "2020-05-27T12:20:56Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "Closing reason seems a complete misunderstanding.  I have not checked how my old wording fits or does not fit the current draft.\r\n\r\nIssue #139 is about handling multiple public servers (with different \"client-facing\" server IPs and different configuration), not about tracking client IPs.",
          "createdAt": "2020-05-28T03:55:26Z",
          "updatedAt": "2020-05-28T03:55:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The reasoning above isn\u2019t about tracking client IPs. Please give the latest draft a review and re-open if you think it\u2019s needed. And please provide suggested changes if they\u2019re needed!",
          "createdAt": "2020-05-28T03:57:18Z",
          "updatedAt": "2020-05-28T03:57:18Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "MDU6SXNzdWU0MTYyMzEwNzM=",
      "title": "Minor nit: This is static DH, not DHE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/140",
      "state": "CLOSED",
      "author": "jb-wisemo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Since the mechanism is essentially static DH key mode (with ephemeral client key), the text should not refer to it as DHE / ECDHE, as those acronyms indicate that both sides use a fresh ephemeral (EC)DH key for each connection, when the client-facing server is in fact using a fixed key (which may be rotated a lot more often than a key from a certificate).",
      "createdAt": "2019-03-01T18:43:17Z",
      "updatedAt": "2019-03-06T22:42:28Z",
      "closedAt": "2019-03-06T22:42:28Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We'll likely address this by adopting notation and terminology from HPKE. See #145.",
          "createdAt": "2019-03-06T22:42:28Z",
          "updatedAt": "2019-03-06T22:42:28Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "MDU6SXNzdWU0MTYyNDE0MTg=",
      "title": "Use the RFC1952/ISO3309/V.42 CRC32",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/141",
      "state": "CLOSED",
      "author": "jb-wisemo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Since the 32 bit checksum in ESNI records does not server a cryptographic purpose, only error detection, and since the chosen suite for the exchange does not necessarily use the SHA-256 algorithm, it would be more efficient to use a dedicated fast error detecting checksum.  The CRC32 algorithm used in RFC1952 (gzip), ISO 3309 and ITU-T V.42 is optimized for this task, widely available in software and hardware, and likely to already be implemented in ESNI using systems for other purposes.\r\n\r\nThis would also remove the only part of the draft that requires a specific single cryptographic algorithm, thereby making the specification algorithm agile without introducing any new algorithm registries for IANA to maintain.",
      "createdAt": "2019-03-01T19:13:32Z",
      "updatedAt": "2019-06-17T18:21:16Z",
      "closedAt": "2019-06-17T18:21:16Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see how this makes it algorithm agile, it just requires baking in some other algorithm. Given that for the foreseeable future, every TLS 1.3 stack will have SHA-256, this would seem to make the implementation profile strictly worse. As for performance, the SHA-256 is trivial compared to the EC cost.",
          "createdAt": "2019-03-01T19:20:39Z",
          "updatedAt": "2019-03-01T19:20:39Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "CRC32 makes no pretense to be a cryptographic algorithm, hence is not subject to the usual considerations of cryptographic algorithm agility.  A key lesson from baking SHA-1 into earlier protocols was that keeping it around for protocol compatibility made it more difficult to ensure it wasn't used in places where it would cause security issues.  Looking forward a few decades, there is little or no assurance that SHA-256 won't be in a similar situation.  In contrast the error detection abilities of CRC-32 (the only purpose it has in this place) has been proven mathematically, has survived for much much longer and is much faster to run before deciding if the cryptographic calculations are needed at all.  Like my other proposals, it's all about simplifying the protocol extension as much as possible.",
          "createdAt": "2019-03-01T20:09:38Z",
          "updatedAt": "2019-03-01T20:09:38Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I am familiar with these arguments, but I don't agree that this is a meaningful simplification. SHA-256 does not need to be agile in this case.\r\n",
          "createdAt": "2019-03-01T20:10:56Z",
          "updatedAt": "2019-03-01T20:10:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @ekr here. Modern TLS implementations already have support for SHA-256 whereas CRC32 isn't always readily available.",
          "createdAt": "2019-03-01T23:56:35Z",
          "updatedAt": "2019-03-01T23:56:35Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "You seem to misunderstand the issue.  The problematic scenario is this:\r\n\r\n1. Many years from now, SHA-256 is broken by new research (not faster computers), similar to what happened to MD5.\r\n\r\n2. Everyone works hard to remove SHA-256 from their cryptographic applications, or at least establish onerous review procedures to ensure any remaining SHA-256 invocation is not a security problem.\r\n\r\n3. ESNI using SHA-256 for a non-cryptographic purpose will then become a very real practical liability, as every implementation will need to make excuses and audit documents just to prove they are not really using SHA-256 for anything risky.\r\n\r\nIf in contrast, ESNI used something non-cryptographic, like CRC-32 or the TCP checksum algorithm, this step 3 of the problem wouldn't happen.  Of the commonly implemented short checksums, CRC-32 is the only one optimized for detecting accidental data corruption, while the other are optimized for tiny speed margins at the cost of less effective detection.\r\n\r\nAs for CRC-32 being available in ESNI implementations, this is likely to be present already because it is used in gzip HTTP compression, but standard CRC-32 may be available for many other reasons.  Anyway, CRC-32 is a trivially small algorithm that doesn't need CPU specific optimization for the data sizes in question.",
          "createdAt": "2019-03-07T16:39:17Z",
          "updatedAt": "2019-03-07T16:39:17Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I understood the scenario and I've been through this before with SHA-1. I don't think that this is a particularly serious concern.",
          "createdAt": "2019-03-07T17:33:26Z",
          "updatedAt": "2019-03-07T17:33:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "SHA-256 is fine for this purpose. Closing for now.",
          "createdAt": "2019-06-17T18:21:16Z",
          "updatedAt": "2019-06-17T18:21:16Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWU0MTYyNTM2OTg=",
      "title": "Eliminating record_digest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/142",
      "state": "CLOSED",
      "author": "jb-wisemo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "To simplify implementation, the record_digest can be eliminated as follows:\r\n\r\n1. In ESNIKeys, provide a server-assigned 32 bit id.  Servers are free to manage that id space as they see fit e.g. to optimize lookup in a history of rotating keys.  However the server MAY obscure any structure in the numbering in any convenient manner.  As a further optimization, move all fixed length fields before the variable length fields and order them such that natural alignment is achieved (as per IETF tradition).\r\n\r\n2. In ClientEncryptedSNI, insert the 32 bit id right after the Ciphersuite, making it part of the fixed-length part of the structure.  The record_digest field and its calculation is removed, thus reducing the size of the ESNI extension.\r\n\r\n3. In ESNIContents, just use the full record instead of hashing it separately.  This costs a few extra blocks of hash invocations (as the cache record_digest can no longer be cached for each hash algorithm), but simplifies the code.  Alternatively, record_digest can be kept for this non-transmitted field to preserve that caching opportunity.",
      "createdAt": "2019-03-01T19:49:21Z",
      "updatedAt": "2019-07-03T00:57:49Z",
      "closedAt": "2019-07-03T00:57:49Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not in favor of this proposal. Computing record_digest is quite trivial as is, and using SHA256 gives us good assurance of its correctness. That is, we don't have to worry about servers possibly assigning incorrect IDs.",
          "createdAt": "2019-06-25T20:44:55Z",
          "updatedAt": "2019-06-25T23:47:03Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We do have to worry about collisions, which could be even harder to get right.  I don't think that sending it in the record makes any sense, but as an identifier, a hash is fine.",
          "createdAt": "2019-06-25T23:46:00Z",
          "updatedAt": "2019-06-25T23:46:00Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So my new insight here is that corruption of DNS records (if that does happen) will now be detected with `record_digest` and corrected through the use of the fallback mechanism.  So that makes `record_digest` important, but `checksum` useless.",
          "createdAt": "2019-07-03T00:53:45Z",
          "updatedAt": "2019-07-03T00:53:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Since a cryptographic proof of key possession is needed for downgrade protection, we can't remove record_digest in this way. Thus, I'm closing this issue as NTBF. ",
          "createdAt": "2019-07-03T00:57:49Z",
          "updatedAt": "2019-07-03T00:57:49Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "MDU6SXNzdWU0MTYzMzAxMzI=",
      "title": "gh-pages is stale",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/143",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The Editor's Copy link leads to a version of the document from July 4, 2018, and there have been no commits to the gh-pages branch since then.  The document is obviously in active development, which suggests that CI is broken / not configured on this repo.",
      "createdAt": "2019-03-02T00:24:43Z",
      "updatedAt": "2019-07-03T01:33:53Z",
      "closedAt": "2019-07-03T01:33:53Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed -- sorry for the delay!",
          "createdAt": "2019-07-03T01:33:53Z",
          "updatedAt": "2019-07-03T01:33:53Z"
        }
      ]
    },
    {
      "number": 145,
      "id": "MDU6SXNzdWU0MTcwOTI1NzQ=",
      "title": "Adopt HPKE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/145",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "See https://datatracker.ietf.org/doc/draft-barnes-cfrg-hpke/ for more info. ",
      "createdAt": "2019-03-05T03:03:26Z",
      "updatedAt": "2020-03-09T21:58:07Z",
      "closedAt": "2020-03-09T21:58:07Z",
      "comments": [
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "Please don't.  The TLS series of RFCs and other related RFCs already contain established terminology for anything in the HPKE draft.   HPKE is basically two guys thinking they reinvented the wheel.",
          "createdAt": "2019-03-07T16:04:51Z",
          "updatedAt": "2019-03-07T16:04:51Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm... As one of the designers of the construction in this current ESNI draft, I would welcome a more carefully vetted construction that came with the CFRG's endorsement, and I generally assume that Karthik and Richard are at least as well equipped to design this as I am.",
          "createdAt": "2019-03-07T16:08:38Z",
          "updatedAt": "2019-03-07T16:09:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to second what @ekr says. In a way, this document reinvents the wheel. We should defer such constructions to the CFRG.",
          "createdAt": "2019-03-07T17:56:57Z",
          "updatedAt": "2019-03-07T17:56:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is part of #207, as discussed in Singapore.",
          "createdAt": "2020-03-08T00:33:26Z",
          "updatedAt": "2020-03-08T00:33:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #207.",
          "createdAt": "2020-03-09T21:58:07Z",
          "updatedAt": "2020-03-09T21:58:07Z"
        }
      ]
    },
    {
      "number": 146,
      "id": "MDU6SXNzdWU0MTczMjEwODk=",
      "title": "User tracking via ESNI keys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/146",
      "state": "CLOSED",
      "author": "kirsey",
      "authorAssociation": "NONE",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "help wanted"
      ],
      "body": "If each client receives a unique ESNI key from a DNS provider, it is possible to link every usage of this key to the same client. It seems feasible that online services, as well as passive observers of the network traffic, can exploit such a practice for user tracking.\r\n\r\nTo enhance the privacy protections of this draft, we should describe these privacy risks in the draft. Furthermore, I recommend a clear restriction on the clients\u2019 caching durations of ESNI keys. For example, clients MUST NOT cache ESNI keys longer than 24 hours and as privacy protection, it is RECOMMENDED to cache ESNI keys only for 10 minutes.",
      "createdAt": "2019-03-05T14:18:34Z",
      "updatedAt": "2020-10-16T17:14:15Z",
      "closedAt": "2020-05-05T20:10:31Z",
      "comments": [
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "To avoid downgrade attacks (by simply filtering out the key DNS response), clients should cache the fact that there is/was an ESNI key significantly longer, perhaps 14 days.  During these 14 days the server can authoritatively report that it no longer has a key, and it can change the key.  But the client would actively look for ESNI support before falling back to plain SNI for that server.\r\n\r\nBug #139 comment 3 contains a proposal that can implicitly handle the case \"client thinks server has ESNI, but doesn't know the current keys or if it has been turned off again server side\"",
          "createdAt": "2019-03-07T17:27:38Z",
          "updatedAt": "2019-03-07T17:27:38Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not believe this will work. In multi-cdn scenarios, clients will sometimes just get an ESNIKeys record sometimes and no record other times and that's normal",
          "createdAt": "2019-03-07T17:32:23Z",
          "updatedAt": "2019-03-07T17:32:23Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think noting that this can track you within the same origin is a worthwhile thing to note - it gets added to a whole bucket of things with the same property (e.g. AAAA).\r\n\r\nAs its not really adding anything to that problem I'm not in favor of recommending particular cache ceilings which may or may not really address the issue anyhow..",
          "createdAt": "2019-03-07T17:54:10Z",
          "updatedAt": "2019-03-07T17:54:10Z"
        },
        {
          "author": "kirsey",
          "authorAssociation": "NONE",
          "body": "I observe, that TLS has a tradition in providing upper limits for caching durations. I think this is a good practice as it restricts the harm of an extreme configuration.\r\n\r\nFurthermore, I see added value in recommending a best practice configuration at least for a specific application type such as browsers because it leads to a description of the trade-offs at hand and facilitates the implementation. ",
          "createdAt": "2019-03-07T20:21:16Z",
          "updatedAt": "2019-03-07T20:21:16Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "The document already sets the maximum TTL to the lifetime of the SNI key.\r\nIt also recommends that \"servers rotate keys frequently\" to reduce the harm from compromised keys.\r\n\r\nSo it seems that short-lived keys are good both for security and privacy.\r\n\r\nA recommended value would be useful.\r\nOtherwise \"frequently\" could be interpreted as months.",
          "createdAt": "2019-03-08T00:10:09Z",
          "updatedAt": "2019-03-08T00:10:21Z"
        }
      ]
    },
    {
      "number": 149,
      "id": "MDU6SXNzdWU0MTk2NTA2ODU=",
      "title": "Replay attack and timestamp",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/149",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "needs WG discussion"
      ],
      "body": "Attackers cannot successfully replay a ClientHello and ESNI extension and establish a connection with the server. However, they can replay a ClientHello and examine whether it triggers a positive response. This can be used to check whether a server is still present. This is a particular concern when using ESNI in local discovery mode, where merely eliciting a response would be enough to give away a server's presence.\r\n\r\nTo protect against such attacks, I consider adding two elements in the ESNI:\r\n\r\n1) A 64 bit timestamp, set to the date at which the client sent the message.\r\n2) The IPv6 address from which the client is sending the message.\r\n\r\nThe timestamp prevents repeat of a message over time. The IPv6 address prevents repeat of the message from a different location. I mention IPv6 here because of NAT, of course.\r\n\r\nWhat do you think? Should that be encoded as part of `ClientEncryptedSNI` or `ClientESNIInner`? Or should it just be encoded as a separate ClientHello extension?",
      "createdAt": "2019-03-11T19:45:33Z",
      "updatedAt": "2019-11-22T14:14:30Z",
      "closedAt": "2019-11-22T14:14:30Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the timestamp idea.  Even if it is only fuzzy.  The timestamp seems adequate, because the fact that a server remains active over short timescales is not that interesting - more so if the connection that is being replayed is still active.  \r\n\r\nFor the timestamp, fewer bits will be sufficient as long as the timestamp can express a longer duration than the maximum key validity.  32 bits is plenty, assuming second resolution.  16 might even suffice.",
          "createdAt": "2019-03-11T21:54:09Z",
          "updatedAt": "2019-03-11T21:54:09Z"
        },
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Frequent ESNIKeys rotation (and subsequent enforcement by the server) should mitigate this issue a bit.\r\n\r\nEncoding the time as-is would undo the effect of [removing the time from the client random field](https://mailarchive.ietf.org/arch/msg/tls/_clS-TIIlZUcid_2S4WPej9iMWk). Not sure if that is desirable.\r\n\r\nWhat is your attacker's model? Even with a truncated timestamp (e.g. in 1 minute intervals), there is still a time span where the confirmation attack could be executed. And if you are worried about an adversary who is trying to raid a data center and needs to track down a physical machine behind a load balancer, then having the IPv6 address binding would not help since the attacker could just spoof packets.",
          "createdAt": "2019-06-03T01:24:14Z",
          "updatedAt": "2019-06-03T01:24:14Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How long would the server's \"replay window\" be in terms of time? If it's less than say, a day, the server would start seeing a lot of spurious failures due to client clock skew.",
          "createdAt": "2019-06-03T12:47:51Z",
          "updatedAt": "2019-06-03T12:47:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Likewise the client will observe failures, and these will hit all connections for some small fraction of users, which is much worse than hitting some small fraction of connections for all users.\r\n\r\nIs the expectation that the client would fail the connection or retry without ESNI? The latter has a clear downgrade attack, while the former strongly discourages ESNI deployment. I would need to check with folks on what kinds of clock skews are observed, but I expect it would be much *much* higher than a day.\r\n\r\nNow that we have the robustness mechanism (if the server does not recognize ESNI, it just responds based on SNI) is that sufficient to resolve this? The server will respond with *something* either way, and the attacker can't tell which certificate it was.",
          "createdAt": "2019-06-03T15:50:19Z",
          "updatedAt": "2019-06-03T15:50:57Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben has a point about fallback to SNI.  If use of the fallback SNI is indistinguishable from successful use of ESNI, then we're good: the observer gains nothing.  Is that a requirement we levy on servers though?\r\n",
          "createdAt": "2019-07-03T00:08:48Z",
          "updatedAt": "2019-07-03T00:08:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, is indistinguishability possible? In the fallback SNI case, the server's EE might carry one or more ESNIKeys, which inflates the size of this message well beyond the EE message size in the normal (non-fallback) case. If we want to make them indistinguishable, we'd probably need to recommend further requirements that the server's EE message(s) are the same in both cases, which is not great. ",
          "createdAt": "2019-07-03T00:29:36Z",
          "updatedAt": "2019-07-03T00:29:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good point.  The extra bits will appear to be part of the certificate chain from the outside.  That means potentially padding everything.  If that is a problem, could the fallback be made to appear more like a response to a request?  That's structurally very different though, and perhaps not worth the pain.",
          "createdAt": "2019-07-03T00:32:04Z",
          "updatedAt": "2019-07-03T00:32:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema how do you want to proceed here? ",
          "createdAt": "2019-11-04T20:47:28Z",
          "updatedAt": "2019-11-04T20:47:28Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think the issue is mitigated yet. The problem is a \"discovery oracle\", and it is linked to a very specific ESNI usage: broadcast an ESNI on the local network to check whether someone will respond. In the normal case, the response is processed by the node doing the discovery. The issue is that an attacker can replay the message later and see whether the client is still there.\r\n\r\nThis is not a \"mainline\" ESNI issue, but just an issue arising from trying to use ESNI in a discovery scenario with Quic or DTLS. It is probably OK to not consider it for the current ESNI design, and to address it in the \"discovery scenario\" design.\r\n\r\nHence, close with no action.",
          "createdAt": "2019-11-22T14:14:29Z",
          "updatedAt": "2019-11-22T14:14:29Z"
        }
      ]
    },
    {
      "number": 150,
      "id": "MDU6SXNzdWU0MjYyNTQ1NzU=",
      "title": "record_digest should not cover address_set",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/150",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Filing this so we don't forget:\r\n\r\nCurrently the record digest covers the address_set extension. This means adding a new addresses to a deployment introduces new digests that need to be propagated to all servers to recognize. (Unless servers trial decrypt everything, but then record digests aren't doing anything.)\r\n\r\nPerhaps the A/AAAA + ESNI gluing should external to the ESNIKeys structure. The glue is probably assembled by DNS serving logic, while ESNIKeys is otherwise probably an opaque blob assembled by some key provisioning system.",
      "createdAt": "2019-03-28T01:38:56Z",
      "updatedAt": "2019-04-18T16:40:57Z",
      "closedAt": "2019-04-18T16:40:57Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Made #151 to try to address this by excluding extensions from the digest. A DNS server that knows it will generate extensions can keep the rest of ESNIKeys as blob, and then simply append extensions to it when serving the record. Otherwise I wouldn't know where to put the AddressSet thingy.",
          "createdAt": "2019-04-09T22:10:55Z",
          "updatedAt": "2019-04-09T22:10:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What do you think about splitting it in two layers?\r\n\r\nFirst you've got ESNIKeys as it existed prior to address_set. The record digest covers the whole thing as before. DNS believes it's just an opaque blob.\r\n\r\nThen you've got, say, some BUNDLE RRTYPE whose RDATA encodes a list of (RRTYPE, RDATA) tuples in whatever DNS-y syntax people want. The DNS server then just assembles a BUNDLE with A and AAAA formatted as before, plus an ESNI record with it. This avoids this odd situation we have here where ESNI wants to be the root of the tree, to the exclusion of everyone else who may wish to correlate data with A/AAAA.\r\n\r\nA nuisance here: we do want to avoid the client having to ask for all of A, AAAA, ESNI, *and* BUNDLE. It is more risk of performance problems and acting on any response to ESNI would reintroduce multi-CDN woes. We'd have to say ESNI can only be fetched via BUNDLE or so. (That perhaps suggests the \"keys\" in BUNDLE should be its own namespace? Other than A/AAAA, everything else is likely to never be fetched on its own.)",
          "createdAt": "2019-04-09T22:30:00Z",
          "updatedAt": "2019-04-09T22:30:00Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the problem is really in DNS, and a complete solution needs to happen there. However I think it's orthogonal to ESNI, and should probably be discussed on its own (e.g. in dnsop).\r\n\r\nThere was some talk in Prague about doing that but AFAICT nothing happened yet, so I'd be interested in helping put a  BUNDLE proposal together if nothing else comes up, and see what the DNS people think.\r\n\r\nIn the meantime AddressSet is what we have, and it's probably easier to just make that work for the specific ESNI case in the short term, and then replace it with whatever BUNDLE solution comes out later on, so the two discussions can proceed in parallel.",
          "createdAt": "2019-04-11T12:55:31Z",
          "updatedAt": "2019-04-11T12:55:31Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, we don't have anything right now because address_set doesn't work. :-P We can change the syntax however we like, be it defining BUNDLE in the ESNI doc, or doing something quick and hacky like:\r\n\r\n```\r\nstruct {\r\n  ESNIKeys keys;\r\n  Address address_set<0..2^16-1>;\r\n} ESNIKeysWithAddresses;\r\n```",
          "createdAt": "2019-04-12T15:54:26Z",
          "updatedAt": "2019-04-12T15:55:34Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My +1 goes to doing this hack, assuming that it helps somebody deploying ESNI.\r\n\r\nIf it turns out to be a bad idea, we can switch to a different mechanism by just bumping the version number in ESNIKeys.",
          "createdAt": "2019-04-12T16:11:13Z",
          "updatedAt": "2019-04-12T16:11:13Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben yeah, so that's similar to @chris-wood's proposal of just having an additional extensions field that doesn't go into record_digest. The additional extensions field would be somewhat more flexible and accomodate both address_set and the other multi-CDN proposal if it ever shows up. Do we care about this flexibility?\r\n\r\nI find both solutions kinda yucky, but I guess those are the options we have. I can update my PR (or create a new one) with whatever new hack.",
          "createdAt": "2019-04-12T17:38:14Z",
          "updatedAt": "2019-04-12T17:38:14Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually, I don't know if the other multi-CDN proposal would have the same problem, so maybe the extensibility is not needed?",
          "createdAt": "2019-04-12T17:40:22Z",
          "updatedAt": "2019-04-12T17:40:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ghedo @davidben @kazuho @ekr \r\n\r\nHow about:\r\n\r\n~~~\r\nstruct {\r\n  ESNIKeys keys;\r\n  Extensions dns_extensions<0..2^16-1>;\r\n} ESNIKeysWithExtensions;\r\n~~~\r\n\r\nWe can then put address_set in dns_extensions, and TLS stacks don't ever have to see them.",
          "createdAt": "2019-04-12T17:44:57Z",
          "updatedAt": "2019-04-12T17:44:57Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, was thinking something along those lines, I'll see if I can put it into text in the next few days if nobody beats me to it.",
          "createdAt": "2019-04-12T17:47:17Z",
          "updatedAt": "2019-04-12T17:47:17Z"
        }
      ]
    },
    {
      "number": 155,
      "id": "MDU6SXNzdWU0MzcyMjA2MTg=",
      "title": "Clarification on AAD for ClientEncryptedSNI.encrypted_sni",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/155",
      "state": "CLOSED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It was initially not clear to me what should be included in the AAD for encrypting ClientESNIInner into ClientEncryptedSNI.encrypted_sni. The spec currently says:\r\n\r\n> The ClientEncryptedSNI.encrypted_sni value is then computed using the usual TLS 1.3 AEAD:\r\n>\r\n>     encrypted_sni = AEAD-Encrypt(key, iv, ClientHello.KeyShareClientHello, ClientESNIInner)\r\n>\r\n> Where ClientHello.KeyShareClientHello is the body of the extension but not including the extension header.\r\n\r\nClientHello.KeyShareClientHello is not defined in this document. At first I thought it would cover ClientEncryptedSNI.key_share, but that seemed odd.\r\n\r\nLater I found that it refers to the Key Share extension defined in [RFC 8446, Section 4.2.8. Key Share](https://tools.ietf.org/html/rfc8446#section-4.2.8). Perhaps this reference could be added?\r\n\r\nOn a related note, `HKDF-Extract(0, Z)` should probably become `HKDF-Extract(\"\", Z)` or be explicit about the salt as is done in https://tools.ietf.org/html/rfc8446#section-7.1 (or https://tools.ietf.org/html/rfc5869#section-2.2).",
      "createdAt": "2019-04-25T14:08:57Z",
      "updatedAt": "2019-06-02T19:57:43Z",
      "closedAt": "2019-06-02T19:57:43Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "FWIW, I also had a little trouble with this. My initial interpretation was to use the h/s key share that ends up being used as the AAD, which worked fine for my client (vs cloudflare) and for my server (vs. NSS' tstclnt). In each of those cases though only one key share was sent by the client. FF nightly however sends two key shares in the h/s so I had to change my code to do the right thing. Could be worth a note in the internet-draft e.g. saying to use (the encoding of) all key shares from the h/s and that some clients do send more than one.  ",
          "createdAt": "2019-06-02T15:15:57Z",
          "updatedAt": "2019-06-02T15:16:33Z"
        }
      ]
    },
    {
      "number": 156,
      "id": "MDU6SXNzdWU0NDQwNzA0ODM=",
      "title": "Require OCSP stapling for ESNI",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/156",
      "state": "CLOSED",
      "author": "J0WI",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Since OCSP is [leaking](https://bugzilla.mozilla.org/show_bug.cgi?id=1535235#c3) the server name, ESNI should probably enforce OCSP stapling (similar to [RFC 7633](https://tools.ietf.org/html/rfc7633)) or any other way of encrypted OCSP checks.\r\nIgnoring OCSP status checks entirely makes it hard to revoke a certificate, even if it's only valid for a few months.\r\n\r\n",
      "createdAt": "2019-05-14T18:51:20Z",
      "updatedAt": "2019-07-04T01:12:54Z",
      "closedAt": "2019-07-04T01:12:54Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@J0WI what behavior do you expect here? Would clients fail hard if server don't send stapled responses? It's good to view ESNI as part of the leaky boat problem. It plugs one hole, but not all of them. Implementations probably should do something about cleartext OCSP if they want all holes plugged. ",
          "createdAt": "2019-07-03T04:04:57Z",
          "updatedAt": "2019-07-03T04:04:57Z"
        }
      ]
    },
    {
      "number": 160,
      "id": "MDU6SXNzdWU0NTUzNjc3NDQ=",
      "title": "Including Presentation language",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/160",
      "state": "CLOSED",
      "author": "mrsylerpowers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "I believe it will be helpful to understanding this document to either add \"Presentation Language\" to this document or link to Presentation Language elsewhere. The TLS/1.3 document has something similar in [RFC8446 Section 3](https://tools.ietf.org/html/rfc8446#section-3)",
      "createdAt": "2019-06-12T18:44:41Z",
      "updatedAt": "2019-07-03T01:09:00Z",
      "closedAt": "2019-07-03T01:09:00Z",
      "comments": []
    },
    {
      "number": 171,
      "id": "MDU6SXNzdWU0NjY2MjMzODU=",
      "title": "Formal analysis",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/171",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need some form of analysis before we ship this. Filing an issue to track that task.",
      "createdAt": "2019-07-11T02:25:38Z",
      "updatedAt": "2019-07-16T16:55:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mrsylerpowers",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood Do you think that this draft is about ready for ship?\r\n",
          "createdAt": "2019-07-16T15:20:49Z",
          "updatedAt": "2019-07-16T15:20:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "No, not yet.",
          "createdAt": "2019-07-16T16:55:06Z",
          "updatedAt": "2019-07-16T16:55:06Z"
        }
      ]
    },
    {
      "number": 173,
      "id": "MDU6SXNzdWU0NzEyMTc5NjM=",
      "title": "Lingering references to `sni` instead of `dns_name`",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/173",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Stephen Farrell on the TLS WG list:\r\n\r\nJust spotted that:\r\n\r\n   opaque zeros[ESNIKeys.padded_length - length(sni)];\r\n\r\nshould I guess now be:\r\n\r\n   opaque zeros[ESNIKeys.padded_length - length(dns_name)];\r\n\r\nAnd maybe s/PaddedServerNameList/PaddedDNSName/ would also make sense.",
      "createdAt": "2019-07-22T17:39:28Z",
      "updatedAt": "2019-08-15T22:20:15Z",
      "closedAt": "2019-08-15T22:20:15Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Think this is fixed now?",
          "createdAt": "2019-08-15T22:19:26Z",
          "updatedAt": "2019-08-15T22:19:26Z"
        }
      ]
    },
    {
      "number": 177,
      "id": "MDU6SXNzdWU0NzI0MzU0Nzk=",
      "title": "GREASE ESNI extensions are easily distinguished from real ones",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/177",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "davidben",
        "chris-wood"
      ],
      "labels": [],
      "body": "The draft has provisions for GREASE ESNI extensions, per \"Do not stick out\". However, this is not very effective if an attacker can distinguish a GREASE ESNI extension from a real one.\r\n\r\n#154 tried to address this, but it doesn't work if the (public) ESNI record is known. There's also a simpler attack: replay the ClientHello with one byte of ciphertext corrupted. ESNI currently distinguishes key mismatch from decrypt failure, with the latter resulting in an alert. We can fix that by saying decrypt failure should behave like key mismatch. This still leaves record_digest.\r\n\r\nThe natural fix is to drop record_digest in favor of trial decryption. The cost is the server must perform a DH operation per known key. The number of keys the server needs depends on its DNS TTLs and key rotation. (I think it's 1 + ceil(dns_ttl / time_between_rotation), plus some leeway[*].)\r\n\r\nInstead, we can keep a key name, but make the space dense. Suppose we replace it with a B-bit \"key phase\". The server picks a random starting key phase. Then, each time it rotates the keys, it increments the phase, with wraparound. The server then gets 2<sup>B</sup> keys for free. If it needs more, it still needs trial decryption but gains a 2<sup>B</sup> multiplicative factor in the cost. On the flip side, an individual GREASE extension with a random key phase has a 1/2<sup>B</sup> chance of colliding with a particular ESNI key.\r\n\r\nI'm not sure we actually need that many live keys, so B = 2 is probably plenty. Or even B = 1 if we say you should just rotate slower than your DNS TTL.\r\n\r\n[*] Note the robustness mechanism means that server doesn't need to cover _all_ clients with stale keys. The retry is expensive, so the server still needs to cover _almost all_ of them, but it can cut off the long tail.",
      "createdAt": "2019-07-24T18:37:10Z",
      "updatedAt": "2020-05-27T12:18:22Z",
      "closedAt": "2020-05-27T12:18:21Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mostly a note to myself for the actual PR: the draft should also discuss padding of the EncryptedExtensions message.",
          "createdAt": "2019-07-29T23:53:40Z",
          "updatedAt": "2019-07-29T23:53:40Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we really need to go back to first principles here and ask what it is we are trying to accomplish.  First, it's public information whether a given server supports ECHO, so if an attacker wants to know that, it can mostly just ask [there is some complexity around getting candidate names, but note that you can always get the public name from the SNI value and any real attacker will see a lot of non-ECHO traffic and so will know a bunch of SNI values].\r\n\r\nWhat's not public information is whether a given *connection* uses ECHO. The attacker might not know this either because:\r\n\r\n1. It knows that the server is ECHO-supporting.\r\n1. It has a limited view of just the connection and isn't willing to do do the work of trying to determine if the server is ECHO-supporting.\r\n\r\nIn case (1) I would also expect that the attacker is not going to go to the trouble of doing probe connections, as determining if the server is ECHO supporting is easier. This leaves us with the case where the attacker knows that the server is ECHO supporting and that the client *knows* about ECHO (otherwise it couldn't generate GREASE) but doesn't know if the client is actually doing ECHO. Do we expect there to be a lot of clients like this? Why not just do ECHO?\r\n\r\n\r\n",
          "createdAt": "2020-04-24T14:46:10Z",
          "updatedAt": "2020-04-24T14:46:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As per today's call, we're going to revisit the GREASE threat model and then reconvene if further work is needed.",
          "createdAt": "2020-04-27T22:02:57Z",
          "updatedAt": "2020-04-27T22:02:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm moving to closes this issue as resolved by #235. If we need to do something against connection blocking adversaries, perhaps we should look into MASQUE for that.",
          "createdAt": "2020-05-20T16:00:52Z",
          "updatedAt": "2020-05-20T16:00:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now. @davidben, please re-open if you still think we should address this!",
          "createdAt": "2020-05-27T12:18:21Z",
          "updatedAt": "2020-05-27T12:18:21Z"
        }
      ]
    },
    {
      "number": 178,
      "id": "MDU6SXNzdWU0NzI4OTMzMzY=",
      "title": "Cryptographic configuration consistency",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/178",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "There is an unstated constraint on deployments.  All servers in the same anonymity set need to have the same cryptographic configuration.\r\n\r\nThis means that they choose the same key exchange groups/cipher/etc.. when presented with the same ClientHello.  Concretely, servers need to produce the same profile for the ServerHello, because the ServerHello is not encrypted and the form of a ServerHello could be used to split the anonymity set if different servers make different choices.",
      "createdAt": "2019-07-25T14:18:36Z",
      "updatedAt": "2019-11-04T21:41:08Z",
      "closedAt": "2019-11-04T21:41:08Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussion in the room in Montreal suggested that this would not be a requirement, but more of the form of an observation and suggestion.  That is, the document would note that if cryptographic configuration is not consistent, the anonymity set fractures into as many sets as there are configurations.  Then it will recommend (but not require) that uniformity is desirable.",
          "createdAt": "2019-07-25T14:43:15Z",
          "updatedAt": "2019-07-25T14:43:15Z"
        }
      ]
    },
    {
      "number": 179,
      "id": "MDU6SXNzdWU0NzI5NDc0ODY=",
      "title": "Decouple ESNIKeys and the envelope DNS record",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/179",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This will let us adopt another delivery mechanism (HTTPSVC?) if needed later on.",
      "createdAt": "2019-07-25T16:00:18Z",
      "updatedAt": "2019-11-02T01:02:04Z",
      "closedAt": "2019-11-02T01:02:03Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We already have `ESNIKeys` and `ESNIRecord` as different structures, wouldn't a different delivery mechanism be able to simply wrap `ESNIKeys` in its own transport, without the DNS record? I guess this point could be clarified though.",
          "createdAt": "2019-08-15T22:18:23Z",
          "updatedAt": "2019-08-15T22:18:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is mostly an editorial change to make it easy to remove `ESNIRecord`, if needed, without changing any other text.",
          "createdAt": "2019-08-15T22:19:19Z",
          "updatedAt": "2019-08-15T22:19:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #187.",
          "createdAt": "2019-11-02T01:02:03Z",
          "updatedAt": "2019-11-02T01:02:03Z"
        }
      ]
    },
    {
      "number": 180,
      "id": "MDU6SXNzdWU0NzQxNzYyNzU=",
      "title": "Use SRV for fronting server selection",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/180",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think that the current ESNI record is maybe a little too\r\ncomplicated. The ESNI key is really a property of the public server, yet\r\nthe ESNI record is defined as a property of the hidden server. If the\r\npublic server rolls a new key, all the ESNI records of all the hidden\r\nservers that mentioned the old key need to be updated. I think it would\r\nbe simpler to have the ESNI record as a property of the public server,\r\nand to just have a pointer to the public server in the context of the\r\nhidden server. May an SRV record. The chain would be something like:\r\n\r\n1) Look up whether the SRV record for _esni._tcp.hidden.example.com\r\n\r\n2) If there are such records, select the appropriate public server, say\r\npublic.example.net\r\n\r\n3) Look up ESNI, A, AAAA for public.example.net\r\n\r\nIn that architecture, there is no need to encode the public server name\r\nin the ESNI record. I think there will be several advantages. The ESNI\r\nrecord's TTL can be set to the lifetime of the key. The SRV record's TTL\r\ncan be set to the expected lifetime of the relation between 'hidden\" and\r\n\"public\". If the SRV lifetime is long enough, the value can be\r\nefficiently cached by the client. If multiple clients share the same\r\nhidden server, the ESNI record is fetched only once, and can be cached.\r\nAt connection time, the client would only need to query the A/AAAA\r\nrecords of the public server, i.e. exactly the same DNS transaction as\r\nan access to the public server.",
      "createdAt": "2019-07-29T17:46:43Z",
      "updatedAt": "2019-11-02T01:02:00Z",
      "closedAt": "2019-11-02T01:02:00Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Issue #139 proposes something similar, using PTR records. I think the semantic of SRV records is closer to what we need.",
          "createdAt": "2019-07-29T17:49:49Z",
          "updatedAt": "2019-07-29T17:49:49Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The practical consequence would be to remove the \"public name\" component from the ESNI record.",
          "createdAt": "2019-07-29T17:51:15Z",
          "updatedAt": "2019-07-29T17:51:15Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "IIRC, the principle that we have so far followed is that ESNI should not introduce additional latency (i.e. roundtrip). TLS WG has spent great effort in reducing the number of roundtrips spent during the handshake. It would be very unfortunate to add latency with ESNI.\r\n\r\nAlso, I am not sure how much the issue is a practical concern, because I'd assume that most if not all of the DNS records of the hidden hostnames would be a CNAME to the public name. The ESNI record would be associated to that public name.\r\n\r\nTo rephrase, the ESNI record would be associated to the public name in the current scheme.",
          "createdAt": "2019-07-30T07:21:18Z",
          "updatedAt": "2019-07-30T07:21:18Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that if the typical implementation is to have the hidden server name point to the public server with a CNAME, then the current record format is just fine. We may want to document this hidden CNAME assumption in the document.\r\n\r\nOn the other hand, I am still not convinced that CNAME is the proper tool. We definitely want to use DNSSEC to sign the record pointing from hidden to public. Otherwise, it becomes very simple to inject a false record pointing to a compromised public server, and then track clients. At a minimum, if we expect the hidden servers to use CNAME, we should explain how to use DNSSEC to secure that.\r\n\r\nApart from DNSSEC, the other feature that we want is the support for multiple public servers, in case one of them is blocked. I don't think that CNAME can do that. In practice, the simplest way will be to have multiple ESNI records listed directly in the context of the hidden server. That works, and doing DNSSEC is straightforward. But it implies replication of the public server ESNI record in many places, which brings in the issues of managing replication.",
          "createdAt": "2019-07-30T16:20:25Z",
          "updatedAt": "2019-07-30T16:20:25Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema I think that elaborating on the expected practice is a good idea.\r\n\r\n> Apart from DNSSEC, the other feature that we want is the support for multiple public servers, in case one of them is blocked.\r\n\r\nWhile I appreciate the possibility, I am not sure if it is a good idea to endorse ESNI to be used as a tool to circumvent blocking. Because doing so would lead to ESNI being blocked. Rather, my preference goes to promoting ESNI as a tool for protecting privacy.",
          "createdAt": "2019-07-31T07:22:24Z",
          "updatedAt": "2019-07-31T07:22:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #187.",
          "createdAt": "2019-11-02T01:02:00Z",
          "updatedAt": "2019-11-02T01:02:00Z"
        }
      ]
    },
    {
      "number": 182,
      "id": "MDU6SXNzdWU0OTg0MzQ4OTM=",
      "title": "Consider disabling server tickets if tickets are not uniform across the ESNI anonymity set",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/182",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Tickets and ESNI interact in a weird way, i.e., they may leak size or contain the SNI, leading to potential issues. One might want to disable them if also offering ESNI as a service.",
      "createdAt": "2019-09-25T17:54:45Z",
      "updatedAt": "2020-04-27T22:01:08Z",
      "closedAt": "2020-04-27T22:01:08Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to confirm, by uniform do you just mean that they're indistinguishable visually or that the server will cross-resume across names in the anonymity set?",
          "createdAt": "2019-09-26T22:47:12Z",
          "updatedAt": "2019-09-26T22:47:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Both!",
          "createdAt": "2019-09-26T22:48:16Z",
          "updatedAt": "2019-09-26T22:48:16Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure we want the latter. For instance, if they have different client certificate requirements, the server could be in a pickle resuming across them allows you to bypass those requirements. It also generally muddles the identity that the server is authenticating as. In the split mode case, the different backends presumably don't even share ticket keys.\r\n\r\nIs the motivation is various attacks around seeing if the server accepts a ticket in various contexts? That would certainly solve this, but I wonder if we can address them by playing games with binders instead? Though it's a little fussy since binder failures are currently fatal, whereas failing to decrypt a ticket just falls back to full handshake...",
          "createdAt": "2019-09-26T22:55:31Z",
          "updatedAt": "2019-09-26T22:55:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> For instance, if they have different client certificate requirements, the server could be in a pickle resuming across them allows you to bypass those requirements.\r\n\r\nCorrect! The issue as written isn't crisp :-) What we require, among possibly other things that I didn't write down, is that the information and authentication context for a ticket is indistinguishable across all tickets possible for a given set of servers. So in the example you describe, if a client gets a ticket without authenticating from one server and then resumes it to a different server that normally would require authentication, then the ticket must record whether authentication took place. And storing that bit should not reveal information about the name.\r\n\r\n(I was just aiming to make a note of this so I didn't forget it later. There's probably other things to consider, too. I don't claim this is complete as written!)\r\n\r\n> Is the motivation is various attacks around seeing if the server accepts a ticket in various contexts? \r\n\r\nYep! This is a \"flip table\" solution to the problem that some server operators may wish to do. ",
          "createdAt": "2019-09-26T23:00:16Z",
          "updatedAt": "2019-09-26T23:00:16Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood Is this about privacy or about authentication? It seems that we have two issues:\r\n\r\n1) Observers perform some trials and find out that \"hidden1.example.com\" uses 33 bytes tickets while \"hidden2.example.com\" uses 42 bytes. They can then look at TLS resume attempts and tell which server is contacted. \r\n\r\n2) Attackers find out that some servers send a ticket after authentication and other before that, and then use clever repeat attacks to benefit from the confusion.\r\n\r\nI would argue that (1) is part of the wider issue of identifying servers without breaking the encryption. We may want to address it, but it seems very complicated.\r\n\r\nAs for (2), is this an ESNI issue or a TLS issue?",
          "createdAt": "2019-09-27T02:20:38Z",
          "updatedAt": "2019-09-27T02:20:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema it's about privacy. As you observe, (1) is clearly an issue for ESNI, but it's more an attack on tickets than it is on ESNI. It seems that if ESNI is to provide desired guarantees, then we ought to address it. (2) is a TLS issue and not related to ESNI. (Servers shouldn't be minting tickets without also including the authentication context. I'd rather not go down that rabbit hole here. :-))",
          "createdAt": "2019-09-27T02:37:41Z",
          "updatedAt": "2019-09-27T02:37:41Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(1) is a matter of degree. It is also possible to fingerprint servers by looking the sizes of pages, or the sizes of TLS blocks, or the profile of a typical session. There was a talk about that in one of the ANRW presentations.\r\n\r\nLet's assume that we want to standardize ticket sizes. Suppose that a fronting server says \"to hide behind me you should pad your tickets to exactly 64 bytes\". We are then going into two kinds of arguments. \r\n\r\nFirst, many sites owner will ask you \"how exactly do I do that with Apache2?\" So if you want uniformity, you need some deployment guidelines, and you want support in the main server distributions. Or the TLS stacks. Or the QUIC stacks. But then we are getting a bit beyond the scope of ESNI.\r\n\r\nSecond, there will be the occasional site that has the requirement for 67 bytes. Or 129. What do you do? Increase the size for everybody else? Suggest plausible sizes? Randomize?",
          "createdAt": "2019-09-27T05:54:53Z",
          "updatedAt": "2019-09-27T05:54:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It is also possible to fingerprint servers by looking the sizes of pages, or the sizes of TLS blocks, or the profile of a typical session. There was a talk about that in one of the ANRW presentations.\r\n\r\nIndeed! However, the attack in mind is arguably much simpler than fingerprinting, so I'm not sure we should lump them in the same bucket. \r\n\r\nOn the question of sizes, note that we already recommend padding to hide certificate sizes. Making a similar suggestion for tickets therefore seems reasonable to me. ",
          "createdAt": "2019-09-27T14:50:24Z",
          "updatedAt": "2019-09-27T14:50:24Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I now realize that the advice on certificate size seems a bit odd, as the size is not something that is exposed on the wire. To be accurate, I think what we care is the number of TLS records and their sizes transmitted during the handshake. Those are the things that are exposed on the wire.\r\n\r\nSimilarly, the contents of Client Hello and Server Hello are also exposed.\r\n\r\nConsidering that, it might be a good idea to recommend as a general rule to not expose _plaintext_ information that helps observers reduce the anonymity set, using the tickets and the size of the certificate as the examples.",
          "createdAt": "2019-09-28T12:51:14Z",
          "updatedAt": "2019-09-28T12:51:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Considering that, it might be a good idea to recommend as a general rule to not expose plaintext information that helps observers reduce the anonymity set, using the tickets and the size of the certificate as the examples.\r\n\r\nYes, that would certainly be an improvement! Would you mind preparing a PR to that effect? I can do it if you don't have the time.",
          "createdAt": "2019-09-28T14:36:21Z",
          "updatedAt": "2019-09-28T14:36:21Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I'd appreciate it if you could, as I'm not sure when I can do it.",
          "createdAt": "2019-09-30T07:48:59Z",
          "updatedAt": "2019-09-30T07:48:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as this is effectively included in #209!",
          "createdAt": "2020-04-27T22:01:08Z",
          "updatedAt": "2020-04-27T22:01:08Z"
        }
      ]
    },
    {
      "number": 183,
      "id": "MDU6SXNzdWU1MDA5Nzc1Njc=",
      "title": "Clarification on repeated extensions in ESNIRecord and ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/183",
      "state": "CLOSED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[RFC8446 section 4.2](https://tools.ietf.org/html/rfc8446#section-4.2) states:\r\n\r\n> There MUST NOT be more than one extension of the\r\n   same type in a given extension block.\r\n\r\nThe ESNI draft should probably explicitly restate this for both `ESNIRecord.dns_extensions` and `ESNIKeys.extensions`.  I'd be happy to make a PR if need be. Thanks!",
      "createdAt": "2019-10-01T15:34:05Z",
      "updatedAt": "2020-03-08T00:32:55Z",
      "closedAt": "2020-03-08T00:32:54Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@dmcardle if you could propose text that takes the new ESNIConfig and HTTPSSVC change into account, that'd be great!",
          "createdAt": "2019-11-04T20:51:08Z",
          "updatedAt": "2019-11-04T20:51:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #195.",
          "createdAt": "2020-03-08T00:32:54Z",
          "updatedAt": "2020-03-08T00:32:54Z"
        }
      ]
    },
    {
      "number": 188,
      "id": "MDU6SXNzdWU1MTI2NzUzMzQ=",
      "title": "\"HKDF-Extract(0, Z)\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/188",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "A second point in issue #155 wasn't addressed very clearly by #158. \r\n\r\n\"...HKDF-Extract(0, Z) should probably become HKDF-Extract(\"\", Z) or be explicit about the salt as is done in https://tools.ietf.org/html/rfc8446#section-7.1 (or https://tools.ietf.org/html/rfc5869#section-2.2).\"\r\n\r\nThe current draft does clarify this in the text below, but I initially missed that. The reader has to know that the first argument to HKDF-Extract is named \"salt\" to put it together.\r\n\r\nI did end up getting it right, figuring this was intended to mean a buffer of zeros. I think it would be clearer to say:\r\n\r\n```\r\nsalt = uint8[Hash.length]\r\nZx = HKDF-Extract(salt, Z)\r\n```",
      "createdAt": "2019-10-25T19:11:24Z",
      "updatedAt": "2019-11-19T09:26:34Z",
      "closedAt": "2019-11-19T09:26:34Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer a PR to clarify this point is most welcome!",
          "createdAt": "2019-11-05T02:25:58Z",
          "updatedAt": "2019-11-05T02:25:58Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "It would be ok to take this suggestion into consideration under the terms of the IETF's \"Note Well\" blue sheet terms, and incorporate it into a PR by the editors.",
          "createdAt": "2019-11-15T08:05:00Z",
          "updatedAt": "2019-11-15T08:05:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer I agree! Could you please provide that PR?",
          "createdAt": "2019-11-17T03:12:45Z",
          "updatedAt": "2019-11-17T03:12:45Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "Oh, I was asking you folks to do it. If there's a reason I need to do it, I'd be happy to.",
          "createdAt": "2019-11-17T21:05:14Z",
          "updatedAt": "2019-11-17T21:05:14Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this is necessary, so while I'm willing to look at a PR, I'm not going to make one at this time.",
          "createdAt": "2019-11-17T22:23:24Z",
          "updatedAt": "2019-11-17T22:23:24Z"
        }
      ]
    },
    {
      "number": 189,
      "id": "MDU6SXNzdWU1MTI3NzIzMTE=",
      "title": "AEAD-Encrypt definition",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/189",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "```\r\nThe ClientEncryptedSNI.encrypted_sni value is then computed using the\r\n   usual TLS 1.3 AEAD:\r\n\r\n    encrypted_sni = AEAD-Encrypt(key, iv, KeyShareClientHello, ClientESNIInner)\r\n```\r\n\r\nHowever, the TLS 1.3 definition is:\r\n\r\n```\r\nAEADEncrypted =\r\n          AEAD-Encrypt(write_key, nonce, additional_data, plaintext)\r\n```\r\n\r\nIn the ESNI text, it's not clear how `iv` maps to TLS 1.3's `per-record nonce` routine.",
      "createdAt": "2019-10-26T01:10:02Z",
      "updatedAt": "2019-11-04T21:41:29Z",
      "closedAt": "2019-11-04T21:41:29Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not following what the problem is here: AEAD-Encrypt is a function that takes four arguments, the second of which is a nonce. In TLS 1.3 record encryption, this nonce value is set as described in S 5.3. In ESNI, it is derived via HKDF in the fashion described in S 5.1.1..",
          "createdAt": "2019-10-26T01:33:48Z",
          "updatedAt": "2019-10-26T01:33:48Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "I don't doubt that there is a right answer. It wasn't clear to me whether I should mix in a sequence number to `iv` (maybe zero?).\r\n\r\nOtherwise, it made sense. Although it might be quite a bit clearer to define each argument in terms of the TLS 1.3 definition.\r\n\r\n```\r\n...\r\nnonce = iv\r\nadditional_data = KeyShareClientHello\r\n...\r\n\r\nAEADEncrypted =\r\n          AEAD-Encrypt(write_key, nonce, additional_data, plaintext)\r\n```",
          "createdAt": "2019-10-26T01:40:04Z",
          "updatedAt": "2019-10-26T01:43:35Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "In other words, the second argument to `AEAD-Encrypt` in TLS 1.3 is \"derived from the sequence number and the client_write_iv or server_write_iv\".\r\n\r\nAs I read, it wasn't clear to me whether I should do nothing to the existing `iv` value, or mix in zero or something. This might be really obvious in some implementations, but it wasn't in the one I'm working on.",
          "createdAt": "2019-10-26T01:51:22Z",
          "updatedAt": "2019-10-26T01:52:29Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "You don't do either. The function takes a nonce argument. In TLS 1.3, that argument is computed one way, and in ESNI it is computed another way. These are positional functions and the names in scope at the call site are irrelevant.\r\n\r\nI think your proposed change would confuse rather than illuminating.\r\n\r\nI agree with you that adding test vectors would be useful, and if you want to supply some -- though I suggest you wait until the next version -- in a PR, that would be great.",
          "createdAt": "2019-10-26T02:22:40Z",
          "updatedAt": "2019-10-26T02:22:40Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "OK, maybe my proposed solution is not the best, but I don't think the status quo is great. I get the point of \"These are positional functions and the names in scope at the call site are irrelevant\", but that's actually not quite true in TLS, afaik. The names tend to imply input/output treatment.\r\n\r\nFor example, things called \"*_iv\" are inputs to `nonce` in TLS 1.3. In some implementations, the input \"Initialization Vector (IV)\" [RFC4106] might be a different static type from the `nonce` in the TLS 1.3 definition. That's why I got confused.\r\n\r\nmaybe adjust `ClientESNIInner ` like so:\r\n\r\n```\r\nstruct {\r\n   uint8 inner_nonce[16];\r\n   PaddedServerNameList realSNI;\r\n} ClientESNIInner;\r\n```\r\n\r\nand then:\r\n\r\n`nonce = HKDF-Expand-Label(Zx, \"esni iv\", Hash(ESNIContents), iv_length)`",
          "createdAt": "2019-10-26T02:29:49Z",
          "updatedAt": "2019-10-26T02:42:28Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "> For example, things called \"*_iv\" are inputs to nonce in TLS 1.3. \r\n\r\nI don't see how this argues your point. Again, the names are irrelevant.\r\n\r\n> In some implementations, the input \"Initialization Vector (IV)\" [RFC4106] might be a different static type from the nonce in the TLS 1.3 definition.\r\n\r\nI don't really see how the implementation types are relevant here.\r\n\r\nIn any case, given the state of the draft and the reasonable likelihood this will change, I think this decision is well within editor discretion.",
          "createdAt": "2019-10-26T03:28:49Z",
          "updatedAt": "2019-10-26T03:28:49Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> > For example, things called \"*_iv\" are inputs to nonce in TLS 1.3.\r\n> \r\n> I don't see how this argues your point. Again, the names are irrelevant.\r\n\r\nThe TLS spec and the ESNI spec do not have a type system. They do have a serialization spec, and I am not arguing about that. I do think the names could be clearer without inventing a type system.\r\n \r\n> > In some implementations, the input \"Initialization Vector (IV)\" [RFC4106] might be a different static type from the nonce in the TLS 1.3 definition.\r\n> \r\n> I don't really see how the implementation types are relevant here.\r\n\r\nWell, I think this perspective leads to reverse engineering C/C++ implementations, rather than precisely specifying the inputs to functions like AEAD-Encrypt.\r\n",
          "createdAt": "2019-10-26T03:44:18Z",
          "updatedAt": "2019-10-26T03:44:18Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "Maybe it could say something like \"The ClientEncryptedSNI.encrypted_sni value is then computed using the usual TLS 1.3 AEAD, but note that the second argument, 'iv', is not combined with a sequence number:\"\r\n\r\nThe reason I found this confusing was that TLS 1.3 doesn't define the \"nonce\" argument symbolically, but the ESNI draft does define \"iv\" symbolically. That's fine, but I then had to plumb a new kind of value into the library to allow for this IV, and I wasn't sure if it was right.",
          "createdAt": "2019-10-26T18:49:19Z",
          "updatedAt": "2019-10-26T18:49:19Z"
        },
        {
          "author": "nharper",
          "authorAssociation": "NONE",
          "body": "I agree with @ekr that AEAD-Encrypt is a 4 positional argument function and it shouldn't matter what they're called in the ESNI spec compared to what they're called in RFC 8446. However, from re-reading RFC 8446, I don't see a good definition of the AEAD-Encrypt function. Perhaps it would be better to describe the encryption using the Authenticated Encryption interface described in [Section 2.1 of RFC 5116](https://tools.ietf.org/html/rfc5116#section-2.1)?",
          "createdAt": "2019-10-28T18:41:48Z",
          "updatedAt": "2019-10-28T18:41:48Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "\"AEAD-Encrypt is a 4 positional argument function and it shouldn't matter what they're called in the ESNI spec compared to what they're called in RFC 8446.\"\r\n\r\nThis is sort of true, but I noticed that the specs use the name of the second argument to imply its input treatment: IV vs nonce. In that light, I suppose my suggested text might sound redundant, but I think the current document is too concise.",
          "createdAt": "2019-10-28T19:13:50Z",
          "updatedAt": "2019-10-28T19:13:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #194.",
          "createdAt": "2019-11-04T21:41:28Z",
          "updatedAt": "2019-11-04T21:41:28Z"
        }
      ]
    },
    {
      "number": 190,
      "id": "MDU6SXNzdWU1MTYzMTQ1NDY=",
      "title": "AAD calculation could use more explanation",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/190",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft says\r\n\r\n\"The ClientEncryptedSNI.encrypted_sni value is then computed using the usual TLS 1.3 AEAD:\r\n\r\n    encrypted_sni = AEAD-Encrypt(key, iv, KeyShareClientHello, ClientESNIInner)\r\n\r\nWhere KeyShareClientHello is the \"extension_data\" field of the  \"key_share\" extension in a Client Hello (Section 4.2.8 of [RFC8446]))\"\r\n\r\nI found that NSS inserts an extra 8 bytes of zeros in front of KeyShareClientHello for its AAD:\r\nhttps://dxr.mozilla.org/mozilla-central/rev/0e1726e95801928249c4dc14fd23fe2cbbb13b3b/security/nss/lib/ssl/tls13esni.c#665\r\n\r\nI'm not sure if those zeros are implied by one of the references. I couldn't spot it after looking for 10 minutes or so, and that byte seems to be in code specifically intended for ESNI.",
      "createdAt": "2019-11-01T19:52:16Z",
      "updatedAt": "2019-11-01T23:01:34Z",
      "closedAt": "2019-11-01T22:12:42Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "You're misreading the code. This is an idiosyncracy of the internal NSS interface. The 0s here are what would be the TLS sequence number ordinarily and are not part of the AAD.",
          "createdAt": "2019-11-01T22:12:42Z",
          "updatedAt": "2019-11-01T22:12:42Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "It could be a misreading, but should this be closed? At the very least, some TLS implementations will prepend 8 bytes of zeros. Another instance of unclear input treatment in this text.",
          "createdAt": "2019-11-01T22:29:27Z",
          "updatedAt": "2019-11-01T22:29:27Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "NSS's code isn't part of the text, so the spec isn't responsible for people's misinterpretations of the NSS code (or any other code).",
          "createdAt": "2019-11-01T22:32:04Z",
          "updatedAt": "2019-11-01T22:32:04Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "Well, currently NSS's code is implied in the spec, because no one could get the ESNI record's checksum right by following any draft. One would have to combine -02 and -04 in the way NSS does.",
          "createdAt": "2019-11-01T22:37:40Z",
          "updatedAt": "2019-11-01T22:37:40Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I haven't verified that this is true, but even if it is, NSS Is not the reference implementation for the specification and failure to interoperate with NSS is not the test for correct implementations. We (NSS) are not attempting to track the current spec because issues are still in fluc, so it's entirely possible that our implementation is in some funny state, but that's still not a spec issue.",
          "createdAt": "2019-11-01T22:43:11Z",
          "updatedAt": "2019-11-01T22:43:11Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "It's true. record_digest is transmitted in the clear, and I noticed my implementation's value mismatched Firefox's.\r\n\r\nI think the issue is not so much that NSS has bugs (it happens), but that the spec is vague enough that I am having trouble telling whether NSS's behavior is following the spec.",
          "createdAt": "2019-11-01T23:00:19Z",
          "updatedAt": "2019-11-01T23:01:34Z"
        }
      ]
    },
    {
      "number": 191,
      "id": "MDU6SXNzdWU1MTYzNTA0NjA=",
      "title": "Why is the PaddedSNI padded with zeros?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/191",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Couldn't these extra bytes be any value?",
      "createdAt": "2019-11-01T21:14:03Z",
      "updatedAt": "2019-11-05T08:13:05Z",
      "closedAt": "2019-11-04T20:52:21Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, but zeroes are quite common. See, e.g., TLS 1.3 record-layer padding: https://tools.ietf.org/html/rfc8446#section-5.4.",
          "createdAt": "2019-11-04T20:52:21Z",
          "updatedAt": "2019-11-04T20:52:21Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "Would you mind reopening this issue? I think a MUST requirement with a rationale of \"everyone else does it\" seems wrong.\r\n\r\nI can think of some reasons to mandate zeros:\r\n\r\n- prevent ad-hoc extensions\r\n- prevent clients from intentionally weakening traffic\r\n\r\nstuff like that. I just think the draft should state the rationale.\r\n",
          "createdAt": "2019-11-04T22:54:43Z",
          "updatedAt": "2019-11-04T22:54:43Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I would prefer that we not add any rationale. This is a reasonable choice and if we add a rationale for everything that is reasonable the draft will get quite long.\r\n\r\nSecond, we are actively considering a number of PRs here, at least one of which does not even have these bytes, so effort spent justifying them is potentially wasted.",
          "createdAt": "2019-11-04T23:02:01Z",
          "updatedAt": "2019-11-04T23:02:01Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> I would prefer that we not add any rationale. This is a reasonable choice and if we add a rationale for everything that is reasonable the draft will get quite long.\r\n\r\nIt's a not a reasonable choice if there is no reason for it.\r\n\r\n> Second, we are actively considering a number of PRs here, at least one of which does not even have these bytes, so effort spent justifying them is potentially wasted.\r\n\r\nThat makes sense. What's the link?",
          "createdAt": "2019-11-04T23:14:10Z",
          "updatedAt": "2019-11-04T23:14:10Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\nIt's a not a reasonable choice if there is no reason for it.",
          "createdAt": "2019-11-05T02:23:17Z",
          "updatedAt": "2019-11-05T02:23:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer I don't think this needs rationale. Padding with zeros is more or less convention in TLS, and we've stuck with it. ",
          "createdAt": "2019-11-05T02:24:44Z",
          "updatedAt": "2019-11-05T02:24:44Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> It's a not a reasonable choice if there is no reason for it.\r\n\r\nJokes aside, what would the rationale be for this requirement?\r\n\r\n\"The SNI must be padded with zeros, because ________\".\r\n\r\nIt may be the case that other TLS specs have used zeros.",
          "createdAt": "2019-11-05T05:20:26Z",
          "updatedAt": "2019-11-05T05:20:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not the case that every design decision in the specification needs to have a rationale in the specification. That's not any kind of IETF requirement.\r\n\r\nIf you have some objection to this design choice, I suggest you raise it on the mailing list and see if others agree.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-11-05T05:32:43Z",
          "updatedAt": "2019-11-05T05:33:22Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "It's true that not every requirement needs a rationale. Some of them are obviously in service of the goals of the draft itself: for example, no one is claiming that the document should justify encryption. It's also reasonable to cite other documents as the way to do things: there's no need to provide a rationale for the use of AEAD, for instance.\r\n\r\nBut, the choice of server-controlled zeros for this padding is specific to this draft. It seems like this requirement would be better as a server-specified minimum length, where the field is variable length and filled with opaque data (zeros are acceptable).",
          "createdAt": "2019-11-05T05:42:52Z",
          "updatedAt": "2019-11-05T05:42:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We've been bitten by requirements for opaque data in the past.  See POODLE.",
          "createdAt": "2019-11-05T06:52:03Z",
          "updatedAt": "2019-11-05T06:52:03Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> We've been bitten by requirements for opaque data in the past. See POODLE.\r\n\r\nThis comment seems ambiguous enough to warrant reopening the issue.",
          "createdAt": "2019-11-05T08:13:04Z",
          "updatedAt": "2019-11-05T08:13:04Z"
        }
      ]
    },
    {
      "number": 192,
      "id": "MDU6SXNzdWU1MTY1MzAyMDY=",
      "title": "How to parse esni_retry_request generically?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/192",
      "state": "CLOSED",
      "author": "ocheron",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As of draft-ietf-tls-esni-04, when the server rejects ESNI with esni_retry_request, it includes one or more ESNIKeys for retry:\r\n```\r\n      struct {\r\n          ServerESNIResponseType response_type;\r\n          select (response_type) {\r\n              case esni_accept:        uint8 nonce[16];\r\n              case esni_retry_request: ESNIKeys retry_keys<1..2^16-1>;\r\n          }\r\n      } ServerEncryptedSNI;\r\n\r\n   retry_keys  One or more ESNIKeys structures containing the keys that\r\n      the client should use on subsequent connections to encrypt the\r\n      ClientESNIInner structure.\r\n```\r\n\r\nThe client behavior described in section 5.1.2 is to pick one of the ESNIKeys values from this vector:\r\n\r\n> If one of the values contains a version supported by the client,\r\n> it can regard the ESNI keys as securely replaced by the server.\r\n> It SHOULD retry the handshake with a new transport connection,\r\n> using that value to encrypt the SNI.\r\n\r\nEncoding of `retry_keys` contains the total size of the vector field but not the size of the individual ESNIKeys elements. This makes it difficult (impossible?) to parse a vector with unknown future versions, so this part is not really extensible.",
      "createdAt": "2019-11-02T08:27:46Z",
      "updatedAt": "2019-11-21T10:17:47Z",
      "closedAt": "2019-11-21T10:17:47Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the comment! https://github.com/tlswg/draft-ietf-tls-esni/pull/198 should resolve this. It's a little goofy-looking but ah well.",
          "createdAt": "2019-11-05T22:04:23Z",
          "updatedAt": "2019-11-05T22:04:23Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "Thank you for confirming the issue. Not the nicest but will be effective.\r\nIt's the only real blocking point I see when implementing draft -04.",
          "createdAt": "2019-11-09T08:33:36Z",
          "updatedAt": "2019-11-09T08:33:36Z"
        }
      ]
    },
    {
      "number": 193,
      "id": "MDU6SXNzdWU1MTY2OTg5MTk=",
      "title": "Reasoning for 260",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/193",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The initial commit for the padding in the spec gave the reason for the \"260\" figure (maximum domain + TLS struct overhead). There have been many comments mentioning slightly lower numbers (255, 253, etc). It's subtle enough that the spec should probably detail the reason.",
      "createdAt": "2019-11-02T19:39:45Z",
      "updatedAt": "2019-11-04T21:41:21Z",
      "closedAt": "2019-11-04T21:41:21Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #194.",
          "createdAt": "2019-11-04T21:41:21Z",
          "updatedAt": "2019-11-04T21:41:21Z"
        }
      ]
    },
    {
      "number": 202,
      "id": "MDU6SXNzdWU1MjMwMDI5NTM=",
      "title": "Removing ESNI RRType Considerations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/202",
      "state": "CLOSED",
      "author": "mrsylerpowers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Because this document now delegates the way the keys are advertised from the RRType ESNI to HTTPSSVC shouldn't the RRType Considerations be removed from this document. ",
      "createdAt": "2019-11-14T17:30:58Z",
      "updatedAt": "2019-11-14T20:35:25Z",
      "closedAt": "2019-11-14T20:35:25Z",
      "comments": []
    },
    {
      "number": 204,
      "id": "MDU6SXNzdWU1MjgzMjI0MTk=",
      "title": "Anonymity sets",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/204",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Even if #146 and #139 are closed without further edits, I think the draft should clarify the intended anonymity set for ESNIConfig and its associated record_digest. The draft does address this in section 7.5.2. \"Avoid widely-deployed shared secrets\", but I missed that. Additionally, the draft uses the term \"anonymity set\" only once, in section 6.1. \"Misconfiguration and Deployment Concerns\".\r\n\r\nThe explanation Ben Schwartz wrote on the list is very clear:\r\n\r\n\"The record_digest, like the ESNIConfig itself, is intended to be constant across all domains that form an anonymity set (i.e. O(1) ESNIConfigs per CDN).  Thus, the record_digest reveals no additional information to an onlooker who can observe the server IP.\"\r\n\r\nPerhaps a short section on anonymity sets would clarify this. I think some combination of section 7.5.2 and the last paragraph of the introduction would work.",
      "createdAt": "2019-11-25T20:35:36Z",
      "updatedAt": "2020-04-27T21:58:03Z",
      "closedAt": "2020-04-27T21:58:03Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer text to clarify this would be most welcome. Please provide a PR!",
          "createdAt": "2019-11-25T20:59:05Z",
          "updatedAt": "2019-11-25T20:59:05Z"
        },
        {
          "author": "ret394",
          "authorAssociation": "NONE",
          "body": "is the clarification still required? just curious.",
          "createdAt": "2020-04-09T04:35:42Z",
          "updatedAt": "2020-04-09T04:35:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Indeed, I'm not sure further clarification is needed. Given no action on this issue, I'm closing. Please propose a PR or text if you feel this still needs to be fixed!",
          "createdAt": "2020-04-27T21:58:03Z",
          "updatedAt": "2020-04-27T21:58:03Z"
        }
      ]
    },
    {
      "number": 205,
      "id": "MDU6SXNzdWU1Mjg5ODA1MTY=",
      "title": "Include \"receiver anonymity\" as motivation for empty record_digest values",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/205",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "And possibly also include a bit inside ESNIConfig that tells clients whether or not to populate record_digest. (See https://bford.info/pub/sec/purb.pdf for some relevant definitions.)",
      "createdAt": "2019-11-26T21:26:01Z",
      "updatedAt": "2020-05-03T14:05:15Z",
      "closedAt": "2020-05-03T14:05:15Z",
      "comments": []
    },
    {
      "number": 206,
      "id": "MDU6SXNzdWU1NTkzNjc1OTc=",
      "title": "Suggestion to support user@domain.name",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/206",
      "state": "CLOSED",
      "author": "vanrein",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I would like to suggest supporting not only the `server_name`, but also permit user names to be included.  This would provide excellent support for peer-to-peer applications for protocols that use `user@domain.name` identities and whose design can work peer-to-peer.\r\n\r\nThere are [TLS relays using SNI](https://github.com/dlundquist/sniproxy) that need no knowledge about the content of the TLS stream, so they are no men in the middle.  With user names added into ESNI, it would be possible to do similar things with registered users; [SIP](https://tools.ietf.org/html/rfc3261) springs to mind as an example, because phones/terminals `REGISTER` [to a domain's server](https://tools.ietf.org/html/rfc3261#section-10.3) that subsequently [relays](https://tools.ietf.org/html/rfc3261#page-12) `INVITE` and other messages between them but is effectively a MITM, which can modify traffic and tap [SDP](https://tools.ietf.org/html/rfc4566)-transmitted [keys](https://tools.ietf.org/html/rfc4566#section-5.12) and [communication end points](https://tools.ietf.org/html/rfc4566#section-4.1).\r\n\r\nThe general story is of course that end-to-end encryption is better than hop-by-hop encryption, as in current uses of TLS.  Peers representing users that register with an intermediate server sound like a good opportunity to be doing that.  All that is required is a way of deciding where to forward TLS traffic, without changing its contents.  ESNI comes really close to that goal (if it adds user names).",
      "createdAt": "2020-02-03T22:16:36Z",
      "updatedAt": "2020-04-27T21:56:35Z",
      "closedAt": "2020-04-27T21:56:35Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the draft now encrypts the entire CH, this issue is irrelevant. (In particular, if clients want to send user names, they can do so today, with or without ECHO.)",
          "createdAt": "2020-04-27T21:56:35Z",
          "updatedAt": "2020-04-27T21:56:35Z"
        }
      ]
    },
    {
      "number": 214,
      "id": "MDU6SXNzdWU1OTYwMzA5MTk=",
      "title": "Clarify 1.2 connection support (don't break connections, but also don't protect the certificate)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/214",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "If the backend server does not include any signal for ECHO negotiation, either as a ServerHello extension or part of ServerHello.random, then it's possible to tunnel CHs to TLS 1.2 servers. This can be a feature, so let's consider whether or not it's in scope. (Note that we may discover that lack of server-side handshake message padding may make traffic analysis trivial.)\r\n\r\ncc @grittygrease ",
      "createdAt": "2020-04-07T17:24:36Z",
      "updatedAt": "2020-05-21T21:40:57Z",
      "closedAt": "2020-05-21T21:40:57Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not sure that'd be worthwhile. Wouldn't the TLS server cert be sent in clear to the client? So the server-name will be visible anyway. I'm not sure if the remaining CH content is sufficient to justify the added complexity of having to handle a TLSv1.2 CH.",
          "createdAt": "2020-04-12T20:17:03Z",
          "updatedAt": "2020-04-12T20:17:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If we didn't encrypt the server flight, that's right! But we might consider designs wherein the client-facing server encrypts (or tunnels) the server flight, just as we've done for the client flight.",
          "createdAt": "2020-04-12T22:01:57Z",
          "updatedAt": "2020-04-12T22:01:57Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, so support for TLSv1.2 here implies a new middle->client encryption. My first reaction is that we're nearly inventing masque again, so maybe this is a feature to leave for that?",
          "createdAt": "2020-04-12T22:34:16Z",
          "updatedAt": "2020-04-12T22:34:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Ah, so support for TLSv1.2 here implies a new middle->client encryption. My first reaction is that we're nearly inventing masque again, so maybe this is a feature to leave for that?\r\n\r\nPossibly. There may be a middle ground. Considering the amount of TLS 1.2 servers in existence, I think this is worth some thought.",
          "createdAt": "2020-04-13T13:48:14Z",
          "updatedAt": "2020-04-13T13:48:14Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems clever, but on balance it seems like we are getting close to a \"tunnel everything\" design. We want people to move to 1.3 and so going out of our way to accommodate 1.2 seems backwards.",
          "createdAt": "2020-04-24T14:38:41Z",
          "updatedAt": "2020-04-24T14:38:41Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The main problem this solves is in the fronting case. Specifically, in the\ncase that an ECHO-aware fronting server is operated by a different entity\nthan the backend server and the fronting server does not know whether the\nbackend server supports TLS 1.3 or not. Enabling support for TLS 1.2\nenables this fronting server to be deployed in front of a wide set of\nservers.\n\nOn Fri, Apr 24, 2020 at 7:38 AM ekr <notifications@github.com> wrote:\n\n> This seems clever, but on balance it seems like we are getting close to a\n> \"tunnel everything\" design. We want people to move to 1.3 and so going out\n> of our way to accommodate 1.2 seems backwards.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/214#issuecomment-619050908>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABHDHZ4SMC6TFEUWSRDFLIDROGQAFANCNFSM4MDJN5UQ>\n> .\n>\n",
          "createdAt": "2020-04-24T23:02:26Z",
          "updatedAt": "2020-04-24T23:02:26Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "As others have pointed out, the cost of adding support for TLS 1.2 servers it that there needs to be a layer below the TLS record layer, so that the plaintext records sent by the backend server can be encrypted.\r\n\r\nI'd be a bit concerned about the required cost and complexity that that has, therefore my +1 goes to just supporting TLS 1.3.",
          "createdAt": "2020-04-27T06:14:18Z",
          "updatedAt": "2020-04-27T06:14:18Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Two concerns here:\r\n\r\n1. Security: Suppose an adversary can inject a TLS 1.2 ServerHello, without the echo_nonce, and a Certificate message.  Does the client react differently depending on whether the hidden name is in the SAN list (e.g. certificate mismatch fails faster than verification failure)?  If so, the adversary might be able to learn the hidden name.\r\n\r\n2. Management: Suppose a TLS 1.2 backend is not coordinating closely with forwarder, which seems to be the goal of this model.  When the backend upgrades to TLS 1.3, will connections start failing because it is not including the echo_nonce in the transcript?",
          "createdAt": "2020-04-27T21:14:24Z",
          "updatedAt": "2020-04-27T21:14:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The client reaction issue is interesting, though maybe we can get around that by requiring constant time verification? On some systems that might be very hard to enforce, as verification doesn't even happen in the same process. Hmm... penny for your thoughts, @ekr and @davidben?\r\n\r\nAs for the nonce issue -- it's already included in the ClientHello. The server doesn't include it an extension explicitly.",
          "createdAt": "2020-04-27T21:26:05Z",
          "updatedAt": "2020-04-27T21:26:55Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the clarification.  I still think there's a potential best-practices concern if this encourages deployments that transmit the decrypted ClientHello in cleartext between the forwarder and backend, but that's less obvious.",
          "createdAt": "2020-04-27T23:28:44Z",
          "updatedAt": "2020-04-27T23:28:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed! Clarifying text there would help. I'll see if I can craft something along those lines for this issue.",
          "createdAt": "2020-04-27T23:30:47Z",
          "updatedAt": "2020-04-27T23:30:47Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nFWIW, I still think making complexity-inducing changes\nto better support TLSv1.2 (even in this reduced manner)\nwould be a bad plan. In large part because it'd take ages to figure it\nout. If someone could demonstrate a reduction\nin complexity and increase in security I might change my\nmind. Absent that, I continue to think we're better off\nexclusively supporting TLSv1.3.\n\nCheers,\nS.\n",
          "createdAt": "2020-04-27T23:34:12Z",
          "updatedAt": "2020-04-27T23:34:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The issue of not being able to clearly tell whether ServerHello used the outer or inner ClientHello does seem somewhat fatal. Deferring figuring this out to certificate verification is especially a nuisance, and I shudder at the thought having a coherent notion of constant-time X.509 verification.",
          "createdAt": "2020-05-21T21:25:26Z",
          "updatedAt": "2020-05-21T21:25:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should continue to base this on the assumption that the server does TLS 1.3. Trying to analyze the question of how this integrates with TLS 1.2  -- especially given that we have concerns about the naive integration -- seems prohibitive.",
          "createdAt": "2020-05-21T21:27:31Z",
          "updatedAt": "2020-05-21T21:27:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "On reflection, I tend to agree. On platforms I'm familiar with, constant-time certificate verification would be intractable. I'm closing this issue with the recommendation that we stick to the document's intent: ESNI for TLS 1.3. ",
          "createdAt": "2020-05-21T21:40:57Z",
          "updatedAt": "2020-05-21T21:40:57Z"
        }
      ]
    },
    {
      "number": 215,
      "id": "MDU6SXNzdWU1OTYwMzMzNTQ=",
      "title": "Limit \"Don't stick out\" to explicit signals",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/215",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "There's no explicit signal indicating that ECHO was negotiated for a connection. Thus, clients must perform trial decryption with both possible handshake keys. If we intend to keep this, then we should crisply state that \"don't stick out\" is limited to explicit signals, i.e., implicit signals such as size-related information is probably out of scope. (It's certainly an open question what is the \"best\" padding scheme for handshake messages.)\r\n\r\ncc @grittygrease ",
      "createdAt": "2020-04-07T17:28:54Z",
      "updatedAt": "2020-05-05T20:10:04Z",
      "closedAt": "2020-05-05T20:10:04Z",
      "comments": []
    },
    {
      "number": 216,
      "id": "MDU6SXNzdWU1OTg1MDI5MDk=",
      "title": "Clarify ECHOConfig (HTTPSSVC) extension purpose",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/216",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "ECHOConfig.public_name provides information that goes in the outer CH. HTTPSSVC.alpn provides information to go in the inner CH (I assume). We don't specify a way for the server to  explicitly say what alpn to use in the outer CH.  I think it'd be worth re-considering where servers/admins might want to put that kind of information and how much of the inner/outer CH they may want to describe. There could be a range of potential outcomes if we re-visit this - at one extreme HTTPSSVC or ECHOConfig might provide a template for the entire CH (possibly via some template naming/numbering scheme), at the other extreme we might decide that ECHOConfig should only contain the keying information and just define alpn, public_alpn and public_name as optional fields for inclusion in HTTPSSVC. But it seems a bit broken for the only two parts of the CH the server specifies to be handled so differently,",
      "createdAt": "2020-04-12T14:54:22Z",
      "updatedAt": "2020-05-07T18:43:48Z",
      "closedAt": "2020-05-07T18:43:47Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> HTTPSSVC.alpn provides information to go in the inner CH (I assume).\r\n\r\nIt doesn't. It's important for downgrade protection that the DNS (not secured) *not* impact the client's ALPN preferences. The interaction between HTTPSSVC and ALPN is... rather a mess and the text around this still needs work.",
          "createdAt": "2020-04-13T14:54:07Z",
          "updatedAt": "2020-04-13T14:54:07Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 13/04/2020 15:54, David Benjamin wrote:\n>> HTTPSSVC.alpn provides information to go in the inner CH (I\n>> assume).\n> \n> It doesn't. It's important for downgrade protection that the DNS (not\n> secured) *not* impact the client's ALPN preferences. The interaction\n> between HTTPSSVC and ALPN is... rather a mess and the text around\n> this still needs work.\n\nAh. Fair enough. Though I guess ECHO will likely only be\nused via DoH or something equivalent which could change\nthings maybe.\n\nBut regardless... doesn't the point still stand that we'd\nbe better off with some consistency in how we manage the\nserver-name in the outer CH, the ALPNs in both inner and outer, and any\nother CH content where the server wants to\npublish some hints?\n\nI'm not particularly wedded to a specific approach (though\nI'd likely be more biased to simplifying the ECHOConfig).\n\n\n",
          "createdAt": "2020-04-13T15:00:58Z",
          "updatedAt": "2020-04-13T15:00:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Even DoH won't authenticate the origin, only the resolver. One hopes the resolver is reasonably trusted, but I'd still prefer not giving it new powers. (Today, only the origin server pick HTTP/1.1 vs HTTP/2. That's useful given HTTP/1.1's safety against truncation attacks is... complicated.)\r\n\r\nI guess I see the public name less as an instruction for what to put in the outer ClientHello but a delegation to another name to authenticate any ECHO key replacements or ECHO shutoffs. That then implies putting it in the outer ClientHello so the server can pick the right fallback certificate. I think I'd also rather keep that information in ECHOConfig so the TLS stack gets a single bundle of data. (Similar thinking as https://github.com/tlswg/draft-ietf-tls-esni/issues/219#issuecomment-612963381.) But maybe the overall change would make more sense? I don't fully understand the proposal.\r\n\r\nOf course, the same authentication mismatch applies to the public name as any ALPN signals. While this was ESNI rather than ECHO, the reasoning was that the DNS server learns the hostname anyway, and can always drop ESNI records. The latter still holds for ECHO. The former... I'm not sure. Over in browser land, I really only care about the hostname, but there are probably other scenarios.",
          "createdAt": "2020-04-13T16:04:40Z",
          "updatedAt": "2020-04-13T16:05:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Assuming we are trying to do GREASE, the important thing is that the outer ClientHello is the same for clients with real and fake ECHO.  This could be achieved by providing a template in the ECHOConfig for the outer ClientHello that matches a popular client's behavior, or by telling clients \"when constructing the outer ClientHello, pretend you're connecting to the public name without the HTTPSSVC info\".  For now, I would lean to the latter for simplicity.  We can always define an outer ClientHello template later as an ECHOConfig extension.\r\n\r\nIf we give up on GREASE, I would remove the outer ALPN entirely.",
          "createdAt": "2020-04-15T03:06:20Z",
          "updatedAt": "2020-04-15T03:06:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The latter sounds reasonable.\r\n\r\nA template would not fly because the outer ClientHello must still adhere to [protocol invariants](https://tools.ietf.org/html/rfc8446#section-9.3), so any parameters in there must ones the client would legitimately accept. (Unless they ignore the fallback case and retry all errors with a more accurate outer ClientHello.)",
          "createdAt": "2020-04-15T14:58:54Z",
          "updatedAt": "2020-04-15T14:58:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As per the call today, we'll use this issue to track guidance (that will be mirrored in the HTTPSSVC document) about how one populates extension information. In particular, information that pertains to the outer CH, which exists only for ECHO's sake, should be limited to ECHOConfig, whereas information that pertains to the inner CH should be put in the HTTPSSVC. We'll work with @bemasc to get this text in shape!",
          "createdAt": "2020-04-27T21:53:53Z",
          "updatedAt": "2020-04-27T21:54:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #226. Closing.",
          "createdAt": "2020-05-07T18:43:47Z",
          "updatedAt": "2020-05-07T18:43:47Z"
        }
      ]
    },
    {
      "number": 217,
      "id": "MDU6SXNzdWU1OTg1MjU2MTY=",
      "title": "ECHOConfigContents.extensions is not needed",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/217",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "draft-06 includes an extensions field in ECHOConfigContents but no extension types are defined. If or when something new is needed it could just as easily be introduced via a new ECHOConfig.version or a new HTTPSSVC tag. The mandatory-to-understand design wit a \"critical\" bit was also used in X.509 and has not clearly worked as planned there. I don't see why that would differ here. Expecting implementers to include all the code required for generic extension handling and introducing new failure modes via critical bits, all for no concrete reason... seems wrong. I suggest we just delete the extensions field entirely. If needed, one can be added back via a new version later. \r\n\r\nBearing in mind the target for this draft is an experimental RFC, and so there's a reasonable likelihood of changes when/if we try promote ECHO to a standards-track RFC, we also don't need to be quite as future proof as normal, so deleting this field for now is not that risky.",
      "createdAt": "2020-04-12T16:50:26Z",
      "updatedAt": "2020-04-27T21:55:36Z",
      "closedAt": "2020-04-27T21:55:36Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't agree with this proposed change.\r\n\r\n1.  Extensions for TLS have proved very useful.\r\n2. The analogy to X.509 seems false. Criticality has a different context here and IMO it works fine for (say) STUN.\r\n\r\nIntroducing a new version has all kinds of other annoyances.\r\n\r\nAs for the experimental bit, that seems like an oversight. I expected this to be PS and I'm not sure why the draft has a different tag. I expect I just screwed up when I wrote the first draft. I note the adoption call doesn't say one way or the other. As a practical matter, we expect this to have widespread deployment.\r\n \r\n",
          "createdAt": "2020-04-24T14:36:47Z",
          "updatedAt": "2020-04-24T14:36:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As per the call today, we're closing this due to (a) the potential need for an extension to deliver padding hints in the future and (b) the benefits extensibility brought TLS in the past. ",
          "createdAt": "2020-04-27T21:55:36Z",
          "updatedAt": "2020-04-27T21:55:36Z"
        }
      ]
    },
    {
      "number": 218,
      "id": "MDU6SXNzdWU1OTg1NTY3MDI=",
      "title": "Use HPKE codepoints for all HPKE-relevant operations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/218",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "NONE",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "HPKE has it's own cipher suite code points, as well as the KEM id. I don't see why we're using TLS codepoints (ECHOConfigContents.suites and ClientEncryptedCH.suite) and yet also use one HPKE code point (ECHOConfigContents.kem_id). But maybe I'm missing something?\r\n\r\nIf not, I think one of two things would make sense:\r\n\r\n1. Change HPKE to use TLS code points. (That could be done but'd involve a bit of nose-holding, however it might be better in the longer term.)\r\n2. Only use HPKE code points in ECHO - I don't see that TLS ciphersuites are actually needed for ECHO, so this seems easiest. (That'd mean s/suite/aead_id/g I guess.)\r\n",
      "createdAt": "2020-04-12T19:39:49Z",
      "updatedAt": "2020-05-02T01:36:23Z",
      "closedAt": "2020-05-02T01:36:23Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to agree with Stephen here. ISTM that probably (1) is better, actually.",
          "createdAt": "2020-04-24T14:39:36Z",
          "updatedAt": "2020-04-24T14:39:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we want HPKE to depend on TLS code points. Algorithms that come down the pipe may not be suitable for TLS. I'd prefer option (2).",
          "createdAt": "2020-04-24T15:06:48Z",
          "updatedAt": "2020-04-24T15:06:48Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "NONE",
          "body": "There's also a third option here:\r\n\r\n3. Use TLS code points (or something else) and define a mapping to HPKE code points\r\n\r\nLike @chris-wood, I am disinclined to tie HPKE to TLS, since it is a more general tool.\r\n\r\nIt seems like the answer here depends on what the negotiation in ECHO is being used for.  If it's just for the HPKE, use HPKE code points.  If it's used in TLS further down the line, use TLS code points and map to HPKE for the HPKE bits.",
          "createdAt": "2020-04-24T15:22:48Z",
          "updatedAt": "2020-04-24T15:22:48Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "How is (3) different than the current design?",
          "createdAt": "2020-04-26T20:51:52Z",
          "updatedAt": "2020-04-26T20:51:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Per the call today, we'll use this issue to track moving everything to HPKE codepoints. (We can remove the mapping table at the same time).",
          "createdAt": "2020-04-27T21:54:43Z",
          "updatedAt": "2020-04-27T21:54:43Z"
        }
      ]
    },
    {
      "number": 219,
      "id": "MDU6SXNzdWU1OTg1NjU3NTU=",
      "title": "cardinality of ECHOConfig vs. HTTPSSVC",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/219",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "A server can publish multuple HTTPSSVC RRs. Each of those RRs can contain multiple ECHOConfigContent values (i.e. multiple public keys and public_names). I don't see a real need for two different ways to publish more than one public key for a given server. There is a minor efficiency benefit in terms of the number of octets published in the DNS, but there is a lot of additional complexity in terms of code, and if nobody really publishes multiple public keys in one RR value, then that code is likely where we'll find CVEs. Reducing down to one public key per RR value also reduces the complexity when writing code to create/publish RRs.\r\n\r\nI think we have to support multiple RR values, because that's how the DNS works, and so the one to drop is the multiple public keys in one ECHOConfigs. IOW, I'd suggest one ECHOConfig has exactly one public key.\r\n ",
      "createdAt": "2020-04-12T20:32:56Z",
      "updatedAt": "2020-04-27T21:52:40Z",
      "closedAt": "2020-04-27T21:52:40Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A single ECHOConfig already has only one public key from https://github.com/tlswg/draft-ietf-tls-esni/pull/201 and the HPKE bits.\r\n\r\nI'm guessing you meant ECHOConfigs? There are multiple ECHOConfig values in a single ECHOConfigs, which came from https://github.com/tlswg/draft-ietf-tls-esni/pull/200. (Gosh, that was a terrible name. My bad. Maybe we should rename it?) I think the rationale there still holds? The problem is that an HTTPSSVC RR implies transport-level decisions, while not every ECHOConfig can be consumed by your TLS logic. Folding them together means transport connect needs to be aware of the exact ECHO capabilities. For instance, the origin could advertise:\r\n\r\n* route1.example.com echo=ECHOv1\r\n* route2.example.com echo=ECHOv2\r\n\r\nThe logic picking HTTPSSVC routes no longer gets a free choice. It must be aware of the TLS layer's capabilities (down to mandatory extensions and HPKE code points). ECHOConfigs means the expectation is:\r\n\r\n* route1.example.com echo={ECHOv1,ECHOv2}\r\n* route2.example.com echo={ECHOv2,ECHOv2}\r\n\r\nNow you pick a route freely and pass the entire opaque ECHO blob to TLS to interpret. Of course, one could still advertise:\r\n\r\n* route1.example.com echo={ECHOv1}\r\n* route2.example.com echo={ECHOv2}\r\n\r\nBut you're no longer forced to explode it out like that, so we can say an ECHOv1-only client that happens to pick route2 can act as if route1 didn't exist. I.e. we set an expectation that all your routes must be equally capable. (Just as we have that expectation elsewhere. If route1 only speaks TLS 1.0, you're not getting TLS's downgrade protection because the attacker can always redirect you to the less secure config.)",
          "createdAt": "2020-04-13T16:03:22Z",
          "updatedAt": "2020-04-13T16:03:22Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "\n\nOn 13/04/2020 17:03, David Benjamin wrote:\n> \n> But you're no longer forced to explode it out like that, so we can \n> say an ECHOv1-only client that happens to pick route2 can act as if \n> route1 didn't exist. I.e. we set an expectation that all your routes \n> must be equally capable. (Just as we have that expectation \n> elsewhere.\n\nGotta admit I'm not at all getting what you're saying,\nsorry. As-is, clients need to write the code to handle\nmultiple keys (and all other variations possible) at\nboth levels, or if not, then we're missing text in the\nspec saying what doesn't need to be supported.\n\nI don't see a real benefit in that complexity.\n",
          "createdAt": "2020-04-13T19:35:35Z",
          "updatedAt": "2020-04-13T19:35:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As per today's call, we're closing this due to the simplifications it brings for client implementations, in particular around collating all logic about ECHOConfig compatibility inside the TLS stack without the need for additional interfaces.",
          "createdAt": "2020-04-27T21:52:40Z",
          "updatedAt": "2020-04-27T21:52:40Z"
        }
      ]
    },
    {
      "number": 220,
      "id": "MDU6SXNzdWU1OTg1Njc0Nzc=",
      "title": "two type codes needed for interop",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/220",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We need to pick some values for the \"encrypted_client_hello(TBD)\" and for the HTTPSSVC RR type before we can do interop. Allocating some values from the private ranges for those before draft-07 is pushed out would be good so we can do some interop testing. (Or for whatever is the next draft for which we want to do interop.)",
      "createdAt": "2020-04-12T20:43:00Z",
      "updatedAt": "2020-05-27T21:48:52Z",
      "closedAt": "2020-05-27T21:48:52Z",
      "comments": []
    },
    {
      "number": 223,
      "id": "MDU6SXNzdWU2MDY0MDExNjE=",
      "title": "Restrict ECHO inner/outer variance for interop purposes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/223",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "First, I do think the security analysis for ECHO ought consider that the inner can be entirely different from the outer. That does not mean that we need to make full use of that flexibility when considering interop.\r\n\r\nIn the ECHO coding I've done so far, handling more restricted variation between inner and outer is a lot simpler, code-wise, and I would expect, will make interop easier and more successful. It seems (at least with OpenSSL) that once the cryptographic parameters (e.g. key shares) are allowed to vary between inner and outer, then things get significantly more complex. (That's not only down to\r\nthe trial decryption on the client btw, but is clearly demonstrated by the need for trial decryption.)\r\n\r\nI suggest we consider, for now, restricting how the inner and outer can vary, for example, only requiring implementations be able to handle minimal variation, perhaps only with server name and alpn and the nonce and ECHO that have to differ.\r\n\r\nIf, having coded this up, people figure it is actually  easy enough to support more flexibility then we could change to require support for that later. I think we should be able to decide before WGLC or IETF LC but don't believe we can currently be confident that full flexibility would be a good interop choice.\r\n ",
      "createdAt": "2020-04-24T15:32:49Z",
      "updatedAt": "2020-04-27T21:51:17Z",
      "closedAt": "2020-04-27T21:51:17Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "You need trial decryption on the client no matter what, because the transcript will be different, so that's not relevant here.\r\n\r\nI am not in favor of restricting how the inner and outer can vary. This is precisely the kind of thing that implementations might then get wrong by assuming and then we have problems.\r\n\r\nIt seems to me that your primary argument here is implementation difficulty, plus some speculation about interop. I don't anticipate any difficulty implementing this in NSS based on my experience with HRR, and it seems like we'll find out whether there are interop difficulties soon enough, so adding restrictions is premature.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-04-24T16:47:23Z",
          "updatedAt": "2020-04-24T16:47:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Per the call today, we're closing this for now. We may revisit this later on if more implementation experience from the WG leads folks towards a restrictions on inner/outer variance.",
          "createdAt": "2020-04-27T21:51:17Z",
          "updatedAt": "2020-04-27T21:51:17Z"
        }
      ]
    },
    {
      "number": 229,
      "id": "MDU6SXNzdWU2MTEyODgwNDU=",
      "title": "Describe HRR cut-and-paste 1 in Security Considerations.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/229",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "<img width=\"909\" alt=\"Screen Shot 2020-05-02 at 3 33 05 PM\" src=\"https://user-images.githubusercontent.com/2172048/80893782-3fae8980-8c8a-11ea-8bca-cb5fc1e33685.png\">\r\n",
      "createdAt": "2020-05-02T22:33:24Z",
      "updatedAt": "2020-05-21T13:08:20Z",
      "closedAt": "2020-05-21T13:08:19Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #234.",
          "createdAt": "2020-05-21T13:08:19Z",
          "updatedAt": "2020-05-21T13:08:19Z"
        }
      ]
    },
    {
      "number": 232,
      "id": "MDU6SXNzdWU2MTQzMjI5ODM=",
      "title": "Bikeshed: finalize on naming of \"ECHO\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/232",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "While cutsy, the name \"ECHO\" for \"Encrypted Client Hello\" seems like it could cause problems and significant confusion.  To those not actively involved in the working group, \"ECHO\" has very different connotations.  Some potential risks include:\r\n* Other IETF standards have some form of \"ECHO\" functionality.  When bouncing this question off someone else, they responded with \"TLS ECHO, like ICMP ECHO, except totally not\"\r\n* The immediate guess people may have on hearing about a TLS ECHO functionality would be to think \"oh, like to echo back a message for heartbeat purposes?\".  Given the potential risk for confusion with heartbeat (especially given \"Heartbleed\") this has some risk of giving TLS ECHO a bad rap from the start due to confusion.\r\n* This functionality is going to have high profile with product managers and perhaps even government regulators and public policy.  Applying a name that has confusing lay-connotations is going to muddle conversations.\r\n* This has a risk of confusion when used in other contexts.  For example, \"echoconfig\" as a SVCB parameter key has potential risk for confusing people reading the config and lacking context.\r\n* ECHO is going to be harder to do searches for, both in Internet and intranet search engines.\r\n\r\nJust calling it \"ECH\" or \"EHELLO\" may be safer?\r\n\r\n(If this changes, SVCB will also need to change the \"echoconfig\".)",
      "createdAt": "2020-05-07T20:27:33Z",
      "updatedAt": "2020-05-21T19:49:50Z",
      "closedAt": "2020-05-21T19:49:50Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "One reason for \"EHELLO\" is that if we support Split Mode with the ClientHelloInner being TLS 1.2 then it also provides protection for the ServerHello as well.",
          "createdAt": "2020-05-07T20:31:28Z",
          "updatedAt": "2020-05-07T20:31:28Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ETCH",
          "createdAt": "2020-05-07T21:46:15Z",
          "updatedAt": "2020-05-07T21:46:15Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "ETCH == \"Encrypted TLS Client Hello\"?    (That also sounds like a fine option.)",
          "createdAt": "2020-05-07T21:47:52Z",
          "updatedAt": "2020-05-07T21:47:52Z"
        }
      ]
    },
    {
      "number": 233,
      "id": "MDU6SXNzdWU2MTUzNDQ4NDk=",
      "title": "Trial decryption after HelloRetryRequest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/233",
      "state": "CLOSED",
      "author": "ocheron",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In a normal ECHO handshake with HelloRetryRequest there are 4 ClientHellos sent: ClientHelloOuter1, ClientHelloInner1, ClientHelloOuter2, ClientHelloInner2.\r\n\r\nEncryption of ClientHelloInner2 is bound to echo_hrr_key so the server must have the ECHOConfig used for ClientHelloInner1 in order to process ECHO the second time.\r\nAnd by the time the client receives encrypted handshake traffic it is not useful to signal if ClientHelloInner1 was successfully decrypted, what matters is to know if ECHO is globally successful or not.\r\n\r\nSo one aspect that I find not explained enough is whether the server replying with HRR should use ClientHelloInner1 in the transcript, or instead always takes ClientHelloOuter1 (data on the wire) regardless of the first decryption status. The ECHO status accept/reject can be conveyed based on distinction ClientHello2 inner/outer only.\r\n\r\nThis point impacts the number of transcripts the client may have to try, i.e. can be sure the combination (ClientHelloInner1, ClientHelloOuter2) is never valid.",
      "createdAt": "2020-05-10T08:39:16Z",
      "updatedAt": "2020-11-19T00:10:06Z",
      "closedAt": "2020-11-19T00:10:06Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @ocheron, the spec has changed quite a bit since this question was first posed. In particular, we've landed #287, which changes the server behavior so that it provides an explicit signal of ECH acceptance in its SH. Hence, no more trial decryption. I'm wondering if your question still applies?\r\n\r\nI believe what to do in case of HRR is well-specified at this point. There is no such ECH accdeptance signal provided in the HRR, so to determine if ECH was accepted, the client must wait until the SH. Until that point, the client needs to compute two transcripts in parallel: one assuming the ClientHelloOuter was used, and another assuming the ClientHelloInner was used.",
          "createdAt": "2020-09-23T18:39:53Z",
          "updatedAt": "2020-09-23T18:39:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think #287 resolves this. If the client has different HRR-relevant preferences (key share and cipher suite) between CHInner and CHOuter, I believe HRR is still a mess because the HRR message doesn't contain a signal for whether ECH was accepted. Though I suppose it is a little less complex now that you don't need to go as far as trial decrypting. Different HRR-relevant preferences means the HRR may be good for one ClientHello but not the other, yet the client needs to manage that state and defer the actual error-handling to when ECH acceptance is known. An option where the HRR message included an ECH acceptance signal would close this, but then we have sticking out woes.\r\n\r\nThe draft touches on this, but somewhat vaguely.\r\nhttps://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-6.3.3-1\r\n\r\nWe've been intending that our implementation would always match inner and outer preferences for HRR-sensitive fields, to avoid this case. But having this odd complexity cliff hidden in the spec is poor. I'd advocate we either require or at least strongly recommend clients do this.",
          "createdAt": "2020-09-23T19:02:49Z",
          "updatedAt": "2020-09-23T19:02:49Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#308 suggests to add the following text to the HRR section: \r\n\r\n> It is an error for the client to offer ECH before the HelloRetryRequest but not\r\nafter. Likewise, it is an error for the client to offer ECH after the\r\nHelloRetryRequest but not before. If the client-facing server accepts ECH for\r\nthe first ClientHello but not the second, or it accepts ECH for the second\r\nClientHello but not the first, then it MUST abort the handshake with an\r\n\"illegal_parameter\" alert.\r\n\r\nI think this solves the problem, at least partially. It ensures that the HRR path aligns with ECH acceptance/rejection.",
          "createdAt": "2020-09-23T19:41:55Z",
          "updatedAt": "2020-09-23T19:43:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That doesn't address the problem. This is about complexity for the client, not the server. Yes, the server needs to enforce consistency between the two modes, but it is easy for it to do this.\r\n\r\nImagine you're the client and your CHOuter has:\r\n* key_shares = {X25519}\r\n* supported_groups = {X25519, P-256, P-384}\r\n* cipher_suites = {TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384}\r\n\r\nAnd your CHInner has:\r\n* key_shares = {P-256}\r\n* supported_groups = {X25519, P-256, P-384}\r\n* cipher_suites = {TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256}\r\n\r\nNow consider how you have to respond to each of these HRRs. Remember that at the time you process the HRR, you *don't know if ECH was accepted*.\r\n1. cipher_suite = TLS_AES_256_GCM_SHA384; key_share = P-384\r\n2. cipher_suite = TLS_AES_128_CCM_SHA256; key_share = P-521\r\n3. cipher_suite = TLS_CHACHA20_POLY1305_SHA256; key_share = X25519\r\n4. cipher_suite = TLS_AES_128_GCM_SHA256; key_share = P-256\r\n5. cipher_suite = TLS_CHACHA20_POLY1305_SHA256; key_share = X25519\r\n\r\n1 is valid for both ClientHellos. This is the easy case and you can compute new CHInner and CHOuter values.\r\n2 is valid for neither ClientHello. If you can detect this, you can error immediately.\r\n3 is valid for neither ClientHello, but for messy reasons. The key share is valid for CHOuter but the cipher suite is not. The cipher suite is valid for CHInner but the key share is not. (Recall that a key share in HRR is allowed if it is in CH.supported_groups and *not* CH.key_shares. If it were in CH.key_shares, you shouldn't have sent HRR.)\r\n4 is valid for only CHOuter, so you can't error. It is not possible to compute a CHInner, so I guess you drop the extension? But you still need to make a note to raise an error later if you see SH which claims it did accept ECH.\r\n5 is valid for only CHInner, so you can't error. It is not possible to compute a CHOuter, but you have to, so I guess you send something garbage? But you still need to make a note to raise an error if you see SH which claims it rejected ECH.\r\n\r\nThis is a huge mess. The client can avoid this mess by always matching key_shares, supported_groups, and cipher_suites between CHInner and CHOuter. That means it can process HRR without knowing which CH to use. It is not obvious in the spec that you should do this, and the spec allows you to not do this.",
          "createdAt": "2020-09-23T20:17:14Z",
          "updatedAt": "2020-09-23T20:17:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see, I wasn't thinking about client complexity. Thanks for laying out the various edge cases. I would favor being stricter about how the key_shares, supported_groups, and cipher_suites are chosen. At the very least, we should guide implementations towards ensuring they are the same in the CHInner and CHOuter.\r\n\r\nAn alternative would be to add an ECH signal to HRR. We can't do the same trick we did with the SH.random, as this would stick out. But maybe there's another way? I thought of using HRR.session_id, but that could get messy.",
          "createdAt": "2020-09-23T21:09:05Z",
          "updatedAt": "2020-09-23T21:11:13Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "> I'm wondering if your question still applies?\r\n\r\nI think there is still ambiguity in the design about what CH is used by the client-facing server in its own transcript when forwarding CHInner to the backend server. Or else the combination (ECH accepted before HRR, ECH rejected after HRR) can be explicitly forbidden, but I don't see why/how.",
          "createdAt": "2020-09-29T17:31:06Z",
          "updatedAt": "2020-09-29T17:31:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Or else the combination (ECH accepted before HRR, ECH rejected after HRR) can be explicitly forbidden, but I don't see why/how.\r\n\r\nIncidentally, this is addressed by https://github.com/tlswg/draft-ietf-tls-esni/pull/311. This adds the following to client-facing server behavior: \r\n\r\n> It is an error for the client to offer ECH before the HelloRetryRequest but not\r\nafter. Likewise, it is an error for the client to offer ECH after the\r\nHelloRetryRequest but not before. If either of these conditions occurs, then the\r\nclient-facing server MUST abort the handshake with an \"illegal_parameter\" alert.\r\n\r\nIt's not hard for the client-facing server to enforce this. It just needs to remember if an HRR was triggered and whether ECH was offered in in the first CH.",
          "createdAt": "2020-09-29T17:38:44Z",
          "updatedAt": "2020-09-29T17:38:44Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "Ok that will do it.\r\nAssuming \"ECH not offered\" is same as \"ECH not accepted\", due to greasing.",
          "createdAt": "2020-10-01T04:40:29Z",
          "updatedAt": "2020-10-01T04:40:29Z"
        }
      ]
    },
    {
      "number": 237,
      "id": "MDU6SXNzdWU2MjI5MTg3NDM=",
      "title": "Remove 1.3 from the title",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/237",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The design can apply to TLS 1.4 and beyond (presumably).",
      "createdAt": "2020-05-22T03:12:25Z",
      "updatedAt": "2020-05-26T21:19:26Z",
      "closedAt": "2020-05-26T21:19:25Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Done in #238.",
          "createdAt": "2020-05-26T21:19:25Z",
          "updatedAt": "2020-05-26T21:19:25Z"
        }
      ]
    },
    {
      "number": 240,
      "id": "MDU6SXNzdWU2MjYwNTczMTU=",
      "title": "Consider strict ECH mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/240",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From a TODO in the draft:\r\n\r\nKey replacement is significantly less scary than saying that ECH-naive servers bounce ECH off. Is it worth defining a strict mode toggle in the ECH keys, for a deployment to indicate it is ready for that?\r\n\r\ncc @davidben ",
      "createdAt": "2020-05-27T21:51:02Z",
      "updatedAt": "2020-06-17T18:40:14Z",
      "closedAt": "2020-06-17T18:40:14Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I imagine clients that talk to general HTTPS servers like browsers wouldn't do this, but maybe more dedicated clients would? I work on a browser and don't know much about those kinds of use cases, so I figured I'd leave it as a TODO in case the WG felt strongly one way or another.",
          "createdAt": "2020-05-28T16:02:56Z",
          "updatedAt": "2020-05-28T16:02:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that no one asked for this, I'm inclined to close this without action. So... doing that now. :)",
          "createdAt": "2020-06-17T18:40:14Z",
          "updatedAt": "2020-06-17T18:40:14Z"
        }
      ]
    },
    {
      "number": 245,
      "id": "MDU6SXNzdWU2NDAzMTIxNjk=",
      "title": "Describe risks and mitigations for privacy leaks from configuration digest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/245",
      "state": "CLOSED",
      "author": "sharpie7",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The ID proposes an optional configuration digest parameter to be included in the clientHello. This parameter is advantageous because it improves the efficiency of the solution by avoiding the server having to do trial decryptions. However, in some scenarios the configuration digest could leak privacy information. In version 7 of the ID, section 10.2 on \u201cClient Tracking\u201d describes one scenario, but there are others. A more complete and general discussion of the risks and mitigations would be useful.\r\n\r\nIf a particular domain has a unique public key then the configuration digest becomes a fingerprint for that domain. An attacker that has a list of such domains that they want to monitor can build a dictionary of the corresponding digests use this to identify traffic to the domains on their list.\r\n\r\nSome mitigations could be:\r\n1)\tAvoid the use of configuration digest\r\n2)\tOnly deploy in a mode where many domains share the same public key to make finger-printing too general to be useful\r\n3)\tTo change keys faster than attackers can update their list of fingerprints\r\n",
      "createdAt": "2020-06-17T10:02:52Z",
      "updatedAt": "2020-06-18T02:50:27Z",
      "closedAt": "2020-06-18T02:50:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be addressed by #247. Please re-open (and suggest text edits!) if you think otherwise.",
          "createdAt": "2020-06-18T02:50:26Z",
          "updatedAt": "2020-06-18T02:50:26Z"
        }
      ]
    },
    {
      "number": 248,
      "id": "MDU6SXNzdWU2NDEzNzgyNTg=",
      "title": "Decryption failure guidance could be more detailed for trial decryption",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/248",
      "state": "CLOSED",
      "author": "raycoll",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\n\r\nIn section 8, there is a description of two approaches to match an ECHConfig with the ClientEncryptedCH:\r\n\r\n```\r\nThis matching procedure should be done using one of the following two checks:\r\n1. Compare ClientEncryptedCH.record_digest against cryptographic hashes of known ECHConfig and choose the one that matches.\r\n2. Use trial decryption of ClientEncryptedCH.encrypted_ch with known ECHConfig and choose the one that succeeds.\r\n```\r\n\r\nAnd later, we have guidance on what the server should do if decryption fails:\r\n\r\n```\r\nIf decryption fails, the server MUST abort the connection with a \"decrypt_error\" alert.\r\n```\r\n\r\nThis guidance makes sense to me for a server that is using record_digest matching to select an ECHConfig. If decryption fails using the matching record_digest, we must abort. However, I think it could be more clear for the trial decryption case, which is expected to have failed decryption attempt(s). \r\n\r\nI think something like this could be more clear:\r\n\r\n```\r\nIf record_digest matching is used and decryption fails using the matching ECHConfig, the server MUST abort the connection with a \"decrypt_error\" alert.\r\n```\r\n",
      "createdAt": "2020-06-18T16:42:35Z",
      "updatedAt": "2020-06-25T23:52:03Z",
      "closedAt": "2020-06-25T23:51:01Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is clarified above in that section. Namely, for trial decryption, we say that the record_digest does not \"match\" the ClientHello if there's no key which successfully decrypts the ClientHello. In this case, the server ignores the ECH extension and proceeds as specified. A \"match\" in the trial decryption case therefore implies that a key successfully decrypts the ClientHello, so the text referenced (\"If decryption fails...\") does not apply. ",
          "createdAt": "2020-06-25T23:45:20Z",
          "updatedAt": "2020-06-25T23:49:06Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I also feel like this is clear.",
          "createdAt": "2020-06-25T23:51:01Z",
          "updatedAt": "2020-06-25T23:51:01Z"
        },
        {
          "author": "raycoll",
          "authorAssociation": "NONE",
          "body": "On reread, that makes sense. Thanks!",
          "createdAt": "2020-06-25T23:52:03Z",
          "updatedAt": "2020-06-25T23:52:03Z"
        }
      ]
    },
    {
      "number": 251,
      "id": "MDU6SXNzdWU2NzAwMTgzMDY=",
      "title": "Common supported KEM",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/251",
      "state": "CLOSED",
      "author": "FredericJacobs",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "It might make sense to have a default KEM that all implementations would need to support for each ECH version.\r\n\r\nThis would prevent clients to have to support all KEMs at the risk of falling back to plaintext because they don't support the server-supported KEM.\r\n",
      "createdAt": "2020-07-31T17:01:52Z",
      "updatedAt": "2020-09-22T21:11:30Z",
      "closedAt": "2020-09-22T21:11:30Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "As Chris Patton says, we should also specify an AEAD and KDF. These should be AES-GCM and HMAC-SHA256.",
          "createdAt": "2020-09-21T15:53:18Z",
          "updatedAt": "2020-09-21T15:53:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "From the interim: HPKE(x25519, AES-128-GCM, SHA-256)",
          "createdAt": "2020-09-21T15:53:54Z",
          "updatedAt": "2020-09-21T15:53:54Z"
        }
      ]
    },
    {
      "number": 252,
      "id": "MDU6SXNzdWU2NzMxNjc5OTI=",
      "title": "Avoid padding cliff",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/252",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Section 7.2 says\r\n> 1. If L > D, add L - D bytes of padding. This rounds to the server's advertised hint, i.e., ECHConfig.maximum_name_length.\r\n> 2. Otherwise, add 32 - (D % 32) bytes of padding. This rounds D up to the nearest multiple of 32 bytes.\r\n\r\nThis has some problems:\r\n\r\n1. If L == D, or D > L and D % 32 == 0, this results in unnecessary padding.\r\n2. If L == D == 31, there is no length protection.  The output is 32, and that is the only length that produces that output.\r\n\r\nThe easiest solution is to replace \"32 - (D % 32)\" with \"(L - D) & 0x1f\".  This pads up to the nearest L + 32*n.\r\n\r\nIf it's considered important to pad to a multiple of 32, I would suggest ensuring that the initial bucket is at least 32, e.g. \r\n\r\n> 1. If L >= D, add L - D bytes of padding. This rounds to the server's advertised hint, i.e., ECHConfig.maximum_name_length.\r\n> 2. Otherwise, add 31 - ((D - 1) % 32) bytes of padding, plus an additional 32 bytes if L > 0 and D < L + 31 - ((L - 1) % 32)",
      "createdAt": "2020-08-05T00:34:55Z",
      "updatedAt": "2020-08-30T15:37:22Z",
      "closedAt": "2020-08-30T15:37:22Z",
      "comments": []
    },
    {
      "number": 253,
      "id": "MDU6SXNzdWU2NzMyMDYxMTQ=",
      "title": "Nonce rationale clarity",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/253",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "There are several rationales provided about the need for `ech_nonce`:\r\n\r\n1. This nonce ensures that the server's encrypted Certificate can only be read by the entity which sent this ClientHello.\r\n2. Since servers process either ClientHelloInner or ClientHelloOuter, and ClientHelloInner contains an HPKE-derived nonce, it is not possible for an attacker to \"cut and paste\" the ECH value in a different Client Hello and learn information from ClientHelloInner. This is because the attacker lacks access to the HPKE-derived nonce used to derive the handshake secrets.\r\n3. Client Reaction Attack Mitigation ... The \"ech_nonce\" extension in the inner ClientHello prevents this attack. In particular, since the attacker does not have access to this value, it cannot produce the right transcript and handshake keys needed for encrypting the Certificate message. Thus, the client will fail to decrypt the Certificate and abort the connection.\r\n\r\nThese rationales are all subtly different, and having read them all, I still don't understand why the nonce is necessary, when the server_handshake_traffic_secret already depends on the inner client random, which is not known to the attacker.\r\n\r\nI would appreciate some more explanation on this point.  It also might make sense to move these rationales up into the ech_nonce section, or add forward references to them there.",
      "createdAt": "2020-08-05T02:33:20Z",
      "updatedAt": "2020-09-22T21:10:51Z",
      "closedAt": "2020-09-22T21:10:50Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the rationale isn't clear from the description. This needs to be cleaned up. However, it does seem to prevent a real attack (see Sec. 10.8.1).",
          "createdAt": "2020-08-12T22:35:04Z",
          "updatedAt": "2020-08-12T22:35:04Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton As I noted above, the server_handshake_traffic_secret already depends on the inner client random, which is not known to the attacker.  It therefore seems to me that the attacker therefore cannot produce a Certificate message that the client will decrypt, even without the nonce.  If that's true, I don't see how the attack in Sec. 10.8.1 is possible.",
          "createdAt": "2020-08-13T00:35:54Z",
          "updatedAt": "2020-08-13T00:35:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What if the inner CH.random is the same as the outer CH.random? This is currently allowed by the spec, i.e., there's no guidance on \"copying\" extensions from the outer CH to the inner.",
          "createdAt": "2020-08-13T16:03:35Z",
          "updatedAt": "2020-08-13T16:03:35Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's an interesting question that I think the spec should probably address.  I assumed they could not be the same, because they are both required to be random.  If they _can_ be the same, I would suggest making them always the same, and remove the inner one to save 32 bytes and simplify the analysis.",
          "createdAt": "2020-08-13T16:48:42Z",
          "updatedAt": "2020-08-13T16:48:42Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The semantics of copying outer CH extensions into inner CH needs to be clarified: see also https://github.com/tlswg/draft-ietf-tls-esni/issues/262. To my read, the intent is that any extension MAY be copied, bit-by-bit, into the inner CH.",
          "createdAt": "2020-08-13T17:04:48Z",
          "updatedAt": "2020-08-13T17:04:48Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The client random is a fixed field of the ClientHello, not an extension.",
          "createdAt": "2020-08-13T17:33:52Z",
          "updatedAt": "2020-08-13T17:33:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> If they can be the same, I would suggest making them always the same, and remove the inner one to save 32 bytes and simplify the analysis.\r\n\r\nHmm, I'm not really a fan of this (and bit shaving in general). The idea is to make the inner CH as close to a full CH as possible, so keeping the same encoding makes most sense to me. \r\n\r\nThat said, even if they are random, there may be cases where the attacker can predict the randomness generated. ",
          "createdAt": "2020-08-13T18:05:45Z",
          "updatedAt": "2020-08-13T18:05:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think an attacker that can predict a random value generated by the TLS stack has much more exciting avenues of attack here. (E.g. the client's key share is lost.) Though it is a good point that they are slightly different: the ECH nonce is exported from the HPKE context while the client random is simply random. I forget if that ends up being important anywhere.",
          "createdAt": "2020-08-13T18:08:28Z",
          "updatedAt": "2020-08-13T18:08:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The client random is a fixed field of the ClientHello, not an extension.\r\n\r\nAh you're right. Thanks!",
          "createdAt": "2020-08-13T18:12:14Z",
          "updatedAt": "2020-08-13T18:12:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Exactly -- even if an attacker knew the client's key share, random value, etc, it *might* not know the ECH nonce (without access to the sever's private key), depending on the KEM used. (If DHKEM was used, it would know the client's ephemeral private key, so the point is moot.) \r\n\r\nAll that said, we *may* be able to remove it. But I'm hesitant to do so without backing analysis.",
          "createdAt": "2020-08-13T18:13:01Z",
          "updatedAt": "2020-08-13T18:13:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If DHKEM was used, it would know the client's ephemeral private key, so the point is moot.\r\n\r\nI think this is true for any KEM. If your KEM looks more like public key encryption, the attacker would instead know the shared secret the client generated. More generally, if we assume the client is incapable of generating random numbers, the attacker can simply run through the client's implementation of SetupBaseS, replacing all non-determinism with the predicted random number. It will then end up with the same HPKE context.",
          "createdAt": "2020-08-13T18:16:07Z",
          "updatedAt": "2020-08-13T18:16:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think this is true for any KEM. If your KEM looks more like public key encryption, the attacker would instead know the shared secret the client generated. More generally, if we assume the client is incapable of generating random numbers, the attacker can simply run through the client's implementation of SetupBaseS, replacing all non-determinism with the predicted random number. It will then end up with the same HPKE context.\r\n\r\nThat's true! ",
          "createdAt": "2020-08-13T18:18:48Z",
          "updatedAt": "2020-08-13T18:18:48Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RFC 8446 Appendix C.1 says \"Implementations can provide extra security against [broken RNG] attack by using separate CSPRNGs to generate public and private values.\".  If that's the motivation for the nonce, I think the spec should mention it.",
          "createdAt": "2020-08-13T19:12:31Z",
          "updatedAt": "2020-08-13T19:12:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "For what it's worth, the [formal model](https://github.com/chris-wood/reftls/blob/esni/pv/tls13_echo_noninterf_factored.pv) checks out after removing \"ech_nonce.\" ",
          "createdAt": "2020-08-21T16:18:50Z",
          "updatedAt": "2020-08-21T16:18:50Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is the current proposal for removing \"ech_nonce\" and clarifying behavior around choosing the ClientHelloInner.random: https://github.com/tlswg/draft-ietf-tls-esni/pull/292",
          "createdAt": "2020-09-03T17:29:36Z",
          "updatedAt": "2020-09-03T17:29:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing now that #292 landed.",
          "createdAt": "2020-09-22T21:10:50Z",
          "updatedAt": "2020-09-22T21:10:50Z"
        }
      ]
    },
    {
      "number": 260,
      "id": "MDU6SXNzdWU2NzgwMTAxMDY=",
      "title": "Need a high-level description of the security goal in the intro",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/260",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "In just a few sentences, let's define the anonymity set and say what it means for connections to end points in this set to be indistignuishable. We might also enumerate non-goals (though we still need consensus on what these are).\r\n",
      "createdAt": "2020-08-12T22:11:36Z",
      "updatedAt": "2020-09-22T21:25:43Z",
      "closedAt": "2020-09-22T21:25:43Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I've not yet gotten around to the PR yet, but here's the gist:\r\n\r\nAttackers:\r\n- Passive attackers are those which cannot probe, e.g., buggy middleboxes that filter based on plaintext packet contents.\r\n- Active attackers can probe, e.g., censors. \r\n\r\nGoals:\r\n- ECH does not negatively affect any existing security properties of TLS 1.3.\r\n- ECH connections to servers in the same anonymity set are indistinguishable from one another for passive and active attackers, modulo traffic analysis. (Note: an anonymity set is determined by the client and server parameters, e.g., the SNI, supported application protocols, and so on.)\r\n- ECH support is secret from passive attackers who don't know the ECH configuration, but not active attackers. \r\n- ECH usage is secret from passive attackers who don't know the ECH configuration, but not active attackers. More specifically:\r\n  - Passive attackers with a known ECH configuration can distinguish between a connection that negotiates ECH with that configuration and one which does not (GREASEd or using a different configuration).\r\n  - Passive attackers without the ECH configuration cannot distinguish between a connection that negotiates ECH and one which does not (but GREASEd).\r\n  - Active attackers can distinguish between a connection that negotiates ECH and one which does not (but GREASEd).\r\n\r\n",
          "createdAt": "2020-09-21T11:58:03Z",
          "updatedAt": "2020-09-21T15:17:07Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah this looks good.",
          "createdAt": "2020-09-21T15:12:58Z",
          "updatedAt": "2020-09-21T15:12:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "From the interim: merge this as a PR and then address censorship separately (if desired).",
          "createdAt": "2020-09-21T15:36:56Z",
          "updatedAt": "2020-09-21T15:36:56Z"
        }
      ]
    },
    {
      "number": 261,
      "id": "MDU6SXNzdWU2NzgwMTM2ODc=",
      "title": "Spec assumes HPKE uses HKDF",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/261",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From Section 6.1:\r\n\r\n```\r\n   When sending ClientHello, the client first computes ClientHelloInner,\r\n   including any PSK binders, and then MAY substitute extensions which\r\n   it knows will be duplicated in ClientHelloOuter.  To do so, the\r\n   client computes a hash H of the entire ClientHelloInner message with\r\n   the same hash as for the KDF used to encrypt ClienHelloInner.  Then,\r\n   the client removes and and replaces extensions from ClientHelloInner\r\n   with a single \"outer_extensions\" extension.  The list of\r\n   outer_extensions include those which were removed from\r\n   ClientHelloInner, in the order in which they were removed.  The hash\r\n   contains the full ClientHelloInner hash H computed above.\r\n```\r\n\r\nThis assumes that the KDF specifies some underlying hash function. From the HPKE spec, it seems like all that's required of the KDF is that it's an \"extract-then-expand\" KDF:\r\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hpke-05#section-4\r\n\r\nIn fact, the currently assigned code points are all for HKDF:\r\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hpke-05#section-7.2\r\n\r\nBut there's no requirement that the KDF always have some underlying hash function. As an alternative to HKDF, one can imagine a dedicated primitive that satisfies the extract-then-expand API but is not constructed from a hash function.",
      "createdAt": "2020-08-12T22:20:25Z",
      "updatedAt": "2020-08-26T12:46:54Z",
      "closedAt": "2020-08-26T12:46:54Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Impacted fields:\r\n- ClientEncryptedCH.record_digest\r\n- OuterExtensions.hash",
          "createdAt": "2020-08-13T16:54:51Z",
          "updatedAt": "2020-08-13T16:54:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We can probably replace `Hash` with `Extract` and be done with it. ",
          "createdAt": "2020-08-13T18:03:29Z",
          "updatedAt": "2020-08-13T18:03:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Putting on my theorist hat, I'd say that the extract function is a \"randomness extractor\" and not a collision resistant hash function. We want the latter in this context. From a practical stand point, using the extract function is more hashing than we need.\r\n\r\nI'd suggest doing away with `OuterExtensions.hash` (see #263) and figuring something else out for `ClientEncryptedCH.record_digest`. Could we simply require HKDF be used with HPKE?",
          "createdAt": "2020-08-13T18:09:59Z",
          "updatedAt": "2020-08-13T18:09:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, but in practice randomness extractors use a collision resistant hash or PRF (CBC) under the hood. \r\n\r\nI don't think we can require HKDF for HPKE. That seems too restrictive. We might just say that ECH requires HKDF-based HPKE ciphersuites, as HKDF is already paramount for TLS 1.3, and then just reference HKDF's hash function. ",
          "createdAt": "2020-08-13T18:17:41Z",
          "updatedAt": "2020-08-13T18:17:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#271 addresses this issue.",
          "createdAt": "2020-08-17T20:09:40Z",
          "updatedAt": "2020-08-17T20:09:40Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As I mentioned on the list, we can use the KDF in place of a hash.",
          "createdAt": "2020-08-17T23:06:09Z",
          "updatedAt": "2020-08-17T23:06:09Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I tend to agree. I'll create a new PR.",
          "createdAt": "2020-08-17T23:09:45Z",
          "updatedAt": "2020-08-17T23:09:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Have a look at #276, @martinthomson!",
          "createdAt": "2020-08-17T23:44:39Z",
          "updatedAt": "2020-08-17T23:44:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved in #276. Closing.",
          "createdAt": "2020-08-26T12:46:53Z",
          "updatedAt": "2020-08-26T12:46:53Z"
        }
      ]
    },
    {
      "number": 262,
      "id": "MDU6SXNzdWU2NzgwMTcwMTI=",
      "title": "\"outer_extensions\" mechanism is lossy compression",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/262",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs WG discussion",
        "ready-for-text"
      ],
      "body": "Say we want the outer CH to have extensions a and b. Let's write this as\r\n```\r\n  ClientHelloOuter = [a, b]\r\n```\r\nSay the inner CH should have extensions a, b, c, and d. But b is really big, so we want a shallow copy it. Then we write the compressed inner CH as\r\n```\r\n   ClientHelloInner = [a, c, d, outer_extensions = [ shallow_copy_of_b ]]\r\n```\r\nThe decompressed ClientHelloInner should be `[a, b, c, d]`, but using `outer_extensions` destroys the intended order.\r\n\r\n",
      "createdAt": "2020-08-12T22:28:26Z",
      "updatedAt": "2020-10-14T23:30:50Z",
      "closedAt": "2020-10-14T23:30:50Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Extension order in TLS isn't meaningful, so I think that's fine, provided the code producing the inner ClientHello and the code encoding it get to coordinate. (I.e. a client that says \"I don't care about secrecy of `key_share` and will send the same one on both sides\" can probably live with `key_share` being at the end.)\r\n\r\nThere have been cases where extension order has interop impacts due to server bugs. (E.g. the last extension needs to be non-empty to avoid a bug in some old servers.) But those old servers wouldn't see inner ClientHellos anyway.",
          "createdAt": "2020-08-13T17:53:30Z",
          "updatedAt": "2020-08-13T17:53:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think maybe a concern is that the client and server wind up using extension lists with different orders, for whatever reasons, thereby yielding different transcripts. Wouldn't that be an issue?",
          "createdAt": "2020-08-13T18:02:57Z",
          "updatedAt": "2020-08-13T18:02:57Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, hence \"provided the code producing the inner ClientHello and the code encoding it get to coordinate\". If compression is done with inner + outer ClientHello being produced by the same thing, the client can simply take this into account and always put referenced extensions at the end. If it's a proxying picture, where the client does not know it is doing ECH (is that even possible? I suspect the ech_nonce would be an issue), that may not work.",
          "createdAt": "2020-08-13T18:11:23Z",
          "updatedAt": "2020-08-13T18:11:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Right. I don't expect the latter (proxy case) to be common, though perhaps modifying this to prevent misuse might be useful.",
          "createdAt": "2020-08-13T18:14:25Z",
          "updatedAt": "2020-08-13T18:14:25Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This make me worry about interoperability. For a client and server to speak to eachother they need to adopt the same convention that is not specified anywhere, but only evident when you look at existing implementations. My vote would be to modify compression so that extension order is preserved.",
          "createdAt": "2020-08-13T18:16:03Z",
          "updatedAt": "2020-08-13T18:19:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is certainly necessary that the decompression function produces a deterministic ClientHello, down to what goes into the transcript. I think section 6.1 does that. That's a different criteria from requiring that every possible input ClientHello be efficiently compressible.",
          "createdAt": "2020-08-13T18:21:41Z",
          "updatedAt": "2020-08-13T18:21:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't compare about it being \"efficiently\" compressible, but I see your point about the transcript being the same. Just to clarify, my concern is in Section 6.1: \r\n\r\n> Then,\r\n   the client removes and and replaces extensions from ClientHelloInner\r\n   with a single \"outer_extensions\" extension.  The list of\r\n   outer_extensions include those which were removed from\r\n   ClientHelloInner, in the order in which they were removed.\r\n\r\nI interpret this as the following procedure:\r\n```python\r\n   outer_extensions = OuterExtensions()\r\n   for extension in client_hello_inner.extensions:\r\n      if extension in client_hello_outer.extensions and too_big(extension.get_payload()):\r\n          outer_extensions.append(extension.get_type())\r\n          client_hello_inner.remove(extension)\r\n   client_hello_inner.extensions.append(outer_extensions)\r\n```\r\nIs it clear what I mean here? Do we agree that, in general, this procedure doesn't preserve the order of extensions?\r\n\r\nMy concern had to do with servers being ossified around the order of extensions. If this isn't a problem, then I guess we're good here. It's worth flagging this, however (from RFC 8446): \r\n\r\n>    When multiple extensions of different types are present, the\r\n   extensions MAY appear in any order, with the exception of\r\n   \"pre_shared_key\" (Section 4.2.11) which MUST be the last extension in\r\n   the ClientHello (but can appear anywhere in the ServerHello\r\n   extensions block).\r\n\r\nAn order-preserving alternative would be something like this:\r\n```python\r\n   # compress\r\n   for extension in client_hello_inner.extensions:\r\n      if extension in client_hello_outer.extensions and too_big(extension.get_payload()):\r\n          extension.drop_payload() # Send extension with empty payload.\r\n   \r\n   # decompress\r\n   for inner in client_hello_inner.extensions:\r\n       if inner.get_payload() == None\r\n            for outer in client_hello_outer.extensions:\r\n                 if outer.get_type() == inner.get_type():\r\n                      inner.set_payload(outer.get_payload())\r\n```\r\nThis would have the added benefit of not needing to define an additional extension point.",
          "createdAt": "2020-08-13T19:39:31Z",
          "updatedAt": "2020-08-13T19:59:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The alternative doesn't quite work because extensions can legitimately be empty, so it's ambiguous whether you meant to explicitly encode an empty extension or reference the outer one. For example, the old TLS 1.2 `session_ticket` extension was empty to signal \"I support tickets but am not sending one\" and a non-empty string to send a ticket.\r\n\r\nThat's a good point though. The compression algorithm in 6.1 breaks if the removed extensions are non-contiguous, so it should either include that requirement, or we come up with a different goofy encoding. :-)",
          "createdAt": "2020-08-13T20:23:17Z",
          "updatedAt": "2020-08-13T20:23:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, good point. I would be fine with adding the requirement, though it might be worth trying to come up with something more general.",
          "createdAt": "2020-08-13T20:45:33Z",
          "updatedAt": "2020-08-13T20:45:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One possible replacement paragraph:\r\n\r\n> When sending ClientHello, the client MAY substitute extensions which it knows will be duplicated in ClientHelloOuter. To do so, the client arranges the duplicate extensions contiguously in the extension list when computing ClientHelloInner, including any PSK binders. The client then computes a hash of the entire ClientHelloInner message with the same hash as for the KDF used to encrypt ClientHelloInner. Finally, the client removes and replaces extensions from ClientHelloInner with a single \"outer_extensions\" extension. The list of outer_extensions include those which were removed from ClientHelloInner, in the order in which they were removed. The hash contains the full ClientHelloInner hash computed above.\r\n\r\n(I'm also fine with replacing with a more general encoding.)",
          "createdAt": "2020-08-13T21:01:47Z",
          "updatedAt": "2020-08-13T21:01:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should also require that the \"outer_extensions\" extension appears where the contiguous extensions were. For example,  to compress `b` and `c`, we encode `[a, b, c, d]` as `[a, outer_extensions = [b_shallow_copy, c_shallow_copy], d]`. Otherwise the \"outer_extensions\" MAY appear somewhere else.\r\n",
          "createdAt": "2020-08-13T21:09:49Z",
          "updatedAt": "2020-08-13T21:20:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In fact, that leads to a more general encoding.\r\n```python\r\n# encode (i.e., compress)\r\nencoded_client_hello_inner = ClientHelloInner()\r\nouter_extensions = OuterExtensions()\r\nfor inner in client_hello_inner.extensions:\r\n    if inner in client_hello_outer.extensions and too_big(inner): # processing contiguous compressed extensions\r\n        outer_extensions.append(inner.get_type())\r\n    else:\r\n        if not outer_extensions.empty(): # end of contiguous compressed extensions \r\n            encoded_client_hello_inner.append(outer_extensions)\r\n            outer_extensions = OuterExtensions()\r\n        encoded_client_hello_inner.append(inner)\r\nif not outer_extensions.empty():\r\n    encoded_client_hello_inner.append(outer_extensions) \r\n```\r\nI guess the problem with this is that we can have multiple \"outer_extension\" extensions in the inner CH, so we would still need to ensure there is just one contiguous block. Or we can say \"screw it\" and decide that **the encoded form of** ClientHelloInner need not be a well-formed ClientHello.",
          "createdAt": "2020-08-13T21:10:12Z",
          "updatedAt": "2020-08-13T22:00:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The proposed change is here: #293.\r\n\r\nAs @ekr suggested in the interim meeting, before changing this mechanism, we should look at real ClientHellos to see what we would actually want to compress.",
          "createdAt": "2020-09-03T18:07:38Z",
          "updatedAt": "2020-09-03T18:07:38Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My inclination is also that the contiguous constraint is probably fine, though we have played games with extension ordering before with the PSK extension. Although I would actually anticipate compressing most extensions, and just ordering things to match. Most of them aren't sensitive and, assuming you're already compressing one extension, even an empty extension would cost just four bytes uncompressed and two bytes compressed.",
          "createdAt": "2020-09-03T18:25:31Z",
          "updatedAt": "2020-09-03T18:25:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm pretty happy with the state of things. I'm closing this issue.",
          "createdAt": "2020-10-14T23:30:49Z",
          "updatedAt": "2020-10-14T23:30:49Z"
        }
      ]
    },
    {
      "number": 263,
      "id": "MDU6SXNzdWU2Nzg2Mjc5OTk=",
      "title": "\"outer_extensions\": What's the purpose of the hash?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/263",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs WG discussion",
        "question"
      ],
      "body": "Field `OuterExtensions.hash` is computed as \"digest of the complete ClientHelloInner\" (including presumably, the \"outer_extensions\" extension). I don't understand the analytical value of this hash. Can anyone explain its reasoning?",
      "createdAt": "2020-08-13T17:50:29Z",
      "updatedAt": "2020-09-23T18:53:32Z",
      "closedAt": "2020-09-23T18:53:32Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "The hash is intended to prevent the attacker from influencing the reconstructed CHInner by manipulating CHOuter. Consider the contrived example of an extension which is separately protected but only works for SNI-A and not SNI-B. E.g., it's constructed by doing E(K_sni, SNI). If that extension were included in CHOuter and then imported into CHInner via this mechanism, then an attacker could substitute it and use a reaction attack to determine whether the CH referred to A or B.\r\n\r\nHowever, with the hash (which may be not well-specified), this attack gets caught by the client-facing server and the handshake is rejected without leaking information.\r\n",
          "createdAt": "2020-09-03T14:28:56Z",
          "updatedAt": "2020-09-03T14:28:56Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My initial understanding of this mechanism was incorrect. What happens is that the hash is computed over the ClientHelloInner that is consumed by the backend server. This is intended to ensure that if ECH accepts, then the backend server consumes the CH intended by the client. (PR https://github.com/tlswg/draft-ietf-tls-esni/pull/293 makes this more clear, I think.)\r\n\r\nI wonder if this mechanism is redundant. Agreement on the CH between the client and backend server is provided by the binding of the transcript hash to the handshake traffic secret, so any attempt to manipulate the ClientHelloInner by fiddling with the ClientHelloOuter should be detected. On the other hand, the binding of the outer extensions to ClientHelloInner ensures agreement on the CH *prior to the backend server consuming it*. This is a strictly stronger property, which may or may not be useful.\r\n\r\n> Consider the contrived example of an extension which is separately protected but only works for SNI-A and not SNI-B.\r\n\r\nI agree that the attack works, but the example seems *really* contrived :) I'd be interested if there are more natural extensions for which this extra layer of security would be useful.",
          "createdAt": "2020-09-03T15:14:17Z",
          "updatedAt": "2020-09-03T15:14:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From the interim meeting, the consensus seems to be that we should err on the conservative side.",
          "createdAt": "2020-09-03T17:44:47Z",
          "updatedAt": "2020-09-03T17:44:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's close this issue and leave the mechanism as is.",
          "createdAt": "2020-09-03T18:05:39Z",
          "updatedAt": "2020-09-03T18:05:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hrm, before closing I think it might be worth noting, in the spec, the stronger security property this provides.",
          "createdAt": "2020-09-03T19:10:12Z",
          "updatedAt": "2020-09-03T19:10:12Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should also consider binding the CHInner to a hash of the whole CHOuter (minus the ClientEncryptedCH extension).  That would have the same size overhead, but would give us a stronger property: modifying anything in CHOuter (not just one of the copied extensions) invalidates the whole thing.",
          "createdAt": "2020-09-03T20:56:14Z",
          "updatedAt": "2020-09-03T20:56:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The point of hashing outer extensions is to provide integrity of the ClientHelloInner. What would be the point in hashing more of the ClientHelloOuter? (Not a rhetorical question :) It seems conceptually different, and I'm curious what the security benefit might be.)",
          "createdAt": "2020-09-03T21:01:05Z",
          "updatedAt": "2020-09-03T21:01:05Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we authenticate the ClientHelloOuter, we'd be authenticating all the inputs that go into the ClientHelloInner, so I think that would also provide integrity. I expect Ben is suggesting this in the context of https://github.com/tlswg/draft-ietf-tls-esni/pull/287#issuecomment-686746358, where GREASE can additionally be made a little stronger if we did that. Getting that to interact well with any PSK binders in ClientHelloOuter is tricky though, unless we decide to ban resumption attempts in outer ClientHellos.\r\n\r\n(Probably best to keep the GREASE-related conversation in one place. Though I see I didn't help on that front because some discussion is also in #274. Ah, GitHub.)",
          "createdAt": "2020-09-03T21:10:57Z",
          "updatedAt": "2020-09-03T21:10:57Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, I'm just echoing @davidben's observation. See also https://github.com/tlswg/draft-ietf-tls-esni/issues/274#issuecomment-686768299.",
          "createdAt": "2020-09-03T21:17:37Z",
          "updatedAt": "2020-09-03T21:17:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If we authenticate the ClientHelloOuter, we'd be authenticating all the inputs that go into the ClientHelloInner, so I think that would also provide integrity.\r\n\r\nToday, the only thing that gets copied into ClientHelloInner is extensions, so I don't see how it's an improvement in terms of our primary security goal. (Not sure about the \"don't stick out\" benefit.)",
          "createdAt": "2020-09-03T23:01:01Z",
          "updatedAt": "2020-09-03T23:01:01Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't understand how hashing all of CHOuter is going to work. In split\nmode, the server never sees any of CHOuter.\n\nOn Thu, Sep 3, 2020 at 4:01 PM Christopher Patton <notifications@github.com>\nwrote:\n\n> If we authenticate the ClientHelloOuter, we'd be authenticating all the\n> inputs that go into the ClientHelloInner, so I think that would also\n> provide integrity.\n>\n> Today, the only thing that gets copied into ClientHelloInner is\n> extensions, so I don't see how it's an improvement in terms of our primary\n> security goal. (Not sure about the \"don't stick out\" benefit.)\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/263#issuecomment-686806030>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIPUBDXMNJRDMQ3CZZTSEAN33ANCNFSM4P6WBVHQ>\n> .\n>\n",
          "createdAt": "2020-09-04T15:07:14Z",
          "updatedAt": "2020-09-04T15:07:14Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, the hash would be checked when reconstructing the inner ClientHello (as here), and would not be present in the reconstructed ClientHello.",
          "createdAt": "2020-09-04T15:43:15Z",
          "updatedAt": "2020-09-04T15:43:15Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There's not much discussion here. Unless there's objection, shall we leave the mechanism as-is and close out this issue? cc/ @chris-wood ",
          "createdAt": "2020-09-23T18:41:39Z",
          "updatedAt": "2020-09-23T18:41:39Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Works for me.",
          "createdAt": "2020-09-23T18:46:44Z",
          "updatedAt": "2020-09-23T18:46:44Z"
        }
      ]
    },
    {
      "number": 264,
      "id": "MDU6SXNzdWU2Nzg2MzUxMzg=",
      "title": "Handshake-level vs record-level padding",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/264",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "ECH currently uses two different kinds of padding. The encrypted ClientHello is padded with the padding extension, while the server response is padded with TLS 1.3 record layer padding.\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-07#section-7.1\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-07#section-7.2\r\n\r\nUsing record-level padding in TLS over TCP is relatively straightforward as it\u2019s ordered. However DTLS and QUIC have their own record layers, with retransmission logic. Properly hiding some length then requires that packet loss and retransmission logic track and retransmit padding as if it were integrated into the byte stream.\r\n\r\nIn the case of QUIC, when a QUIC packet is determined to be lost, it is not retransmitted whole; instead information carried in the frames in lost packets might be sent again in new frames (draft-ietf-quic-transport, section 13.3). That same section states that PADDING frames do not need to be retransmitted. If ECH in QUIC relies on QUIC transport layer padding, that would need to be changed, and implementations would need to track how much adding is associated with CRYPTO frame data for retransmission.\r\n\r\nQUIC additionally needs the padding size communicated across API boundaries between the TLS and QUIC implementations. It\u2019s likely that everyone\u2019s first pass at the API will omit this, only to need to add an extra parameter (API change) later when they implement ECH.\r\n\r\nThis seems a somewhat general issue between padding at reliably- and unreliably-transmitted layers of the stack. HTTP/3 has something analogous (though carried in slightly frames). That draft actually discusses two options for padding and calls out the relation to packet loss:\r\n\r\n> Where HTTP/2 employs PADDING frames and Padding fields in other frames to make a connection more resistant to traffic analysis, HTTP/3 can either rely on transport-layer padding or employ the reserved frame and stream types discussed in Section 7.2.8 and Section 6.2.3. These methods of padding produce different results in terms of the granularity of padding, how padding is arranged in relation to the information that is being protected, whether padding is applied in the case of packet loss, and how an implementation might control padding. Redundant padding could even be counterproductive.\r\n\r\nhttps://quicwg.org/base-drafts/draft-ietf-quic-http.html#name-padding-and-traffic-analysi\r\n\r\nShould we match that precedent and move the padding into the handshake itself? That would make it apply to DTLS and QUIC transparently. If we do, a couple possibilities to start with:\r\n\r\n* Say that ECH implementations must tolerate unsolicited padding extensions and inject those into various messages. This is a goofy around messages without extensions (CertificateVerify), or messages with multiple extension blocks (Certificate), but as long as there is an extension block _somewhere_ in each padded flight, it's probably possible to fudge it.\r\n* Say that ECH adds a new kind of Padding handshake message, which the sender can incorporate into the handshake as needed, and the receiver ignores.\r\n\r\nIf we leave ECH as-is, it seems to me QUIC (both spec and implementations) needs some changes to track padding across retransmission.",
      "createdAt": "2020-08-13T18:03:12Z",
      "updatedAt": "2020-11-19T12:09:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(2) seems simplest and most useful to me. The receiver path is trivial, and avoiding per-message semantics for adding padding (or not, if the extension isn't supported) seems easier. (This would also let clients move inner CH padding from an extension to a message, which might simplify padding calculations in the case where binders are used? That is, it can pad a fully-formed CH, rather than only part of a CH.)",
          "createdAt": "2020-08-13T18:25:20Z",
          "updatedAt": "2020-08-13T18:25:20Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The alternative is to tell the QUIC stack to pad, in the same way that TLS is told to pad.  This is more complicated in QUIC, because you have to respect packet boundaries and ensure that you include ack-eliciting frames in packets that might other contain only padding, but it is doable.\r\n\r\nThis is not by any means perfect, but it matches the signals in TLS.  The handshake tells the record layer: \"pad to X\".",
          "createdAt": "2020-08-14T01:23:01Z",
          "updatedAt": "2020-08-14T01:23:01Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My +1 goes to padding at the handshake message level.\r\n\r\nPadding at the record layer (or QUIC packet layer) is going to require more work and have more security concerns, as the transport needs to pad retransmissions.\r\n\r\nAs an example, when a handshake message that requires padding is split into multiple packets, and one of the packets gets lost, the transport has to figure out what to send and how to pad. In case of QUIC, we also have to make sure that PING frame would be used when the only thing that has to be retransmitted is padding, because not sending an ack-eliciting packet would reveal to a passive observer that it was padding only.",
          "createdAt": "2020-08-14T01:29:05Z",
          "updatedAt": "2020-08-14T01:29:05Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An alternative to a Padding message is to use the existing padding extension (in Certificate or EncryptedExtensions or both) to ensure that the overall message is the right size.  That accomplishes the goal, but it does require that the client be willing to send it, or we create a new exception to the rules for extensions.  You could, I guess, add the padding to the ECH extension.\r\n\r\nNew messages cost more (than I'd like).",
          "createdAt": "2020-08-14T04:48:12Z",
          "updatedAt": "2020-08-14T04:48:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just realized a nuisance with the extensions option: certificate extensions are incompatible with draft-ietf-tls-certificate-compression, which is [important for QUIC](https://www.fastly.com/blog/quic-handshake-tls-compression-certificates-extension-study). The extension compresses the entire Certificate message, so any padding messages inside the payload would get compressed away.\r\n\r\nWe could still fudge this by computing how much padding would be needed ahead of time and then adjusting the padding in EncryptedExtensions (same flight and all), but this is getting pretty silly. :-)\r\n\r\nAn aside since this comes up alot: ECH and certificate compression are perfectly compatible. Rather than padding up to `max(len(cert) for cert in anonymity_set)`, you pad the compressed cert up to `max(len(compress(cert)) for cert in anonymity_set)`. The key observation is that, assuming compression support is uniform across the anonymity set, *whether* you compressed is not sensitive, only *what* you compressed.\r\n\r\n> New messages cost more (than I'd like).\r\n\r\nHuh, I'd actually seen the extension as more annoying, since we'd need to add quirks to the unsolicited extensions rule. Is the issue for you all the state machine integration or something else? (I was envisioning we'd just have the handshake message logic silently drop all the padding messages on the ground so the handshake state machine doesn't notice.)",
          "createdAt": "2020-08-14T16:03:01Z",
          "updatedAt": "2020-08-14T16:03:01Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I would really like the QUIC padding to be independent of any TLS padding. The TLS RFC tries to keep the handshake and record layers separate -- heck, it even calls them protocols :). We're just starting to think about the next version of NTP-Security, and using *just* the handshake would likely be helpful there.\r\n\r\nNo matter what happens, I think draft-ietf-quic-tls will need an update to cover this issue.",
          "createdAt": "2020-08-21T13:55:54Z",
          "updatedAt": "2020-08-21T13:55:54Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "As an implementation detail: right now Akamai uses a port of the boringSSL QUIC patches. They are pretty cleanly layered on top of OpenSSL and getting entangled deeper into other parts of the OpenSSL code will be an issue. @sftcd is working on an ECH implementation and we would like to keep that clean separation as well.\r\n\r\nNeither of these efforts will be part of OpenSSL 3.0, which many people will want because it will be FIPS validated. They will also want QUIC and ECH, which means they will have to be added in as separate patches. Mixing up the layers, then, will make that harder and slow down adoption. I'm writing this as a separate comment to separate the protocol from the deployment issues. :)",
          "createdAt": "2020-08-21T14:02:31Z",
          "updatedAt": "2020-08-21T14:02:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From the interim meeting, it seems folks are not enthusiastic about doing padding in the record layer. We still need a proposal for doing padding in the handshake.",
          "createdAt": "2020-09-03T17:38:18Z",
          "updatedAt": "2020-09-03T17:38:18Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "As I was saying on the call, what I propose is:\r\n\r\n1. The client pads with the RFC 7685 padding extension in CHInner\r\n2. The server pads in EE with RFC 7685 padding\r\n\r\nWe would then relax the restriction on servers sending padding in 7685 Section 3 but not the restriction on unsolicited extensions.\r\n\r\nThere is a minor inconvenience here in that you would be required to compute the amount of padding needed before sending EE (because it appears prior to Certificate).\r\n",
          "createdAt": "2020-09-03T17:45:23Z",
          "updatedAt": "2020-09-03T17:45:23Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Oof, I got confused by time zones and thought the call was much later in the day.)\r\n\r\nPrecomputing the padding in EE would probably work, if a bit obnoxious to implement on the sender's side. It also doesn't allow padding the client certificate, if the client wishes to hide some information on that end.",
          "createdAt": "2020-09-03T18:17:22Z",
          "updatedAt": "2020-09-03T18:17:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It also doesn't allow padding the client certificate, if the client wishes to hide some information on that end.\r\n\r\nYeah, I'd like there to be a mechanism for supporting this on the client side. Something that only works for one end doesn't seem like the best solution here.",
          "createdAt": "2020-09-03T20:53:51Z",
          "updatedAt": "2020-09-03T20:53:51Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed that it doesn't allow padding the client cert, however, this issue already exists in TLS 1.3 w/o ECH. My proposal for that would be the dual of this: include the padding extension in CR and then pad in CERT.",
          "createdAt": "2020-09-04T15:05:19Z",
          "updatedAt": "2020-09-04T15:05:19Z"
        },
        {
          "author": "kaduk",
          "authorAssociation": "NONE",
          "body": "> Agreed that it doesn't allow padding the client cert, however, this issue already exists in TLS 1.3 w/o ECH. My proposal for that would be the dual of this: include the padding extension in CR and then pad in CERT.\r\n\r\nJust to check my understanding: this is predicated on fixing the interaction of CERT and compression w.r.t. preserving padding, right?",
          "createdAt": "2020-09-15T16:48:37Z",
          "updatedAt": "2020-09-15T16:48:37Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(@vasilvv FYI.) Certificate compression already got a code point allocated June 2018 and went through WGLC April 2019. That code point's shipped for some time now. So if we're to change anything there, we'd at minimum need to burn the old code point and get a new one.\r\n\r\n(I'm not opposed to doing that if it's the right path forward. Just wanted to make sure folks were aware of the complication.)\r\n\r\nWhat fix are folks envisioning?",
          "createdAt": "2020-09-15T19:25:55Z",
          "updatedAt": "2020-09-15T19:25:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "From the interim: stick with EE for padding, and address the client-side padding issue separately (as a change to ALPS or a new handshake message type).",
          "createdAt": "2020-09-21T15:42:48Z",
          "updatedAt": "2020-09-21T15:42:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi issue, I'm working on a PR for server-side padding (using EE) now. Will post a link once it's ready.",
          "createdAt": "2020-09-30T15:15:33Z",
          "updatedAt": "2020-09-30T15:15:33Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Two questions.\r\n1. RFC 7685 only specifies the usage of the padding extension in the ClientHello. Will ECH need to update the IANA registry to allow the extension to appear in EncryptedExtensions?\r\n1. RFC 7685 mandates that the server MUST NOT echo the extension. We need to amend this rule here. What's the best way to do so? A couple options:\r\n          (a) \"The server MAY echo the padding extension in its EncryptedExtensions message.\"\r\n          (b) \"The server MAY send an [unsolicited] padding extension in its EncryptedExtensions message.\"\r\n          (c) Define a new codepoint for server-side padding, which MAY be solicited by the client.",
          "createdAt": "2020-09-30T15:22:53Z",
          "updatedAt": "2020-09-30T15:25:36Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> RFC 7685 only specifies the usage of the padding extension in the ClientHello. Will ECH need to update the IANA registry to allow the extension to appear in EncryptedExtensions?\r\n\r\nI think yes.\r\n\r\n> RFC 7685 mandates that the server MUST NOT echo the extension. We need to amend this rule here. What's the best way to do so? A couple options:\r\n\r\n(a) or (b) on their own won't work. Today's clients already send the padding extension and expect that the server will not echo the extension, per the existing definition. Any phrasing must preserve that server MUST NOT for existing ClientHellos. So I think our options are (c), which is to define a whole new padding extension, or:\r\n\r\n(d) Use the same code point as before, but bodge it by saying the server is allowed to send it in EncryptedExtensions if encrypted_client_hello shows up in the ClientHello.\r\n\r\nWhat we need is something to distinguish a client which knows about the new rules and doesn't.",
          "createdAt": "2020-09-30T15:30:15Z",
          "updatedAt": "2020-09-30T15:30:15Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For (d) I'm not sure what to do about this (RFC8446, 4.3.1): \r\n>    The EncryptedExtensions message contains extensions that can be\r\n   protected, i.e., any which are not needed to establish the\r\n   cryptographic context but which are not associated with individual\r\n   certificates.  The client MUST check EncryptedExtensions for the\r\n   presence of any forbidden extensions and if any are found MUST abort\r\n   the handshake with an \"illegal_parameter\" alert.\r\n\r\nRegardless of whether the client knows the new rule, the presence of the extension causes an abort, no? I guess the question is: what's a \"forbidden extension\"? cc/ @ekr ",
          "createdAt": "2020-09-30T15:35:07Z",
          "updatedAt": "2020-09-30T15:47:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that the standard Go implementation (crypto/tls) does not appear to enforce this \"MUST\": see `readServerParameters()` in https://golang.org/src/crypto/tls/handshake_client_tls13.go.",
          "createdAt": "2020-09-30T15:43:02Z",
          "updatedAt": "2020-09-30T15:43:02Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "BoringSSL does. But yes (d) would contradict the no unsolicited extensions rule and would need some text to undo it (as is already done for the cookie extension in HRR).\r\n\r\nThe no unsolicited extensions rule is really an approximation of a more subtle rule: the server can only send things in EncryptedExtensions that it knows the client will understand. The client can expect to fully parse the entirety of EncryptedExtensions.\r\n\r\nNo matter how we slice it, this is a change to the wire protocol. Changes to the wire protocol require some flavor of negotiation, so we retain compatibility with existing implementations.",
          "createdAt": "2020-09-30T16:00:48Z",
          "updatedAt": "2020-09-30T16:01:21Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I think C makes more sense.  The code changes, let alone the wording changes, for it seem more clean and simple.",
          "createdAt": "2020-09-30T16:04:22Z",
          "updatedAt": "2020-09-30T16:04:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I tend to agree with @richsalz, though I think @davidben's idea is very doable. I think the trade off is cleanliness (c) vs not defining a new codepoint (d). I'm not sure what's more important.",
          "createdAt": "2020-09-30T16:05:51Z",
          "updatedAt": "2020-09-30T16:05:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd go for (c). I think code points are (intentionally) cheap, so we might as well use them, especially since it's an extension inside EE (and less likely something a middlebox might already latch onto?).",
          "createdAt": "2020-09-30T16:18:01Z",
          "updatedAt": "2020-09-30T16:19:05Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(c) SGTM. And yeah I agree it's probably less fuss.\r\n\r\nSince the inner CH should have padding anyway, perhaps the ClientHello extension should not just solicit padding but also just contain padding as before. Then we're effectively dropping ECH's dependency on RFC7685 and moving it to a more general padding extension.",
          "createdAt": "2020-09-30T16:31:52Z",
          "updatedAt": "2020-09-30T16:31:52Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like that idea.",
          "createdAt": "2020-09-30T16:34:33Z",
          "updatedAt": "2020-09-30T16:34:33Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Alrighty,  https://github.com/tlswg/draft-ietf-tls-esni/pull/313 is my attempt to spell (c) with @davidben's suggestion of dropping dependency on RFC7685. I look forward to your feedback.",
          "createdAt": "2020-09-30T18:52:38Z",
          "updatedAt": "2020-09-30T18:52:38Z"
        }
      ]
    },
    {
      "number": 265,
      "id": "MDU6SXNzdWU2Nzg2NDk4ODk=",
      "title": "\"outer_extensions\": Guidance on what to compress",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/265",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In Section 6.1:\r\n\r\n> Clients SHOULD only use this mechanism for extensions which are large. All other extensions SHOULD appear in both ClientHelloInner and ClientHelloOuter even if they have identical values. \r\n\r\nif I were implementing this extension, I think the simplest thing would be to compress all copied extensions by default:\r\n1. it's not computationally intensive;\r\n1. it minimizes bandwidth overhead; and\r\n1. it's simpler for future \"big\" extensions, since no code changes would be needed here.\r\n\r\nI suggest removing this guidance.",
      "createdAt": "2020-08-13T18:29:51Z",
      "updatedAt": "2020-08-19T22:40:41Z",
      "closedAt": "2020-08-19T22:40:41Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#272 addresses this issue.",
          "createdAt": "2020-08-17T20:09:03Z",
          "updatedAt": "2020-08-17T20:09:03Z"
        }
      ]
    },
    {
      "number": 266,
      "id": "MDU6SXNzdWU2Nzg2NTQ0NjM=",
      "title": "Security considerations: SNI leakage vectors",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/266",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Section 7.1 provides a bit of guidance on how ECH might interact with other extensions:\r\n\r\n> The client MUST place the value of ECHConfig.public_name in the ClientHelloOuter\r\n\"server_name\" extension. The ClientHelloOuter MUST NOT contain a \"cached_info\"\r\nextension {{!RFC7924}} with a CachedObject entry whose CachedInformationType is\r\n\"cert\", since this indication would divulge the true server name. The remaining\r\ncontents of the ClientHelloOuter MAY be identical to those in ClientHelloInner\r\nbut MAY also differ.\r\n\r\nI think it's worth expanding on this in \"Security Considerations\". There may be other ways that private CH extensions get leaked, now or in the future.",
      "createdAt": "2020-08-13T18:38:13Z",
      "updatedAt": "2020-08-18T03:55:45Z",
      "closedAt": "2020-08-18T03:55:45Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Now that we've switched to encrypting an entire ClientHello, I think the text wants to say something else anyway: if you want ECH + cached info, you simply include the cached_info extension in the ClientHelloInner, not the ClientHelloOuter. There wouldn't be much point in sending a true name cached_info in ClientHelloOuter since the true server would ignore it. Sending a public name cached_info in ClientHelloOuter is also plausible and also needn't be forbidden (it reveals information about the public name, which is public). It's also probably not that useful since it's just a recovery mechanism, but maybe to avoid sticking out, for clients that normally send it?\r\n\r\nMore generally, anything dependent on the inner name goes in ClientHelloInner and not ClientHelloOuter.",
          "createdAt": "2020-08-13T19:13:21Z",
          "updatedAt": "2020-08-13T19:13:21Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I took a stab at replacement text in https://github.com/tlswg/draft-ietf-tls-esni/pull/270. Thoughts?",
          "createdAt": "2020-08-17T18:55:20Z",
          "updatedAt": "2020-08-17T18:55:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm happy with it.",
          "createdAt": "2020-08-17T19:55:39Z",
          "updatedAt": "2020-08-17T19:55:39Z"
        }
      ]
    },
    {
      "number": 267,
      "id": "MDU6SXNzdWU2Nzg2NTgwNTQ=",
      "title": "\"ech_accept\" response type undefined",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/267",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Section 6: \r\n\r\n> Finally, requirements in {{client-behavior}} and {{server-behavior}} require\r\nimplementations to track, alongside each PSK established by a previous\r\nconnection, whether the connection negotiated this extension with the\r\n\"ech_accept\" response type. If so, this is referred to as an \"ECH PSK\".\r\nOtherwise, it is a \"non-ECH PSK\". This may be implemented by adding a new field\r\nto client and server session states.\r\n\r\n\"ech_accept\" is not defined anywhere.\r\n",
      "createdAt": "2020-08-13T18:44:56Z",
      "updatedAt": "2020-09-18T21:31:04Z",
      "closedAt": "2020-09-18T21:31:04Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I suspect \"the connection negotiated this extension with the 'ech_accept' response type\" is an incorrect way of saying that ECH was accepted.",
          "createdAt": "2020-09-01T00:05:40Z",
          "updatedAt": "2020-09-01T00:05:40Z"
        }
      ]
    },
    {
      "number": 274,
      "id": "MDU6SXNzdWU2ODA1MDY2Njk=",
      "title": "Usage indication: alternatives to trial decryption",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/274",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "In the current spec, the server provides no indication of whether the inner or outer ClientHello (CH) was used. This means the client must do trial decryption to make this determination, which creates complexity and potentially raises security concerns. As such, it would be useful to explore possible alternatives. In order to drive the discussion, I'll provide a few simple alternatives below, which we can refine as folks provide feedback. (The current spec, draft-07, is listed as option (0) for comparison.)\r\n\r\nBesides implementation complexity, one of our design considerations is ensuring that middleboxes don't ossify on ECH. As such, indication of ECH usage should \"stick out\" (see [draft-ietf-tls-sni-encryption, Sec 3.4](https://tools.ietf.org/html/draft-ietf-tls-sni-encryption-09#section-3.4)) as little as possible.\r\n\r\nFor our purposes, \"do not stick out\" means a middlebox who observes connections between the client and the client-facing server can't distinguish between real ECH and \"dummy\" ECH (i.e., a \"GREASEd\" extension, as described [Section 7.4](https://tools.ietf.org/html/draft-ietf-tls-esni-07#section-7.4)). We assume the middlebox doesn't know the ECH configuration or the public-facing name. (Note that this rules out adversaries such as the GFW, which can actively probe to discover this information.)\r\n\r\n## Option (0): Do not indicate usage\r\n**Protocol flow:**\r\n* **On input of the client's outer CH.** If the server accepts `ech` (i.e., `encrypted_client_hello`), it uses the inner CH; and if the server rejects or does not support ECH, then it uses the outer CH. It proceeds with the handshake as normal, except that in case of rejection, it sends an `ech` extension in its EE with the updated `ech` configuration.\r\n* **On input of the server's SH, EE, \u2026, Finished.** The client determines whether the inner CH or outer CH was used by computing the decryption key for each scenario and attempting to decrypt EE. It then proceeds with the handshake as usual, updating its `ech` configuration if applicable.\r\n\r\n**Pros**\r\n* Sticks out the least.\r\n* Is the least complex for servers to implement (same for Option (2)).\r\n\r\n**Cons**\r\n* Is the most complex for clients to implement.\r\n\r\n**Spec changes:** None.\r\n\r\n## Option (1): Publicly indicate acceptance\r\n**Protocol flow:**\r\n* **On input of the client's outer CH.** If the server accepts `ech`, it uses the inner CH; and if the server rejects or does not support `ech`, then it uses the outer CH. If the server accepts, then it adds an empty `ech` extension to its SH; if the server rejects, then it adds an `ech` extension to its EE with the updated `ech` configuration; and If the server doesn't support `ech`, then it proceeds as normal.\r\n* **On input of the server's SH, EE, \u2026, Finished.** If the SH has the `ech` extension, then the client proceeds as normal, assuming the inner CH was used; otherwise, the client proceeds as if the outer CH was used, updating its `ech` configuration if applicable.\r\n\r\n**Pros**\r\n* Is the least complex for clients to implement.\r\n\r\n**Cons**\r\n* Breaks Split Mode: the backend server must indicate acceptance in its SH but does not know whether the client-facing server accepted or not. (We could ameliorate this problem by adding an indication of acceptance to the inner CH.)\r\n* Sticks out the most. (See Option (3).)\r\n\r\n**Spec changes:** Semantics of the `ech`  extension changes; changes are needed to accommodate \"Split Mode\".\r\n\r\n## Option (2): Publicly indicate rejection\r\n\r\n**Protocol flow**:\r\n*  **On input of the client's outer CH.** If the server accepts `ech`, it uses the inner CH; and if the server rejects or does not support `ech`, then it uses the outer CH. If the server accepts or does not support `ech`, then it proceeds as usual; and if the server rejects, then it adds an `ech` extension to its SH with the updated `ech` configuration.\r\n*  **On input of the server's SH, EE, \u2026, Finished.** If the SH has the `ech` extension, then the client proceeds as if the outer CH was used and updates its `ech` configuration; otherwise, the client proceeds as if the inner CH was used. Decryption failure indicates either that the server does not support `ech` (i.e., outer CH was used) or the connection is under attack.\r\n\r\n**Pros**\r\n* Is the least complex for the server to implement (same as Option (0)).\r\n\r\n**Cons**\r\n* Sticks out, but only on rejection.\r\n* Complicates deployment: if the client offers `ech` to a server that has turned off support for the extension, then the connection will fail hard, as the client assumes lack of signal means that `ech` was accepted. (We could ameliorate this problem, at the cost of added complexity on the client side implementation.)\r\n\r\n**Spec changes:** Semantics of the `ech` extension changes; `ech` configuration update is sent in the clear. (We could avoid this by sending the new configuration in a new extension in the EE.)\r\n\r\n## Option (3): Privately indicate acceptance\r\nIt may be worth considering an alternative to Option (1) that doesn't stick out as much. Namely, it's possible to make `ech` acceptance in the SH indistinguishable from `ech` rejection.",
      "createdAt": "2020-08-17T20:30:05Z",
      "updatedAt": "2020-09-22T21:10:35Z",
      "closedAt": "2020-09-22T21:10:35Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for writing this up! We've also been pondering this issue in the context of QUIC. In particular, the status quo (option (0)) requires the handshake and record layer coordinate to implement the trial decryption. This would need to happen separately in TLS, DTLS, and QUIC.\r\n\r\nThis is especially a nuisance for QUIC as it will typically cross the TLS library\u2019s public API. TLS must configure two different keys for QUIC, then QUIC must do some trial decryption, and it must report back to TLS which keys were used. Public APIs and changes in them require coordination across groups, so ideally such interfaces stay as simple as possible. As in #264, I think an option that stays entirely in the handshake would apply to QUIC better.",
          "createdAt": "2020-08-17T21:05:29Z",
          "updatedAt": "2020-08-17T21:05:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That (option (1) or something like it) would be my preference as well.",
          "createdAt": "2020-08-17T21:25:55Z",
          "updatedAt": "2020-08-17T21:25:55Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would prefer Option 3, or something like it, if trial decryption is not acceptable.  Martin Thomson's proposal from March (placing a signal in ServerHello.random) seems like the logical approach to me.  There were [some concerns](https://mailarchive.ietf.org/arch/msg/tls/tvJx0setNnskI6eCR2Q20kcdy_M/) about an active attack that can distinguish acceptance from rejection, but that's still much better than a cleartext signal.",
          "createdAt": "2020-08-17T21:31:45Z",
          "updatedAt": "2020-08-17T21:31:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To clarify, I think any of (1-3) would avoid the QUIC issues. The deployment concerns of (2) worry me, and the extent to which (1) sticks out makes me a little uncomfortable. I'm interested in exploring option (3).",
          "createdAt": "2020-08-17T21:32:16Z",
          "updatedAt": "2020-08-17T21:32:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here's a suggestion for Option (3), worked out by me and some folks at Cloudflare. (Others might have had a similar idea, I don't mean to take credit!) The indication is a pseudorandom value output by the HPKE state. (If `ech` is not accepted, then a random value is used instead.)\r\n\r\n## Suggestion for Option (3)\r\nLet `context` denote the HPKE state shared by the client and server when `ech` is accepted. Its output can be treated as pseudorandom, e.g., `context.Export(\"tls13-ech-hrr-key', 16)` in Section 7.1 is treated as being indistinguishable from random.\r\n\r\n**Protocol flow:**\r\n* **On input of the client's outer CH.** If the server accepts `ech`, it uses the inner CH; and if the server rejects or does not support `ech`, then it uses the outer CH. If the server accepts, then it adds an `ech` extension to its SH with `context.Export(\"tls13-ech-accept\", 16)` as the value; if the server rejects, then it adds an `ech` extension to its SH with a random, 16-byte string and an \"ech_retry\" extension to its EE with the updated `ech` configuration; if the server does not support `ech`, then it proceeds as normal, but MAY mimic `ech` rejection.\r\n* **On input of the server's SH, EE, \u2026, Finished.** If the SH has the `ech` extension with payload `context.Export(\"tls13-ech-accept\", 16)`, then it proceeds as if the inner CH was used; otherwise it proceeds as if the outer CH was used, updating its `ech` configuration if applicable.\r\n\r\n**Pros**\r\n* Similar to Option (1)\r\n\r\n**Cons**\r\n* Similar to Option (1), but doesn't stick out as much. (It sticks out as much as the CH when dummy `ech` is used as described in Section 7.4.)\r\n\r\n**Spec changes:** Semantics of `ech` extension changes; adds `ech_retry` (i.e., `encrypted_client_hello_retry`) extension.",
          "createdAt": "2020-08-17T21:34:53Z",
          "updatedAt": "2020-08-17T21:41:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(FWIW, I think the ServerHello.Random trick is due to @davidben or @dvorak42)",
          "createdAt": "2020-08-17T21:38:02Z",
          "updatedAt": "2020-08-17T21:38:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Weighing in: my vote goes to something like (3) as a means of not sticking out.",
          "createdAt": "2020-08-17T21:41:02Z",
          "updatedAt": "2020-08-17T21:41:02Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Before I even finished reading the opening post, I was thinking (3), so that seems like an obvious win.  What this does is signals *support* for ECH at a server, but doesn't indicate anything more.  It's an expensive way to signal a single bit, but that's not terrible.\r\n\r\nNote that this can be used to indicate support in-principle without any config, because servers (or stacks) that want to join the crowd can always produce this random string.  That would increase the number of servers that appear to support ECH, at very little cost.",
          "createdAt": "2020-08-17T21:54:38Z",
          "updatedAt": "2020-08-17T21:54:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm pleasantly surprised by how much consensus there is for Option (3). (BTW, kudos to the HPKE authors for designing a really nice API!) Does anyone have comments on the suggestion for Option (3) above?",
          "createdAt": "2020-08-17T21:59:15Z",
          "updatedAt": "2020-08-17T21:59:15Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Signalling that the server supports ECH in cleartext seems like a significant loss to me, and I think we can avoid it.  For example, if the first ~8 bytes of ServerHello.random were replaced by a MAC of the rest of the ServerHello, keyed from the HPKE context, that would be a tamperproof signal that the inner ClientHello was used.",
          "createdAt": "2020-08-17T22:14:37Z",
          "updatedAt": "2020-08-17T22:14:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Signalling that the server supports ECH in cleartext seems like a significant loss to me, and I think we can avoid it. For example, if the first ~8 bytes of ServerHello.random were replaced by a MAC of the rest of the ServerHello, keyed from the HPKE context, that would be a tamperproof signal that the inner ClientHello was used.\r\n\r\nThis would require security analysis to be sure it's actually safe. \r\n\r\nBut beyond that, what type of adversary are you considering?",
          "createdAt": "2020-08-17T23:00:13Z",
          "updatedAt": "2020-08-17T23:00:13Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Of course, if every stack produced the 16 byte extension in ServerHello, how is that materially different than 8 bytes embedded in ServerHello.random?",
          "createdAt": "2020-08-17T23:29:31Z",
          "updatedAt": "2020-08-17T23:29:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Overloading the SH.random this way is likely to violate assumptions made in existing security analyses for TLS 1.3. @bemasc's suggestion might turn out to be OK, but it would be safer to stick this in our own extension. That point notwithstanding, I'm worried about the broader precedent this could set, since overloading the semantics of CH.random and SH.random got us into trouble in earlier versions of TLS.",
          "createdAt": "2020-08-17T23:54:55Z",
          "updatedAt": "2020-08-17T23:55:29Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't know that this is necessarily the case, but unless we need to, avoiding more use of those bits is desirable.  We could run out, and with 32 bytes, that's saying something.",
          "createdAt": "2020-08-17T23:58:47Z",
          "updatedAt": "2020-08-17T23:58:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think what's clear is that the SH.random trick requires analysis, whereas the SH extension variant does not. Right?",
          "createdAt": "2020-08-18T00:00:07Z",
          "updatedAt": "2020-08-18T00:00:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think they both need analysis, but the SH.random trick is much more invasive and likely to break things. In addition, if more \"users\" of the SH.random come along, then we would need to vet the interaction of our extension with theirs. (As @martinthomson points out.)",
          "createdAt": "2020-08-18T00:03:33Z",
          "updatedAt": "2020-08-18T00:06:26Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to option 3, and I tend to think that use of a SH extension is not a big concern.\r\n\r\nIt's correct that the extension might indicate the use of ECH. But from the perspective of a middlebox, that would always be the case when the _client_ sends an ECH extension. Also, there would be other ways to determine if a large-scale server supports ECH (note: ECH is about hiding a tree in the wood, so it's about the cost of finding such woods). Therefore, in practice there's marginal benefit in making the server support signal indistinguishable.",
          "createdAt": "2020-08-18T03:52:02Z",
          "updatedAt": "2020-08-18T03:52:02Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From @cjpatton \r\n> I think they both need analysis, but the SH.random trick is much more invasive and likely to break things. In addition, if more \"users\" of the SH.random come along, then we would need to vet the interaction of our extension with theirs. (As @martinthomson points out.)\r\n\r\nI agree that analysis is needed, but I think using 8 bytes of SH.random is not a weird hack. It's at least a well-understood hack, because it's nicely parallel to the downgrade sentinel, and they never coexist.\r\n\r\nFrom @kazuho\r\n> It's correct that the extension might indicate the use of ECH. But from the perspective of a middlebox, that would always be the case when the client sends an ECH extension.\r\n\r\nTLS 1.2 middleboxes frequently take action based on the certificate, so  ServerHello extensions seem likely to be used as well.  If there's a ServerHello extension, I expect that some firewall vendor will offer a checkbox labeled \"Block Encrypted ClientHello\" based on this extension, in the \"Security\" section, and some admins will turn it on without understanding what it does.  If the local network is normally used to access a small set of services, and none of them support ECH yet, then this will appear to work fine, perhaps for years.  Then, if one of those services tries to enable ECH, they'll get angry phone calls from customers who can no longer access the service.  For them, ECH will be ossified.\r\n\r\nFor QUIC, I agree that a visible extension is OK, since it's not too late to get it into 1.0.  For TLS, I worry that it is too late.",
          "createdAt": "2020-08-18T14:14:00Z",
          "updatedAt": "2020-08-18T14:14:00Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "@bemasc, given that servers can respond with rejection even without actual ECH support, would your concern be alleviated if some servers started rejecting the GREASE ECH extensions in the near future?",
          "createdAt": "2020-08-18T14:24:43Z",
          "updatedAt": "2020-08-18T14:24:43Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi thread, since there's largely consensus here, I'm going to start working on a PR for Option (3). I'll post it here when it's ready. Thanks for your input!",
          "createdAt": "2020-08-18T20:45:38Z",
          "updatedAt": "2020-08-18T20:45:38Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@MikeBishop Sure, the sooner many servers become \"ECH-aware\", the better.  However, I expect that conservative institutional services will be very slow to update.  In the extreme case, if a network is only used to access one service, then the broader ecosystem has limited direct impact.\r\n\r\nI don't mean to claim that this ossification is inevitable, but I'd prefer to reduce the risk if we can find a reasonable alternative.",
          "createdAt": "2020-08-18T20:58:39Z",
          "updatedAt": "2020-08-18T20:58:39Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton Regarding your second-extension proposal above, it seems to me that there are two options here.  In the one you wrote (\"ech_retry\"), the second extension (empty from the client) is paired with the retry configs.  Syntactically, this makes the retry functionality optional: a client that doesn't support retry could omit the \"ech_retry\" extension.\r\n\r\nAn alternative would be to pair the retries with the \"ech\" extension (as in the current draft), and pair the context tag response with a new empty extension.  I would call it \"context_tag\".  Syntactically, this makes the context tag functionality optional: clients that support trial decryption could omit it.\r\n\r\nI think the \"context_tag\" arrangement is preferable.  It's not explicitly connected to ECH, which I think makes it more likely to be implemented and less likely to be blocked.  In principle, it could be used for any future situation where the cryptographic context is ambiguous.  It would also give clients the option to use trial decryption in TLS/TCP, and avoid it for QUIC.  (Support would be mandatory for ECH and QUIC servers, but optional for clients.)",
          "createdAt": "2020-08-19T13:38:08Z",
          "updatedAt": "2020-08-19T13:39:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc, this sounds like an alternative to Option (3) that makes the explicit indication of acceptance optional. Just so we're on the same page, we think this is what you mean (@chris-wood and I really like this idea, if this is in fact what you intend):\r\n\r\n**Protocol flow:**\r\n* **On input of the client's outer CH.** If the server accepts `ech`, it uses the inner CH; and if the server rejects or does not support `ech`, then it uses the outer CH.\r\n   * If the client requested a context tag in its `ech`:\r\n       * If the server accepts, then it adds an `ech_context_tag` extension to its SH with `context.Export(\"tls13-ech-accept\", 16)` as the value.\r\n       * if the server rejects, then it adds an `ech_context_tag` extension to its SH with a random, 16-byte string.\r\n    * If the server rejects, then it adds and an `ech` extension to its EE with the updated `ech` configuration.\r\n    * if the server does not support `ech`, then it proceeds as normal, but MAY mimic `ech` rejection.\r\n* **On input of the server's SH, EE, \u2026, Finished.**  If the client didn't request a context tag, then it proceeds as in Option (0).  If the client requested a context tag and the SH has the `ech_context_tag` extension with payload `context.Export(\"tls13-ech-accept\", 16)`, then it proceeds as if the inner CH was used; otherwise it proceeds as if the outer CH was used, updating its `ech` configuration if applicable.",
          "createdAt": "2020-08-19T15:26:01Z",
          "updatedAt": "2020-08-19T15:28:58Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that's about what I mean, but I'm not clear on what you're saying the client would send. Here's what I was thinking:\r\n\r\n* The `ech` extension is not changed at all from the current draft.\r\n* We define a new extension: `context_tag`.  In the ClientHello, it is empty.  The response (in the ServerHello) contains 16 random bytes by default.  If the server is using an ECH context, the value is `context.Export(<constant>, 16)` instead.\r\n* A ClientHello may contain either or both of `ech` and `context_tag`.  The client should include `context_tag` in all their ClientHellos (inner and outer, ECH and GREASE) or none, for a given protocol (TCP or QUIC).\r\n* Servers that implement `ech` must also support `context_tag`.  All other servers should support `context_tag` (which is trivial).\r\n* All QUIC servers must implement `context_tag`.  (Possibly not something we can specify in this draft.)",
          "createdAt": "2020-08-19T17:19:23Z",
          "updatedAt": "2020-08-19T17:19:23Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems fine, except that it doesn't make sense to offer the `context_tag` extension without the `ech` extension, since the `context_tag` response is derived from the HPKE state.\r\n\r\nI'm suggesting that the client \"requests\" a context tag in its `ech` extension. In particular, there's a flag in the extension that is \"true' if it requests a tag and \"false\" otherwise. Doing this in a separate extension is fine, but you wouldn't want to offer that extension without also offering `ech`.",
          "createdAt": "2020-08-19T17:23:37Z",
          "updatedAt": "2020-08-19T17:24:57Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm suggesting that the client \"requests\" a context tag in its ech extension.\r\n\r\nI'm not sure this is [allowed](https://tools.ietf.org/html/rfc8446#section-4.2):\r\n> Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests...  Upon receiving such an extension, an endpoint MUST abort the handshake with an \"unsupported_extension\" alert.\r\n\r\nI also think this formulation is clearer from the perspective of a server that does not implement ECH.\r\n\r\nBTW, here's a variation that's even simpler, and might work better with split mode:\r\n* If the ClientHello's `context_tag` is empty, the server responds with 16 random bytes.\r\n* Otherwise, the server echoes the contents.\r\n* The client includes an empty `context_tag` in the outer ClientHello, and one containing 16 random bytes in the inner ClientHello.",
          "createdAt": "2020-08-19T17:43:17Z",
          "updatedAt": "2020-08-19T17:43:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I also think this formulation is clearer from the perspective of a server that does not implement ECH.\r\n\r\nYup, I agree! This will be what the PR does.",
          "createdAt": "2020-08-19T17:43:44Z",
          "updatedAt": "2020-08-19T17:47:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR is underway, I just need to revise the client and server behavior. Should be done tomorrow!",
          "createdAt": "2020-08-20T00:44:14Z",
          "updatedAt": "2020-08-20T00:44:14Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "Another possibility is that in the ECH message the client sends a FLAGS extension with a bunch of bits set, and the server responds with a FLAGS extension that has one of those bits set.  The plaintext CH could have a superset of the ECH flags.",
          "createdAt": "2020-08-20T17:03:05Z",
          "updatedAt": "2020-08-20T17:03:05Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@richsalz Right, that would the flags-encoded of option (1). It does, however, stick out.",
          "createdAt": "2020-08-20T17:05:10Z",
          "updatedAt": "2020-08-20T17:05:10Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I thought my \"plaintext CH could have a superset of the ECH flags\" handled the sticking out part.",
          "createdAt": "2020-08-20T17:07:12Z",
          "updatedAt": "2020-08-20T17:07:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh I see. Sorry, I misunderstood. Though that seems to also stick out: you can tell by just checking the flags for the superset, etc., rule or however we decide to encode it.",
          "createdAt": "2020-08-20T17:09:34Z",
          "updatedAt": "2020-08-20T17:09:34Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I'm not pushing on this very hard, but if you grease flag-bits in the CH and pick one of those bits in the ECH.  Maybe that doesn't work, so I'm willing to let this drop.\r\n",
          "createdAt": "2020-08-20T17:56:13Z",
          "updatedAt": "2020-08-20T17:56:13Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My model of the implementation here is that the server is made up of two components in a stack:\r\n\r\nECH-unwrapping portion of the server\r\n- can broadly be thought of as the proxy frontend, think large proxy provider pointed to by the site's DNS\r\n- has access to the ECH key and the fallback key only\r\n- forwards the inner client hello to the backend service if encryption works\r\n- finishes the handshake with updated ECH config with the updated key if ECH doesn't decrypt\r\n- can be deployed on a global edge network close to eyeballs (even places where TLS termination isn't safe)\r\n\r\nBackend service\r\n- associated with the site certificate owner, think individual dedicated host behind proxy provider\r\n- has access to private key for the certificate\r\n- standard TLS 1.3 implementation, answers inner CHs or non-ECH CHs\r\n- can be deployed in a hardened/trusted datacenter (no need to put on global edge where content isn't decrypted)\r\n- could even be something like an AWS LB or other service that has no incentive to implement anything ECH-related\r\n\r\nThese two components communicate over the network, or in the degenerate case, are in the same machine.\r\n\r\nMy understanding is that Option (1)\r\na) requires there to be signaling between the front-end and the back-end, and\r\nb) requires changes to the backend service to support ECH and the signaling\r\n\r\nThis additional complexity seems hard to justify and could hinder many deployment scenarios (especially ones we haven't thought of yet). What is the proposed mechanism for signaling whether an inner client hello was used or an outer client hello? This eliminates the ability to use existing TLS stacks without modification, and on top to support a signaling layer. Option (1) seems fraught.\r\n\r\nIt seems like Option (3) does not require signaling (signaling would come in-handshake from the new extension), but it does require backend changes to implement the new extension. This wouldn't work in situations where a third party doesn't have any motivation to implement ECH-related extensions, a tough loss, but not fatal. The problem here is that the combination of the presence of the client extension (signaling client support for ECH) and the server extensions (signaling server support for ECH) is going to make ECH-enabled traffic stick out from non-ECH-enabled traffic, even if dummy ECHs are sent 100% of the time from supporting clients. The ossification risk is huge.\r\n\r\nOption (2) is my strong preference because it doesn't require backend changes and doesn't stick out unless ECH fails to be decrypted (which is a degenerate case).\r\n",
          "createdAt": "2020-08-20T19:18:50Z",
          "updatedAt": "2020-08-20T19:18:50Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems to me that we are trading off between three things:\r\n\r\n- Ability/difficulty of an adversary to determine that ECH is in use (as opposed\r\n  to that ECH is possible with a server)\r\n- Compatibility with split mode.\r\n- Ease of client implementation\r\n\r\nAs I understand the situation we have (Y is good in each column)\r\n\r\n~~~~\r\n                Can't detect ECH-in-use        Split-Mode       Easy Client Impl\r\nCurrent           Y                              Y                N\r\nOption 1          N                              N                Y\r\nOption 2          Y*                             Y                ?\r\nOption 3          Y                              N                Y\r\n~~~~\r\n\r\n* Except on rejection, for what that's worth.\r\n\r\nUnless I misunderstand, Ben's proposals are just different spellings of (3).\r\n\r\nI don't think anyone likes 1 so that leaves us with Current, 2, and 3.\r\n\r\nI'm not that concerned about the \"implementation\" issues of Current, but I am\r\nquite concerned about the QUIC/DTLS issues, so I think we should strive to\r\navoid that. That leaves us with 2 and 3.\r\n\r\nAs I understand it, the complexity issue is that if the server has\r\nturned off support for ECH entirely, then the connection will hard\r\nfail. However, with the current state of the spec I believe that this\r\nis effectively the state anyway. Here's the relevant text:\r\n\r\n   Note that authenticating a connection for the public name does not\r\n   authenticate it for the origin. The TLS implementation MUST NOT\r\n   report such connections as successful to the application. It\r\n   additionally MUST ignore all session tickets and session IDs\r\n   presented by the server. These connections are only used to trigger\r\n   retries, as described in {{handle-server-response}}. This may be\r\n   implemented, for instance, by reporting a failed connection with a\r\n   dedicated error code.\r\n\r\nIOW, we don't try to recover for cases where the client-facing server\r\nhas just forgotten about ECH but rather where it has forgotten the\r\nECH key. So, hard fail is actually not a problem here. I'm similarly\r\nnot worried about signaling that the server is ECH-capable (especially\r\nin this case where it's actually not). So, I think my ? under \"Easy\r\nClient Impl\" turns out to be a Y.\r\n\r\nWith that said, I do find Option 3 aesthetically cleaner, though I'd\r\nstruggle a bit to explain why and there is an obvious appeal to not\r\nhaving *any* public signaling in terms of being able to analyze it,\r\nthough I'm not sure how strong an argument that is. I'm also not\r\nthat worried about the sticking out piece, as I would expect that\r\nwe can rapidly make a lot of servers accept and pretend do respond\r\nto grease-ECH -- which we would want to do in any case.\r\n\r\nI'd like to hear from some other people about why they prefer (3) to (2)\r\nand whether there is some split mode-compatible variant of (3).\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-08-20T20:28:25Z",
          "updatedAt": "2020-08-20T20:28:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Option (2) means ECH becomes much riskier to deploy. In options (0), (1), or (3), a service can advertise ECH in the DNS and not largely panic about inconsistencies between hard-to-predict DNS cache behavior, and hard-to-predict future or present rollout decisions on individual servers.\r\n\r\nThe only hard commitment is that the servers advertised in DNS are able to speak on behalf of the public name. As long as that that's true, the client has an authenticated signal to recover from any DNS / server mismatches. In particular, if there is a problem and the service needs to roll back ECH (or if the service was in the process of rolling out ECH and missed a few spots initially), the existing TLS server behavior will be correctly interpreted by the client as an authenticated rollback, and the client can recover. This is true for every TLS feature I can think of to date: it is always safe to rollback. With the exception that proves the rule being 0-RTT, which got a note in the spec (RFC8446, appendix D.3.) to describe client behavior to restore safety.\r\n\r\nOption (2) breaks this invariant.",
          "createdAt": "2020-08-20T20:42:17Z",
          "updatedAt": "2020-08-20T20:42:34Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben. Sorry, I had misread the specification and I agree with you. To recap for those following at home presently the client's algorithm is:\r\n\r\n~~~\r\n1. Trial decrypt as if ECH accepted. If success, then proceed.\r\n2. Trial decrypt as if ECH rejected. If failure, then abort.\r\n3. If retry_keys is present, then restart with ECHConfig == retry_keys\r\n4. If retry_keys is absent, then retry without ECH\r\n~~~\r\n\r\nIt's point 4 that is relevant here. I had read the spec as requiring a hard failure, but it in fact recovers. That pushes me more towards (3).\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-08-20T20:52:37Z",
          "updatedAt": "2020-08-20T20:52:37Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'd like to hear ... whether there is some split mode-compatible variant of (3).\r\n\r\nI believe I described one above.  I'll rephrase, in case it was unclear:\r\n\r\n* `context_tag` is an extension that appears in ClientHello and ServerHello.\r\n* If the ClientHello contains a `context_tag` with empty contents, the server replies with a `context_tag` containing 16 random bytes.\r\n* Otherwise, the ServerHello's `context_tag` echoes the contents of the ClientHello's `context_tag`.\r\n* The client includes an empty `context_tag` in the outer ClientHello, and a `context_tag` containing 16 random bytes in the inner ClientHello.\r\n\r\n",
          "createdAt": "2020-08-20T20:53:19Z",
          "updatedAt": "2020-08-20T20:53:19Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc this is only *partially* split-mode compatible in that it requires changing every origin server. It just doesn't require coordination between the servers.",
          "createdAt": "2020-08-20T20:54:29Z",
          "updatedAt": "2020-08-20T20:54:29Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True!  For any extension implementing Option 3, I think we want those changes anyway.  If a ServerHello extension is only implemented by ECH terminating servers, then its presence distinguishes real ECH from GREASE.  If it's widely implemented, then that signal is diminished.\r\n\r\nAlternatively, we could say that the new extension is only for QUIC, and make TLS/TCP stick to trial decryption.",
          "createdAt": "2020-08-20T21:04:09Z",
          "updatedAt": "2020-08-20T21:04:09Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure. I'm comparing it to (2).",
          "createdAt": "2020-08-20T22:50:02Z",
          "updatedAt": "2020-08-20T22:50:02Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi all, see PR #283 for our proposal for Option (3), with @bemasc's improvements incorporated. The main points:\r\n* The client may request confirmation of ECH acceptance (Option (3)), but the default behavior is Option (0).\r\n* Acceptance is indistinguishable from rejection, which is the primary motivation for choosing Option (3) over Option (1).\r\n* Split Mode works for Option (3), but the backend server needs to support ECH. (All it has to do is echo an extension sent by the client-facing server.) There's no change to the backend if confirmation isn't requested.",
          "createdAt": "2020-08-20T23:07:24Z",
          "updatedAt": "2020-08-20T23:08:33Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't understand why this is better than (3). Won't every client just send ech_confirm, in which case this is isomorphic to 3?",
          "createdAt": "2020-08-21T21:34:12Z",
          "updatedAt": "2020-08-21T21:34:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Option (0) sticks out less than option (3), which is why a client might opt to not send \"ech_confirm\".",
          "createdAt": "2020-08-21T23:14:37Z",
          "updatedAt": "2020-08-21T23:14:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm ... I think there should be away to resolve the deployment issues between (2) and (3). Will post on Monday.",
          "createdAt": "2020-08-22T00:13:01Z",
          "updatedAt": "2020-08-22T00:13:01Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "(3') This seems strictly worse than either (0) or (3). We'll have an odd mix of people doing one or the other and every server will have to do and test both.",
          "createdAt": "2020-08-24T13:53:17Z",
          "updatedAt": "2020-08-24T13:53:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr:\r\n\r\n> (3') This seems strictly worse than either (0) or (3). We'll have an odd mix of people doing one or the other and every server will have to do and test both.\r\n\r\nYou're suggesting that confirmation SHOULD NOT be optional, correct? I'm Ok with this, but it seems to me that it's not especially complicated to implement this correctly on the server side. The hard bit is the client, since it has to do trial decryption.\r\n\r\n@davidben:\r\n\r\n> Option (2) means ECH becomes much riskier to deploy.\r\n\r\nI'd like to drill down on the problem of rolling back ECH. The essence of the problem is that an ECH server that advertised a configuration in the past must support ECH for as long as that configuration is valid. What are some \"bad\" events that may lead to this contract being violated?\r\n\r\n- *The ECH secret key has been compromised, so the service needs to be shut off until a new key is rolled.* In the meantime, the service can explicitly reject ECH without providing a new configuration. The client would take this as a signal of ECH being disabled by the server.\r\n- *A bug is found somewhere in the TLS stack, and the quick fix is to revert to a point before the ECH code was committed.* This is definitely a risk, but I wonder if there are ways to mitigate it. For example, if the configuration is valid for the next hour, say, then we must delay the rollback until the hour has lapsed. Alternatively, we can roll-back right away, and when the client aborts because of decryption failure, it might make a DNS query to see if ECH support has been turned off.",
          "createdAt": "2020-08-24T18:06:36Z",
          "updatedAt": "2020-08-24T18:11:15Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton \r\n\r\nI agree that the first issue is fine by option (2). (Though probably the mitigation would be to roll out a new key. One hopes that pipeline is already built out and regularly exercised by routine key rotation.)\r\n\r\nI'm worried about the second one, but I think the characterization is too simple. TLS implementations are part of a complex system, both within the service and on the internet as a whole. Complex systems break unpredictably. Maybe it's a TLS bug. Maybe ECH inadvertently broke some assumption in some other part of the stack. Maybe some large client had a bug that only triggered due here to some quirk of the server. Maybe some printer happened to be [using the code point](https://mailarchive.ietf.org/arch/msg/tls/i9blmvG2BEPf1s1OJkenHknRw9c/) and now breaks. Maybe it had nothing to do with TLS at all, but some other concurrent server change broke and the entire release needs to be rolled back.\r\n\r\nAnything which interferes with the default response (rollback to a known good configuration) is expensive and risky. This risk needs to be communicated across a long game of telephone from...\r\n\r\n* the people who wrote the ECH to spec, to...\r\n* the people who implemented it in the TLS library, to...\r\n* the people who integrated it into some server software, to...\r\n* the people who perhaps packaged the server software into some OS release, to...\r\n* the people who perhaps shipped the OS release in some server appliance, to...\r\n* the people who manage the rollout of the change in some deployment, to...\r\n* the people who noticed a failure in a faraway system and are trying to mitigate it\r\n\r\nThis is not practical, especially if we want ECH to be widely adopted.\r\n\r\nTo the alternatives you list, when things go wrong, the priority is to get the service working again. Leaving it broken until the ECH config expires is thus not great. Moreover, expiry itself is a property of a complex system (DNS), so it may not be clear when it actually expires. Mandating a client retry on decryption failure is more plausible (compatible with rollback), but it relies on caching properties of the DNS, which is where much of the deployment mismatch risk comes from in the first place.",
          "createdAt": "2020-08-24T19:41:01Z",
          "updatedAt": "2020-08-24T19:41:01Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Mandating a client retry on decryption failure is more plausible (compatible with rollback), but it relies on caching properties of the DNS, which is where much of the deployment mismatch risk comes from in the first place.\r\n\r\nCan you elaborate on this issue a bit more? Suppose the DNS and ECH provider are the same entity, and suppose that entity can synchronize the DNS response with the rollback. I guess one potential pitfall is that the client could use a DNS response cached by its operating system? Any others?",
          "createdAt": "2020-08-24T21:05:52Z",
          "updatedAt": "2020-08-24T21:05:52Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": ">  Suppose the DNS and ECH provider are the same entity, \r\n\r\nThat's a simplifying assumption and doesn't always hold.  Even within an enterprise, it's not uncommon for the DNS folks to be a separate group from those running the webservers.",
          "createdAt": "2020-08-24T21:23:07Z",
          "updatedAt": "2020-08-24T21:23:07Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Even when they are the same entity, I don't think synchronizing the DNS response with the rollback is meaningful. As you note, the OS has a cache. The client may have a cache in front of that. The recursive resolver may have a cache. There are probably other caches in various DNS middleware. There is also no guarantee that the same server instance and will serve the client's DNS query and the client's TLS connection, which means that during the course of a rollout or rollback, there will be mismatches.",
          "createdAt": "2020-08-24T21:25:31Z",
          "updatedAt": "2020-08-24T21:25:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "~~Turtles~~ caches all the way down!",
          "createdAt": "2020-08-24T21:27:19Z",
          "updatedAt": "2020-08-24T21:27:19Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> There is also no guarantee that the same server instance and will serve the client's DNS query and the client's TLS connection, which means that during the course of a rollout or rollback, there will be mismatches.\r\n\r\nEr, by \"mismatch\" here, I mean that the client will see DNS and TLS configs from different generations. If a very careful server operator carefully controls changes based on TTLs and deployment times, they may be able to arrange for all observed cross-generation configs to be compatible. (And indeed they *should* arrange for TLS servers to know about ECH keys before advertising them, etc.)\r\n\r\nBut this is the careful, happy case, not a failure recovery case.",
          "createdAt": "2020-08-24T21:28:39Z",
          "updatedAt": "2020-08-24T21:28:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That's a simplifying assumption and doesn't always hold. Even within an enterprise, it's not uncommon for the DNS folks to be a separate group from those running the webservers.\r\n\r\nVery true, and I don't think we should assume this is the case. I think (3) is the best option for many deployments, but there are use cases for which (2) is much better, assuming the server can manage the DNS/TLS synchronization complexity. It might be worth exploring a hybrid approach: in its ECHConfig, the server might indicate *what* it confirms: acceptance a la (3), or rejection al a (2). \r\n\r\nThe main concern I have with (2) is that the client needs to evict its cache before making the DNS request, and I'm not sure how platform-dependent this behavior is.",
          "createdAt": "2020-08-24T21:47:47Z",
          "updatedAt": "2020-08-24T21:47:47Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The client can't evict the recursive resolver's cache. I'm not sure if even the OSes provide APIs to clear caches. (I don't see an obvious flag to pass into `getaddrinfo`.)\r\n\r\nWe also should not have two different spellings of the same thing in the protocol. It is complex enough as it is.",
          "createdAt": "2020-08-24T21:56:46Z",
          "updatedAt": "2020-08-24T21:56:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So the only way to safely rollback for option (2) is to wait until the DNS record expires. Does anyone have a sense of the degree to which clients respect the record's TTL? Google measured clock skew among Chrome clients years ago and found it was pretty dismal. Is the state of affairs any better today?\r\n\r\nIn any case, counting on clients to get DNS right appears to be risky. If we go with (2), then it seems the best option on the table so far is to use trial decryption to distinguish between ECH acceptance and (the unlikely case of) ECH rollback. \r\n\r\nLet me make one more pitch for (something like) option (2). As @grittygrease pointed out, we have largely ignored a potentially important \"don't stick out\" consideration. The goal of (3) is to make connections from a real ECH client to an ECH server look like connections from a dummy ECH client (i.e., one that sends a GREASEd extension) to an ECH server. A property that (0,2) have that (1,3) don't is that connections from a real ECH client to an ECH server look like connections from a dummy ECH client to a non-ECH server. In other words, options (1,3) don't provide covertext for non-ECH servers, whereas (0,2) do. (ECH rejection sticks out for (2), but the happy path doesn't.) Do we regard this as a risk to deployment?",
          "createdAt": "2020-08-25T15:43:40Z",
          "updatedAt": "2020-08-25T15:43:40Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In any case, counting on clients to get DNS right appears to be risky. If we go with (2), then it seems the best option on the table so far is to use trial decryption to distinguish between ECH acceptance and (the unlikely case of) ECH rollback.\r\n\r\nIf we do that, we haven't addressed this issue. If clients still need to implement trial decryption for one case, however unlikely, we're still paying for it and there's no point in building a separate thing. How common a codepath is affects performance considerations, but not complexity considerations. The issue with trial decryption is complexity, not performance. (Trial decryption also breaks some in-place decryption strategies, so there can be a performance concern too, but it's just one record so I'm not concerned about that.)\r\n\r\n> A property that (0,2) have that (1,3) don't is that connections from a real ECH client to an ECH server look like connections from a dummy ECH client to a non-ECH server. In other words, options (1,3) don't provide covertext for non-ECH servers, whereas (0,2) do. (ECH rejection sticks out for (2), but the happy path doesn't.) Do we regard this as a risk to deployment?\r\n\r\nRight, I think this is the ServerHello.random vs. new extension question for (3). Sticking the indicator in ServerHello.random makes the full cross product of {ECH-client, GREASE-client} x {ECH-server, non-ECH-server} look the same, provided the server supports TLS 1.3. This is nice, but it's a weird one-off trick we can't do again. Sticking the indicator in a new extension also makes the same cross product look the same, provided the server supports TLS 1.3 *and* has been updated to send this extension. It can send this extension independent of ECH support, but it's not a thing anyone does today because the extension doesn't exist, so the deployment curve will be different.\r\n\r\nIn contrast, (2) is missing coverage. It makes the following tuples look the same: (ECH-client, ECH-server), (ECH-client, non-ECH-server), (GREASE-client, non-ECH-server). It misses (GREASE-client, ECH-server). In particular, clients may be ECH-capable (and thus know to send GREASE extensions) but not configured with a DoH resolver and unable to get HTTPS records over Do53 (either due to cleartext problems or ossification).",
          "createdAt": "2020-08-25T16:11:59Z",
          "updatedAt": "2020-08-25T16:12:32Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The issue with trial decryption is complexity, not performance. \r\n\r\nAgreed, I'm just reiterating that we haven't solved the problem with (2) if we can't solve the problem with client-side DNS.",
          "createdAt": "2020-08-25T16:33:11Z",
          "updatedAt": "2020-08-25T17:18:28Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben, do you expect clients to send GREASE on all connections or only connections for which DoH is available? If you expect clients to send a dummy ECH in situations where the ECHConfig is potentially unavailable, do you expect the server to send ECHConfig back in the handshake and the client to restart the handshake? That seems like a pretty big performance hit.",
          "createdAt": "2020-08-25T17:33:20Z",
          "updatedAt": "2020-08-25T17:33:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> do you expect clients to send GREASE on all connections or only connections for which DoH is available?\r\n\r\nI think they should send it for all connections. That was a big part of the motivation.\r\n\r\n> If you expect clients to send a dummy ECH in situations where the ECHConfig is potentially unavailable, do you expect the server to send ECHConfig back in the handshake and the client to restart the handshake? That seems like a pretty big performance hit.\r\n\r\nNo, clients don't process retry configs on GREASE connections.\r\n\r\n> Offering a GREASE extension is not considered offering an encrypted ClientHello for purposes of requirements in {{client-behavior}}.\r\n\r\nPossibly the spec should be clearer here. The intent is that this is a different mode altogether. (~~Probably the business around sessions remembering whether ECH was negotiated can be dropped too now that we encrypted the whole ClientHello. That was originally added to work around some goofiness between the public and private names.~~ Edit: filed https://github.com/tlswg/draft-ietf-tls-esni/issues/285)\r\n\r\nThat was an intentional limitation in at least the first iteration of the retry flow. Picking up a retry config without a DNS lookup is odd for several reasons. As you note, there is a performance penalty to the retry. More importantly, the client has *already* leaked the name at that point. It'd really only be useful for subsequent connections and the text intentionally only applies the retry to one connection attempt. Trying to solve it for subsequent connections would be interesting, but there are several nuisances to resolve:\r\n\r\n* State is a tracking vector. This is easy enough to address\u2014adjust the scope of the state to meet your privacy goals, same as resumption itself\u2014but we'd need to discuss it and reducing scope also reduces effectiveness.\r\n* Remembering TLS-level state, rather than SVCB- or Alt-Svc-level state breaks the multi-CDN story. (At the time this text was written, we hadn't even figured out the multi-CDN story.)\r\n* Even if the retry keys contained a full SVCB record, one CDN won't know the config of the other CDN, so it ends up being a CDN pin, which seems awkward.\r\n* Any cache for subsequent connections needs to deal with the larger lifetimes necessary for effectiveness (see https://github.com/MikeBishop/dns-alt-svc/issues/105)\r\n\r\nGiven all that mess, I omitted it from the PR when proposing this mechanism and figured we'd think about these issues later if the WG wanted to pursue a non-DNS flow.",
          "createdAt": "2020-08-25T18:01:09Z",
          "updatedAt": "2020-08-25T18:54:42Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The DNS expiration complaint seems like overthinking a bit.\r\n\r\nStep 1: Update Registry to remove DS\r\nStep 2: Wait until DNS caches expire\r\nStep 3: Remove zone keys (KSK, ZSK, RRSIG, etc.)\r\n\r\nThis is done pretty frequently, and the servers take the risk of the site having an outage if the client has record synchronization issues.\r\n\r\nIn fact, RRSIG records have explicit expiration times, which makes them less flimsy with respect to expiration. If we follow the lead of RRSIG and add an expiration time to ECHConfig, then we're only relying on clock synchronization during rollover rather than DNS cache expiration.\r\n\r\nHow about:\r\n1) add a time box to the ECHConfig record\r\n2) recommend only sending GREASE in the same situations as 10.2. describes: when you expect to reliably get the ECHConfig record if it exists (i.e. DNSSEC or DoH)",
          "createdAt": "2020-08-25T18:03:43Z",
          "updatedAt": "2020-08-25T18:03:43Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In fact, RRSIG records have explicit expiration times, which makes them less flimsy with respect to expiration.\r\n\r\nI think this is not quite right.  When all RRSIGs in the zone are expired, [the status is 'Bogus'](https://tools.ietf.org/html/rfc4641#section-4.1), not ['Insecure'](https://tools.ietf.org/html/rfc4035#section-4.3).  In other words, DNSSEC fails hard when the validation expires, and relies on caches to respect TTL.  This is a security feature to prevent an attacker from resurrecting expired data.  This arguably supports your overall argument, but not your proposed mitigation.\r\n\r\nFrom this discussion, it sounds like trial decryption (Option 0) is only modestly inconvenient for TLS/TCP.  If so, that makes me think that we should focus on a simple, separate Option 3 extension only for QUIC, and keep TLS/TCP at Option 0.",
          "createdAt": "2020-08-25T18:51:16Z",
          "updatedAt": "2020-08-25T18:51:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi folks, in order to help drive the discussion, I've created PRs for the options currently being discussed.\r\n- #283: option (3), but incorporates various changes and improvements.\r\n- #286: based on #283, but with fallback to option (2). In case option (3) sticks out too much and gets blocked, then we can fall back to option (2) at the cost of deployment complexity. \r\n- #287: based on #283, but the indication of acceptance appears in the SH.random instead of a new SH extension. This stick out less than (3), but requires security considerations.\r\n\r\n> From this discussion, it sounds like trial decryption (Option 0) is only modestly inconvenient for TLS/TCP. If so, that makes me think that we should focus on a simple, separate Option 3 extension only for QUIC, and keep TLS/TCP at Option 0.\r\n\r\nBased on the discussion on #283, most people seem to not favor supporting this behavior.",
          "createdAt": "2020-08-25T21:27:31Z",
          "updatedAt": "2020-08-25T21:28:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi all, a quick update for those who haven't been following the proposals:\r\n1. #283 adds an explicit confirmation of acceptance as an extension to the SH.\r\n1. #286  is the same as #283, except the server can opt to only explicitly confirm rejection.\r\n1. #287 adds an explicit confirmation of acceptance by hijacking SH.random.\r\n\r\nIt seems that consensus is coalescing around #287 because it minimizes deployment coimplexity and sticks out less than #283. The open issue for this change is security.\r\n\r\n@chris-wood and I reached out to a variety of people who have worked on security proofs of TLS 1.3 to see how this change might impact their analysis. While this change is significant enough to requires generating fresh proofs, no one expects it to lead to an attack if the confirmation string is sufficiently short. The current proposal uses the last 8 bytes of the SH.random, which leaves 24 bytes of entropy to ensure uniqueness of the session id. I added discussion of this point to the PR... it would be helpful to get more eyes on this.",
          "createdAt": "2020-09-02T18:32:19Z",
          "updatedAt": "2020-09-02T18:59:36Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "2 and 3 talk to the same PR?\r\n\r\n(edited to remove the email cruft)\r\n",
          "createdAt": "2020-09-02T18:42:13Z",
          "updatedAt": "2020-09-02T19:11:07Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oops, fixed!",
          "createdAt": "2020-09-02T19:00:13Z",
          "updatedAt": "2020-09-02T19:00:13Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "To follow up on the comment I made at the mic and then decided didn't work.\r\n\r\nAssuming we accept PR#292, and decide the CHInner.Random is secret\r\nthen can we just say that the ESNI accepted signal is to have the low\r\norder bytes of SH.Random be derived from CHInner.Random (copied might\r\nwork, but hashed would make me feel better). I haven't done any\r\nreal analysis of this, but it seems like it would not permit an\r\nattacker who does not know CHInner.Random to determine whether\r\nECH was accepted.\r\n",
          "createdAt": "2020-09-03T17:22:48Z",
          "updatedAt": "2020-09-03T17:23:03Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should consider a construction like `Expand(Extract(ServerHello.random[0:24], CHInner.random), \"ech-tag\", 8)`, i.e. to make the tag dependent on the rest of `ServerHello.random`.  This would at least partly address @huitema's concern about replays.",
          "createdAt": "2020-09-03T20:45:40Z",
          "updatedAt": "2020-09-03T20:45:40Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see the replay concern as important, since all it does is reveal if ECH was used. There are easier ways for an attacker to learn this information. In fact, it doesn't need to interfere with the connection at all: all it needs to do is learn the ECH configuration.\r\n\r\nI think it's best to keep the mechanism as simple as possible. In particular, I'd like to do everything we can to not increase the requirements for the backend server in Split Mode.\r\n\r\nOf course, if there is an attack that violates the intended security goal of ECH (confidentiality of CH extensions), then we should take that seriously. But I don't think this change (i.e., #287) increases this risk compared to the status quo.",
          "createdAt": "2020-09-03T20:52:47Z",
          "updatedAt": "2020-09-03T20:54:53Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These attacks aren't part of our core threat model, but it seems like we have an opportunity to defeat some or all of them at low cost, so I think we should consider doing so.\r\n\r\n> There are easier ways for an attacker to learn this information. In fact, it doesn't need to interfere with the connection at all: all it needs to do is learn the ECH configuration.\r\n\r\nThis is true in the main deployment models we're discussing, but I can also imagine use cases where the ECHConfig is not available to the attacker.",
          "createdAt": "2020-09-03T21:14:40Z",
          "updatedAt": "2020-09-03T21:14:40Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think we should consider a construction like `Expand(Extract(ServerHello.random[0:24], CHInner.random), \"ech-tag\", 8)`, i.e. to make the tag dependent on the rest of `ServerHello.random`. This would at least partly address @huitema's concern about replays.\r\n\r\nThat doesn't work. The attacker just needs to replay the entire server random. If you want protection you need to mix in the server's key share.\r\n",
          "createdAt": "2020-09-03T21:25:30Z",
          "updatedAt": "2020-09-03T21:25:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc \r\n\r\n> These attacks aren't part of our core threat model, but it seems like we have an opportunity to defeat some or all of them at low cost, so I think we should consider doing so.\r\n\r\nIf we're going to go down this road, then I think we need to take a step back and think about our \"don't stick out\" threat model in more detail. Currently our requirement is that a **passive observer**, who doesn't know the configuration, is unable distinguish real ECH usage from the \"cover traffic\" provided by clients who \"GREASE\" the ECH extension. The attackers mentioned so far are **active** and may know the config. So let's start here: do we anticipate an attacker this powerful? So far we've mostly been talking about \"don't stick out\" in terms of dumb middleboxes that we don't want ossifying on our extension. The current threat model captures this pretty well, I think. If we want to go for something stronger, then we clearly need to re-think the design of #287 (or decide we shouldn't do it).\r\n\r\nSomething to keep in mind is that indistinguishability of the \"real\" protocol from some \"cover\" protocol is a property that TLS was never designed to have. It seems to me that the task of endowing TLS with some sort of stegonagraphic security property goes way beyond this one extension. It's an interesting and valuable goal, but one that should be addressed in a more general way.\r\n\r\nFor ECH, I think we should focus our efforts on coming up with a design that we feel we can deploy today, and iterate and re-deploy as needed.",
          "createdAt": "2020-09-03T22:55:45Z",
          "updatedAt": "2020-09-04T01:26:35Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @cjpatton that there is value in simplicity. A really stealthy ESNI would be a different design than ECH. ",
          "createdAt": "2020-09-04T03:42:10Z",
          "updatedAt": "2020-09-04T03:42:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 -- ECH is *not* about censorship circumvention, or being stealthy.",
          "createdAt": "2020-09-04T14:35:14Z",
          "updatedAt": "2020-09-04T14:35:14Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood you should maybe expand a bit on that. If you are not trying to defeat *some* form of censorship, then why are you hiding the SNI in the first place?",
          "createdAt": "2020-09-04T15:50:26Z",
          "updatedAt": "2020-09-04T15:50:26Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The problem I'm focusing on is an \"attack\" so trivial it could almost happen by accident.  If a ClientHello is issued twice, verbatim, and elicits two independent ServerHellos, an observer can see whether the last 8 bytes of .Random are the same in both responses.  This might happen sporadically to DTLS or QUIC in some configurations, even without an active attacker.\r\n\r\nThe formula I proposed above avoids this repetition.  If we're going to use a hash, as EKR suggested, this calculation seems like a pretty natural way to do it.\r\n\r\nI definitely don't want to slow down progress, and I'm not proposing that we substantially expand our threat model.  I do think closing trivial attacks has some value even if more advanced ones still exist.  For example, the other attacks may be more difficult or less deniable.",
          "createdAt": "2020-09-04T16:03:36Z",
          "updatedAt": "2020-09-04T16:04:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood you should maybe expand a bit on that. If you are not trying to defeat some form of censorship, then why are you hiding the SNI in the first place?\r\n\r\nCensorship is, for example, active blocking of a connection based on the name, whereas ECH hides SNI (and other things) from those that just passively snoop and try to learn about clients.",
          "createdAt": "2020-09-04T16:05:31Z",
          "updatedAt": "2020-09-04T16:05:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "EDITED TO FIX PROPOSAL 3.\r\n\r\n@bemasc \r\n\r\n> The problem I'm focusing on is an \"attack\" so trivial it could almost happen by accident.\r\n\r\nI agree that it would be worth mitigating this attack, as long as the mechanism isn't too complicated. Let's consider the \"replay protection\" properties of the current proposals. Suppose the attacker wants to learn if a client offered ECH, so it replays the ClientHelloOuter to the server. Here are the proposals (please chime in if I got this wrong!)\r\n\r\n1. current proposal: `accept_confirmation = getrandom(8)`\r\n2. @ekr proposes: `accept_confirmation = Hash(ClientHelloInner.random)`\r\n3. @bemasc proposes: `accept_confirmation = Hash(ServerHello.random[0:24] + ClientHelloInner.random)`\r\n\r\nwhere `Hash` is something like `Expand(Extract( . , some_salt), some_info, 8)`. (Though since the ikm is a random string, I think it would suffice to just call `Extract( . , some_info, 8)`.)\r\n\r\nNeither 1 nor 2 mitigates the attack, but 3 does. All options \"stick out\" the same if the ClientHelloInner is known, e.g., if the adversary is on-path from the client-facing server to the backend server. \r\n\r\nIncidentally, proposals 2 and 3 are an improvement over 1 since we don't have to send an extension in the ClientHelloInner. On the down side, the backend server needs to know how to instantiate `Hash`, i.e., it needs to know the HPKE cipher suite. We could get around this by using the hash from the TLS cipher suite.",
          "createdAt": "2020-09-04T16:36:55Z",
          "updatedAt": "2020-09-04T16:43:26Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton In this shorthand, my proposal is more like `Hash(ServerHello.random[0:24], ClientHelloInner.random)`.  This avoids the leak that you identified.",
          "createdAt": "2020-09-04T16:40:29Z",
          "updatedAt": "2020-09-04T16:40:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, you're right. My apologies! Fixing above.",
          "createdAt": "2020-09-04T16:41:37Z",
          "updatedAt": "2020-09-04T16:41:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd be fine with 2 or 3, though we should use the TLS cipher suite instead of the HPKE cipher suite so that the backend server doesn't need to know the latter.",
          "createdAt": "2020-09-04T16:44:26Z",
          "updatedAt": "2020-09-04T16:44:26Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc proposes `accept_confirmation = Hash(ServerHello.random[0:24] + ClientHelloInner.random)`\r\nMy proposal would be: `accept_confirmation = Hash(ServerHello.KeyShare + ClientHelloInner.random))`\r\n\r\nThe rationale is that merely hashing the reminder of the server random is insufficient. The attacker could just do the attack I delineated in issue #287 by copying the whole `ServerHello.random[0:32]` instead of just copying `ServerHello.random[24:32]`. But if you mix the server key share in the hash, then the attacker cannot do that without also copying a key share for which the private key is unknown.",
          "createdAt": "2020-09-04T17:22:43Z",
          "updatedAt": "2020-09-04T17:22:43Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "EDITED AFTER DISCUSSION WITH @chris-wood\r\n\r\nRoger that. Here's what we have on the table:\r\n\r\n1. current: `accept_confirmation = getrandom(8)`\r\n1. @ekr: `accept_confirmation = PRF(ClientHelloInner.random, \"\")`\r\n1. @bemasc: `accept_confirmation = PRF(ClientHelloInner.random, ServerHello.random[0:24])`\r\n1. @huitema: `accept_confirmation = PRF(ClientHelloInner.random, ServerHello.KeyShare)`\r\n\r\nLet's instantiate `PRF( . , . )` with `Expand( . , . , 8)`, where `Expand` is for the TLS cipher suite (and not HPKE). Proposal 1 and 2 are for the status-quo threat model, i.e., the \"don't stick out\" distinguisher is passive; proposal 3 provides additional \"don't stick out\" protection in case the CH is replayed; and proposal 4 improves on 3 by providing some protection against manipulation of the SH.\r\n\r\nMy preference is proposal 2, since it simplifies the extension. I would be fine with 3 or 4, though I'm not convinced that either fully addresses the stronger threat model. ",
          "createdAt": "2020-09-04T18:00:55Z",
          "updatedAt": "2020-09-04T18:16:42Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm, on second thought I'm not so sure how much simpler 2 is than 1. The ClientHelloInner would still have to carry some sort of indication of ECH acceptance so that the backend server knows to confirm. But an empty \"encrypted_client_hello\" extension (or maybe a new code point?) would do just fine.\r\n\r\nSomething weird about 4 is that the backend server has to wait to finish the ServerHello.random until it generates a key share. This might add a bit of complexity, though it depends on the code base.",
          "createdAt": "2020-09-04T18:25:15Z",
          "updatedAt": "2020-09-04T18:27:07Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton Yes, incorporating the key share is more complex. But let's look at what we are doing, replacing trial decryption by a hint. Trial decryption generates complexity, especially in the QUIC mapping, but the result is unambiguous and hard to fool. The client knows for sure whether the key was generated from the inner CH or the outer CH, and it is very hard for third parties to partially fool the client. The hint introduces another failure mode, i.e. wrong hint value, and I believe it can be exploited. For protection, the code has to be almost as hard to fool as trial decryption. That's what I am trying to achieve by incorporating the server key share in the mix.\r\n\r\nThere are of course implementation issues. The server has to know what key share it will use before generating `Server.Random`. That may or may not be easy to do, depending on implementation. The `KeyShareEntry` value do not depend on the `Server.Random` value, so this is definitely possible. But the code path depends on the implementation, and it may be more difficult for some stacks than for others.",
          "createdAt": "2020-09-04T19:23:06Z",
          "updatedAt": "2020-09-04T19:23:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "HI all, I added a commit to #287 that implements @bemasc's suggestion. Specifically, `accept_confirmation` (i.e., the last 8 bytes of `ServerHello.random` is computed as \r\n~~~~\r\n    HKDF-Expand-Label(\r\n        HKDF-Extract(0, ClientHello.random),\r\n        \"tls13-ech-accept-confirm\",\r\n        ServerHello.random[0:24],\r\n        8\r\n    )\r\n~~~~\r\nwhere HKDF-Extract and HKDF-Expand-Label are as defined in RFC8446. Doing Extract-then-Expand ensures that we don't run into any issues with the length of the ClientHello.random not matching the Hash.length in the TLS stack.\r\n\r\nPlease have a look to make sure it's spelled correctly.",
          "createdAt": "2020-09-08T21:18:21Z",
          "updatedAt": "2020-09-08T21:18:21Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`HKDF-Expand-Label` adds a \"tls13 \" prefix to the label, so I think you can shorten the label.\r\n\r\nI agree, we need `HKDF-Extract()` for `Hash.length > 32` (e.g. SHA-512).  Given the need for `HKDF-Extract()`, it would seem more natural to me to put `ServerHello.random[0:24]` in the extraction salt, and use `HKDF-Expand` instead of `HKDF-Expand-Label`.",
          "createdAt": "2020-09-08T22:13:09Z",
          "updatedAt": "2020-09-08T22:13:09Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc \r\n\r\n> `HKDF-Expand-Label` adds a \"tls13 \" prefix to the label, so I think you can shorten the label.\r\n\r\nGood call! Fixing. This reminds me that we need to do a pass of the spec to ensure all the constants have the same structure.\r\n\r\n> Given the need for `HKDF-Extract()`, it would seem more natural to me to put `ServerHello.random[0:24]` in the extraction salt, ...\r\n\r\nI disagree. In any case, the salt being Hash.length bytes long avoids indifferentiability issues [1].\r\n\r\n> ... and use `HKDF-Expand` instead of `HKDF-Expand-Label`.\r\n\r\nWhat does this buy us?\r\n\r\n[1] https://ieeexplore.ieee.org/document/8806752\r\n\r\n\r\n",
          "createdAt": "2020-09-08T23:37:04Z",
          "updatedAt": "2020-09-08T23:37:04Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not familiar with that paper, but Section 4.3 seems to say that HKDF is suitably indifferentiable without any such restriction on the salt length.\r\n\r\nUsing HKDF-Expand instead of HKDF-Expand-Label would seem to make use of fewer, better-analyzed constructions, but I'm not aware of a practical difference, so if HKDF-Expand-Label is more convenient to implement for some reason then that seems like enough justification.",
          "createdAt": "2020-09-09T00:13:46Z",
          "updatedAt": "2020-09-09T00:13:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm not familiar with that paper, but Section 4.3 seems to say that HKDF is suitably indifferentiable without any such restriction on the salt length.\r\n\r\nThere are many \"safe\" salt lengths. I'm not sure 24 is \"safe\", but I know Hash.length is.\r\n\r\n> Using HKDF-Expand instead of HKDF-Expand-Label would seem to make use of fewer, better-analyzed constructions, but I'm not aware of a practical difference, so if HKDF-Expand-Label is more convenient to implement for some reason then that seems like enough justification.\r\n\r\nI don't think one is any harder than the other. The only difference between them is that `HKDF-Expand-Label` exposes an additional `context` parameter, which I think aligns a bit better with what we're doing here.\r\n\r\nIf you'd like to keep pushing for these changes, then please follow up by making a comment on the PR.\r\n\r\n",
          "createdAt": "2020-09-09T00:46:12Z",
          "updatedAt": "2020-09-09T00:46:12Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I appreciate the safety concerns, but you are going to extract an 8 bytes hint from the hash. That's a serious step down from 32 or even 16 bytes, and with such a short length I would be really surprised if two different hash constructs resulted in any security difference!",
          "createdAt": "2020-09-09T01:05:12Z",
          "updatedAt": "2020-09-09T01:05:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hahaha, yeah. We need the 8 bytes to be pseudorandom, and I think the current design is defensible from a provable security perspective. We may be able to do a bit better. What do you think of this, @bemasc?\r\n~~~\r\n    accept_confirmation = HKDF-Extract(ServerHello.random[0:24] + 0^{Hash.len-24}, ClientHello.random)[0:8]\r\n~~~\r\nThis is valid as long as Hash.len >= 24, which I believe is guaranteed by RFC8446.",
          "createdAt": "2020-09-09T15:25:00Z",
          "updatedAt": "2020-09-09T15:26:03Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's fine with me, although I'm not sure why you need to pad the salt.  (HKDF-Extract will pad it for you.)",
          "createdAt": "2020-09-09T16:59:30Z",
          "updatedAt": "2020-09-09T16:59:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  (HKDF-Extract will pad it for you.)\r\n\r\nRoger that.\r\n\r\nAre you happy with this @huitema?\r\n",
          "createdAt": "2020-09-09T17:14:08Z",
          "updatedAt": "2020-09-09T17:14:08Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> (HKDF-Extract will pad it for you.)\r\n\r\nHmm, looking at RFC5869, it's not clear to me that the salt is padded by this function. I think I prefer the following:\r\n```\r\n     accept_confirmation = HKDF-Extract(0, ClientHelloInner.random + ServerHello.random[0:24])[0:8]\r\n```\r\n\r\n",
          "createdAt": "2020-09-09T18:37:44Z",
          "updatedAt": "2020-09-09T18:37:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated #287 with this change.",
          "createdAt": "2020-09-09T18:52:10Z",
          "updatedAt": "2020-09-09T18:52:10Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that's a fine implementation of the suggestion made by @bemasc . I am waiting for the resolution of the \"don't stick out\" issue on the TLS mailing list.",
          "createdAt": "2020-09-09T20:08:39Z",
          "updatedAt": "2020-09-09T20:08:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The decision in today's interim meeting is to merge #287 as-is and reconsider the \"don't stick out\" threat model later on. In particular, we won't be adopting Karthik's suggestion from the mailing list for this PR. @ekr also pointed out that it could be done as an ECH extension.",
          "createdAt": "2020-09-21T18:09:24Z",
          "updatedAt": "2020-09-21T18:09:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing now that #287 landed.",
          "createdAt": "2020-09-22T21:10:35Z",
          "updatedAt": "2020-09-22T21:10:35Z"
        }
      ]
    },
    {
      "number": 275,
      "id": "MDU6SXNzdWU2ODA1NjUyMTY=",
      "title": "s/Hkpe/Hpke/?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/275",
      "state": "CLOSED",
      "author": "cbartle891",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Are these typos or is there some reason HkpeKemId, HkpeKdfId, and HkpeAeadId should be \"Hkpe\" instead of \"Hpke\"? I don't see \"Hkpe\" anywhere in the cited draft.\r\n\r\n```\r\nuint16 HkpeKemId;  // Defined in I-D.irtf-cfrg-hpke\r\nuint16 HkpeKdfId;  // Defined in I-D.irtf-cfrg-hpke\r\nuint16 HkpeAeadId; // Defined in I-D.irtf-cfrg-hpke\r\n```",
      "createdAt": "2020-08-17T22:34:31Z",
      "updatedAt": "2020-08-18T03:55:05Z",
      "closedAt": "2020-08-18T03:55:05Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep -- typo! Can you please send a PR to fix them?",
          "createdAt": "2020-08-17T23:15:56Z",
          "updatedAt": "2020-08-17T23:15:56Z"
        }
      ]
    },
    {
      "number": 278,
      "id": "MDU6SXNzdWU2ODEzMzg4MDA=",
      "title": "Computation of `config_digest`: which KDF?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/278",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The `config_digest` field is defined as;\r\n> A cryptographic hash of the ECHConfig structure from which the ECH key was obtained, i.e., from the first byte of \"version\" to the end of the structure. This hash is computed using the hash function associated with cipher_suite, i.e., the corresponding HPKE KDF algorithm hash.\r\n\r\nBut the `ECHConfig` structure in draft-07 specifies a list of KDF/AEAD pairs. So which KDF is used to compute `config_digest`? The client is supposed to ignore any KDF/AEAD it doesn't support, so it's not clear how a client and server who need to negotiate the cipher suite can compute `config_digest` correctly.",
      "createdAt": "2020-08-18T20:59:39Z",
      "updatedAt": "2020-08-30T15:35:17Z",
      "closedAt": "2020-08-30T15:35:17Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One way to solve this problem is to only allow one cipher suite per ECH configuration.",
          "createdAt": "2020-08-18T21:00:07Z",
          "updatedAt": "2020-08-18T21:00:07Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think one cipher suite per ECH configuration is a step too far in flattening. While juggling lots of KEM algorithms is unlikely (we basically have one correct answer right now, and each KEM algorithm is another long-lived key to manage), cipher suites are easier to shuffle and there are multiple correct answers depending on hardware capabilities. Whether AES-GCM and ChaCha20-Poly1305 is preferred is complex.\r\n\r\nPerhaps we use KDF associated with the KEM instead?",
          "createdAt": "2020-08-18T21:57:02Z",
          "updatedAt": "2020-08-18T21:57:02Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm, doesn't the cipher suite list indicate a set of KDFs that MAY be used with the KEM? In other words, if there's a KDF associated with the KEM, then why would we allow multiple KDFs?",
          "createdAt": "2020-08-18T22:13:24Z",
          "updatedAt": "2020-08-18T22:13:24Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah hrm. I had thought the KEM had a KDF associated, but looks like that's not quite right. The KEM interface does not, but the DHKEM happens to internally use a KDF, which may or may not be the same as the HPKE-level one.",
          "createdAt": "2020-08-18T23:04:49Z",
          "updatedAt": "2020-08-18T23:04:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Right -- KEMs might not have KDFs associated with them. I think we should just use the KDF that the client picks when encrypting the ClientHello:\r\n\r\n~~~\r\n    struct {\r\n       HpkeCipherSuite cipher_suite; // <--- the KDF specified here...\r\n       opaque config_digest<0..2^16-1>; // <--- ... is used to compute this value\r\n       opaque enc<1..2^16-1>;\r\n       opaque encrypted_ch<1..2^16-1>;\r\n    } ClientEncryptedCH;\r\n~~~\r\n\r\nIt's fine that the ECHConfig has a list of KDFs. The client picks only one and tells the server which one. And I think it's reasonable for the server to be able to compute the `config_digest` (or whatever we rename it to be) with the KDF of the client's choosing.",
          "createdAt": "2020-08-19T12:43:05Z",
          "updatedAt": "2020-08-19T12:43:05Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's workable, although it does lead to a bit of a combinatorial explosion. Suppose the server has two ECH configurations, `config1` and `config`, each supporting HKDF-SHA256 and HKDF-SHA256 for the KDF, but only AES-GCM for the AEAD. To avoid trial hashing to determine which configuration to use, the server will need to store a data structure like this:\r\n```python\r\n{\r\n   config1_digest_hkdf_sha256_aes_gcm: config1,\r\n   config1_digest_hkdf_sha512_aes_gcm: config1,\r\n   config2_digest_hkdf_sha256_aes_gcm: config2,\r\n   config2_digest_hkdf_sha512_aes_gcm: config2,\r\n}\r\n```\r\n\r\nIn general, if there N configurations, each supporting k KDFs and e AEADs, then there are N * k * e entries in this table.\r\n\r\nThat said, I'd be happy with adopting @chris-wood's convention.",
          "createdAt": "2020-08-19T15:09:05Z",
          "updatedAt": "2020-08-19T15:10:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, there's more state on the server, but that seems to be the price of supporting multiple configurations.",
          "createdAt": "2020-08-19T15:30:01Z",
          "updatedAt": "2020-08-19T15:30:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In general, if there N configurations, each supporting k KDFs and e AEADs, then there are N * k * e entries in this table.\r\n\r\nDoes the server need a separate entry for each AEAD, or just each KDF? I thought we were just extracting a hash function out, which would suggest just the KDF. (Unlike AEADs, which need to deal with the mess around AES, I think there's a lot less reason for a server to particularly care about KDF diversity.)",
          "createdAt": "2020-08-19T19:18:31Z",
          "updatedAt": "2020-08-19T19:18:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ohh duh :) It should be N * c, where c is the number of cipher suites.",
          "createdAt": "2020-08-19T19:26:16Z",
          "updatedAt": "2020-08-19T19:26:16Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Shouldn't it be N * h, where h is the number of distinct `HpkeKdfId`s in your `HpkeCipherSuite`s? That is, if you support AES-GCM and ChaCha20-Poly1305, but only pair them with HKDF-SHA256, you only need one hash. Although, looking at ECHConfig again, the association between AEAD and KDF is a purely ECH-level construct. So we could choose to disassociate them and then flatten:\r\n\r\n```\r\n       struct {\r\n           opaque public_name<1..2^16-1>;\r\n\r\n           HpkePublicKey public_key;\r\n           HpkeKemId kem_id;\r\n           HpkeKdfId kdf_id;\r\n           HpkeAeadId aead_ids<2..2^16-2>;\r\n\r\n           uint16 maximum_name_length;\r\n           Extension extensions<0..2^16-1>;\r\n       } ECHConfigContents;\r\n```\r\n\r\nNow there's no multiplication. That said, flattening KDFs but not AEADs assumes you believe that `HpkeKdfId` diversity is rare (personally I'd have been happy just locking all of TLS 1.3 onto HKDF-SHA256 and bumping versions for a KDF swap) while `HpkeAeadId` diversity is meaningful (the AES hardware silliness).",
          "createdAt": "2020-08-19T19:38:13Z",
          "updatedAt": "2020-08-19T20:17:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That's an interesting suggestion. I don't see why one would choose a KDF other than HKDF-SHA-256, at least in the near term. ",
          "createdAt": "2020-08-19T20:09:01Z",
          "updatedAt": "2020-08-19T20:09:01Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, the obvious thing to do in the near term is switch to a KDF that is a little faster than HKDF.\r\n\r\nThe other thing I notice here is that with this change you don't need `config_digest` to be variable-length.",
          "createdAt": "2020-08-20T00:15:29Z",
          "updatedAt": "2020-08-20T00:15:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We don\u2019t yet have any standard KDFs that would fit the bill, do we?",
          "createdAt": "2020-08-20T00:19:11Z",
          "updatedAt": "2020-08-20T00:19:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, but I still carry a flame for getting one.  HKDF is a rock, but it's a heavy one.",
          "createdAt": "2020-08-20T00:30:16Z",
          "updatedAt": "2020-08-20T00:30:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would also like to see alternatives to HKDF. There seem to be a lot of interesting alternatives floating around.",
          "createdAt": "2020-08-20T00:42:46Z",
          "updatedAt": "2020-08-20T00:42:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the resolution to this issue is to keep the spec as is:\r\n\r\n> config_digest                                                                                                               \r\n: Equal to `Expand(Extract(\"\", config), \"ech_config_digest\", Nh)`, where\r\n`config` is the `ECHConfig` structure and `Extract`, `Expand`, and `Nh` are as\r\nspecified by the cipher suite KDF. (Passing the literal `\"\"` as the salt is\r\ninterpreted by `Extract` as no salt being provided.)\r\n \r\nLet's close this issue if there's no objection.",
          "createdAt": "2020-08-26T21:01:44Z",
          "updatedAt": "2020-08-26T21:01:44Z"
        }
      ]
    },
    {
      "number": 280,
      "id": "MDU6SXNzdWU2ODIwMzk4Mzg=",
      "title": "When computing config_digest, use I2OSP on integer values.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/280",
      "state": "CLOSED",
      "author": "kjacobs-moz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`config_digest` is defined as `A cryptographic hash of the ECHConfig structure from which the ECH key was obtained, i.e., from the first byte of \"version\" to the end of the structure.`\r\n\r\nAs the struct contains integer values, those fields should first be normalized with I2OSP. Also, it's probably worth clarifying that the hash is taken over the serialized representation of the struct.",
      "createdAt": "2020-08-19T18:14:44Z",
      "updatedAt": "2020-08-19T18:45:34Z",
      "closedAt": "2020-08-19T18:45:34Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think that's right for a TLS structure. TLS already has well-defined serialization, which is what that structure uses. See https://tools.ietf.org/html/rfc8446#section-3",
          "createdAt": "2020-08-19T18:20:32Z",
          "updatedAt": "2020-08-19T18:20:32Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah - that's right. Coming from HPKE this looked like a gap, but I think it's well-defined in this context. Thanks.",
          "createdAt": "2020-08-19T18:33:25Z",
          "updatedAt": "2020-08-19T18:33:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved. ",
          "createdAt": "2020-08-19T18:45:34Z",
          "updatedAt": "2020-08-19T18:45:34Z"
        }
      ]
    },
    {
      "number": 281,
      "id": "MDU6SXNzdWU2ODIwNDIxNjk=",
      "title": "ServerEncryptedCH: retry_configs vs. retry_keys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/281",
      "state": "CLOSED",
      "author": "kjacobs-moz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The spec uses both `retry_configs` and `retry_keys` when referring to the contents of `ServerEncryptedCH`. These should be made consistent (preferably using the former).",
      "createdAt": "2020-08-19T18:19:05Z",
      "updatedAt": "2020-08-19T22:40:49Z",
      "closedAt": "2020-08-19T22:40:49Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed -- let's unify around `retry_configs`! Would you be able to propose text?",
          "createdAt": "2020-08-19T18:45:58Z",
          "updatedAt": "2020-08-19T18:46:11Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(`retry_keys` is a remnant of the old `ESNIKeys` name. I guess we missed a few.)",
          "createdAt": "2020-08-19T18:48:20Z",
          "updatedAt": "2020-08-19T18:48:20Z"
        }
      ]
    },
    {
      "number": 284,
      "id": "MDU6SXNzdWU2ODU1OTI5NTY=",
      "title": "Section number levels",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/284",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Purely editorial, but the layout of the TOC is a bit confusing....\r\n\r\n> 1.  Introduction\r\n> 2.  Conventions and Definitions\r\n> 3.  Overview\r\n> 3.1.  Topologies\r\n> 3.2.  Encrypted ClientHello (ECH)\r\n> 4.  Encrypted ClientHello Configuration\r\n> 4.1.  Configuration Extensions\r\n> 5.  The \"encrypted_client_hello\" extension\r\n> 6.  The \"ech_nonce\" extension\r\n> 6.1.  Incorporating Outer Extensions\r\n\r\nI think all the confusing things about this would be resolved by moving \"encrypted_client_hello\" and \"ech_nonce\" to be subsections of 4.1, instead of top-level sections in their own right.  This would make 6.1 become 4.2, and \"Incorporating Outer Extensions\" does seem like a reasonable sub-section of \"Encrypted ClientHello Configuration\".",
      "createdAt": "2020-08-25T15:42:51Z",
      "updatedAt": "2020-09-23T20:36:37Z",
      "closedAt": "2020-09-23T20:36:37Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The order is much cleaner now. It describes, in order: the ECH configuration details, extension details, client behavior, and then server behavior. @MikeBishop, I'd suggest closing this as resolved. What do you think?\r\n\r\n>   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\r\n>   2.  Conventions and Definitions . . . . . . . . . . . . . . . . .   4\r\n>   3.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   4\r\n>     3.1.  Topologies  . . . . . . . . . . . . . . . . . . . . . . .   4\r\n>     3.2.  Encrypted ClientHello (ECH) . . . . . . . . . . . . . . .   5\r\n>   4.  Encrypted ClientHello Configuration . . . . . . . . . . . . .   7\r\n>     4.1.  Configuration Extensions  . . . . . . . . . . . . . . . .   8\r\n>   5.  The \"encrypted_client_hello\" extension  . . . . . . . . . . .   9\r\n>     5.1.  Incorporating Outer Extensions  . . . . . . . . . . . . .  10\r\n>   6.  Client Behavior . . . . . . . . . . . . . . . . . . . . . . .  11\r\n>     6.1.  Sending an encrypted ClientHello  . . . . . . . . . . . .  11\r\n>     6.2.  Recommended Padding Scheme  . . . . . . . . . . . . . . .  13\r\n>     6.3.  Handling the server response  . . . . . . . . . . . . . .  14\r\n>       6.3.1.  Accepted ECH  . . . . . . . . . . . . . . . . . . . .  14\r\n>       6.3.2.  Rejected ECH  . . . . . . . . . . . . . . . . . . . .  14\r\n>       6.3.3.  HelloRetryRequest . . . . . . . . . . . . . . . . . .  16\r\n>     6.4.  GREASE extensions . . . . . . . . . . . . . . . . . . . .  16\r\n>   7.  Server Behavior . . . . . . . . . . . . . . . . . . . . . . .  17\r\n>     7.1.  Client-Facing Server  . . . . . . . . . . . . . . . . . .  17\r\n>     7.2.  Backend Server Behavior . . . . . . . . . . . . . . . . .  19",
          "createdAt": "2020-09-22T21:30:04Z",
          "updatedAt": "2020-09-22T21:30:04Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "That's probably workable.",
          "createdAt": "2020-09-23T20:36:37Z",
          "updatedAt": "2020-09-23T20:36:37Z"
        }
      ]
    },
    {
      "number": 285,
      "id": "MDU6SXNzdWU2ODU3MTE1MDU=",
      "title": "Possible to simplify interaction with session resumption?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/285",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The current draft contains various rules around ECH and resumption.\r\n\r\n> Per {{client-behavior}} and {{server-behavior}}, implementations are required to track, alongside each PSK established by a previous connection, whether the connection negotiated this extension with the \"ech_accept\" response type. If so, this is referred to as an \"ECH PSK\". Otherwise, it is a \"non-ECH PSK\". This may be implemented by adding a new field to client and server session states.\r\n\r\n> When offering an encrypted ClientHello, the client MUST NOT offer to resume any non-ECH PSKs.\r\n\r\n> If the server resumed a session or negotiated a session that did not use a certificate for authentication, the client MUST abort the connection with an \"illegal_parameter\" alert. This case is invalid because {{send-ech}} requires the client to only offer ECH-established sessions, and {{server-behavior}} requires the server to decline ECH-established sessions if it did not accept ECH.\r\n\r\n> The server MUST ignore all PSK identities in the ClientHello which correspond to ECH PSKs. ECH PSKs offered by the client are associated with the ECH name. The server was unable to decrypt then ECH name, so it should not resume them when using the plaintext SNI name. This restriction allows a client to reject resumptions in {{auth-public-name}}.\r\n\r\n> If the server sends a NewSessionTicket message, the corresponding ECH PSK MUST be ignored by all other servers in the deployment when not negotiating ECH, including servers which do not implement this specification.\r\n\r\nThese rules date to before we started encrypting the entire ClientHello and were intended to avoid mixing up session resumptions between the public and private name, since the same pre_shared_key extension was used for both, and amount to saying implementations must add a boolean to their session state.\r\n\r\nNow that the public and private names correspond to different ClientHellos altogether, the client can (and should) only send inner name tickets in the inner ClientHello and outer name tickets in the outer ClientHello. (#270) I suspect that means we no longer need further ECH special cases here.",
      "createdAt": "2020-08-25T18:52:10Z",
      "updatedAt": "2020-10-07T23:00:44Z",
      "closedAt": "2020-10-07T23:00:44Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a good simplification, but we should probably be careful about the interaction with cross-SNI resumption.",
          "createdAt": "2020-08-26T12:44:50Z",
          "updatedAt": "2020-08-26T12:44:50Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it just composes as expected? If you offer a PSK in the outer ClientHello, cross-SNI or no, it means that you are satisfied with it as an alternative to the certificate covering the public name. If you offer a PSK in the inner ClientHello, cross-SNI or no, it means you are satisfied with it as an alternative to the certificate covering the true name. Your ClientHellos should be consistent with this, which means that servers resuming isn't an issue.\r\n\r\nTBH I forgotten some of the details for why this was here. I found this long comment I wrote, but apparently past me was just unsatisfied that a case (4) was \"weird\". So that was very unhelpful, past me. Regardless, I think the ambiguity is moot now.\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/124#discussion_r243055936\r\n\r\n(I also expect clients just won't offer PSKs in the outer ClientHellos. It's unlikely that you'll get any to offer anyway. And if your API has an external session cache, the caller needs to go out of their way to do two lookups.)",
          "createdAt": "2020-08-26T18:29:03Z",
          "updatedAt": "2020-08-26T18:29:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I was thinking about clients that might mistakenly use inner tickets for the outer name when given the cross-SNI signal. (I agree that it composes naturally.) A simple note would probably suffice. \r\n\r\nFor outer tickets, I tend to think they should just be discouraged. What's the benefit of resuming a TLS 1.3 connection you'd tear down anyway?",
          "createdAt": "2020-08-26T23:31:34Z",
          "updatedAt": "2020-08-28T20:39:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I fully understand the (historical) need to distinguish between ECH-PSKs and non-ECH-PSKs. But why would a client offer PSK to a client-facing server at all? In other words, will it ever be useful to send a PSK extension in the ClientHelloOuter? It seems to me that this feature is only meaningful to the intended backend server, and so should only appear in the ClientHelloInner.\r\n\r\nThe same question applies to all other extensions. If the client-facing server terminates the connection, then the only action the client will take is to close the connection. Hence, the only functionality we will ever need for the client<->client-facing server connection is to complete a full, server-authenticated handshake. If I were implementing the client, I would restrict the contents of the ClientHelloOuter to only those extensions that are necessary to implement this functionality. I wonder if it makes sense to enforce this in the spec. Something like: \"When offering the 'ech' extension, the client MAY include the following extensions in the ClientHelloOuter: 'supported_versions', 'server_name'. 'key_shares', 'signature_algorithms', [and so on]. It MUST NOT include any other extension.\"\r\n\r\nWhat are the downsides to doing something like this? I think the upside is that it simplifies the problem of deciding what to put in the ClientHelloInner versus the ClientHelloOuter. I suppose one downside is that it potentially sticks out a bit.",
          "createdAt": "2020-08-28T20:33:29Z",
          "updatedAt": "2020-08-28T20:35:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on this week's interim, we decided it was fine to prohibit PSKs in the outer CH for ECH connections, so the current draft text prohibits \"pre_shared_key\" extensions in the outer CH. A connection using GREASE may, however, decide to resume its connection to the outer name. This gives a passive adversary a pretty easy distinguisher between GREASE and non-GREASE: if there's a ticket present, the connection is definitely GREASE. \r\n\r\nIt *seems* that if we want to maintain our current indistinguishability properties, there always needs to be some ticket. So perhaps that means:\r\n\r\n- ECH (non-GREASE) clients would generate a bogus (GREASEd) ticket\r\n- GREASE clients that don't have a ticket would generate a bogus ticket\r\n- GREASE clients that have a ticket would use it\r\n\r\n@davidben, @ghedo, @ekr, @martinthomson, @cjpatton: penny for your thoughts?",
          "createdAt": "2020-09-22T21:53:13Z",
          "updatedAt": "2020-09-22T21:53:13Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I mostly figure there won't be a ticket in the initial connection to a server, or any connections made after long time, so intolerance to ticket-less ClientHellos will likely be noticed quickly. Though it is true that probably a lot of connections offer tickets.\r\n\r\nThere may be something to be said for allowing clients to send bogus tickets if they want, but it's worth noting an active attacker can tell if the ticket is (most likely) bogus by simply trying to resume it.\r\n\r\n(A tangent: we actually saw a very old TLS 1.0 server implementation that broke with TLS 1.3 because it would take the client's session IDs and unconditionally echo it back. I'm not sure what was going on there. It didn't actually switch to a resumption handshake or implement resumption at all. It just echoed back the session ID for some reason. Only reason this didn't break before was that it never issued session IDs, so this codepath had never been tested before.)",
          "createdAt": "2020-09-22T22:02:05Z",
          "updatedAt": "2020-09-22T22:02:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> There may be something to be said for allowing clients to send bogus tickets if they want, but it's worth noting an active attacker can tell if the ticket is (most likely) bogus by simply trying to resume it.\r\n\r\nTrue, but that's already the case for active attackers. What I'm concerned about are passive attackers. ",
          "createdAt": "2020-09-22T22:03:49Z",
          "updatedAt": "2020-09-22T22:03:49Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this gets at a larger \"don't stick out\" problem currently only addressed in bits and pieces. Just as dummy (i.e., greased) ECH is used to provide covertext for real ECH, real-ECH connections also need to provide covertext for the real extensions offered in dummy-ECH connections. In particular, the spec should provide guidance on how to generate dummy extensions in the ClientHelloOuter.",
          "createdAt": "2020-09-22T22:33:46Z",
          "updatedAt": "2020-09-22T22:33:46Z"
        }
      ]
    },
    {
      "number": 288,
      "id": "MDU6SXNzdWU2ODYyODgxMDI=",
      "title": "config_digest doesn't need to be 2^16-1 bytes long",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/288",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "It's bound by the size o the HPKE KDF output size, which is unlikely to be larger than 32B. Let's make this:\r\n\r\n~~~\r\n       opaque config_digest<0..2^8-1>;\r\n~~~",
      "createdAt": "2020-08-26T12:42:25Z",
      "updatedAt": "2020-09-02T20:48:24Z",
      "closedAt": "2020-09-02T20:48:24Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should also add a requirement for the HPKE ciphersuite. E.g., 'Nh <= 2^8`.",
          "createdAt": "2020-08-26T20:41:21Z",
          "updatedAt": "2020-08-26T20:41:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Careful with fenceposts: `Nh < 2^8`.)\r\n\r\nIf config_digest is the output of a KDF, why could you not fix the length to something that is enough to avoid collisions (16 bytes seems ample for this) and not worry about Nh at all?",
          "createdAt": "2020-08-26T22:45:06Z",
          "updatedAt": "2020-08-26T22:45:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If config_digest is the output of a KDF, why could you not fix the length to something that is enough to avoid collisions (16 bytes seems ample for this) and not worry about Nh at all?\r\n\r\nI think it makes sense to let the KDF dictate the security level, i.e., the collision probability of the config_digest.",
          "createdAt": "2020-08-27T01:13:01Z",
          "updatedAt": "2020-08-27T01:13:01Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would argue that collision probability here doesn't contribute to security.  If a config is misidentified, the result will be failure, not a reduction in security.  A failure either because the group doesn't match or because peers end up disagreeing on keys.",
          "createdAt": "2020-08-27T03:48:08Z",
          "updatedAt": "2020-08-27T03:48:08Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True that it's an operational consideration rather than a security one. I still think it makes sense to let the length of `config_digest` be dictated by the KDF, since whether truncation is an operational risk depends on the KDF.",
          "createdAt": "2020-08-27T22:55:04Z",
          "updatedAt": "2020-08-27T22:55:04Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I assume here that a KDF is capable of producing uniform random bytes of arbitrary length, meaning that truncation isn't a factor.  That's what `L` is for, right?",
          "createdAt": "2020-08-27T23:32:22Z",
          "updatedAt": "2020-08-27T23:32:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That assumption holds if the input has sufficient entropy. Since the public key is public, there's no entropy from the point of view of an adversary who wants to distinguish the output from random.",
          "createdAt": "2020-08-28T00:40:19Z",
          "updatedAt": "2020-08-28T00:40:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(To be clear, I think truncating to something reasonable, like 16 bytes, is low risk. I would be fine with doing this.)",
          "createdAt": "2020-08-28T00:53:15Z",
          "updatedAt": "2020-08-28T00:53:15Z"
        }
      ]
    },
    {
      "number": 289,
      "id": "MDU6SXNzdWU2ODc1OTE0ODQ=",
      "title": "Rejecting ECH for unrecognized backend servers",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/289",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The client-facing server should not attempt to accept ECH on behalf of backend servers it doesn't recognize. For example, suppose a client attempts to connect to \"example.com\" via an ECH-service provider named \"ech-provider.com\", but \"example.com\" has not authorized \"ech-provider.com\" to accept ECH on its behalf. What should the client-facing server do in this case? It could reject ECH, but this action alone doesn't convey the reason ECH was rejected. The reason is important here because the client might not know that \"example.com\" is unreachable via  \"ech-provider.com\".\r\n\r\n@Lekensteyn proposed adding the following behavior to \"Client-Facing Server Behavior\":\r\n\r\n> If the client-facing server does not have the authority to accept ECH on the backend server's behalf, e.g., it does not recognize the value of the \"server_name\" extension sent in the ClientHelloInner, then it SHOULD abort the handshake with an \"unrecognized_name\" alert.\r\n\r\nThis alert is appropriate because the situation is akin to the server getting a plaintext SNI for which it is not authoritative. I think \"SHOULD\" is more appropriate than \"MUST\" because what it means for the client-facing server to \"have the authority to accept ECH on behalf of the backend server\" is deployment-dependent. In the CDN case it's quite clear what this means: the client-facing server is only authoritative for websites on its platform. But other use cases are less clear.\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2020-08-27T22:50:07Z",
      "updatedAt": "2020-09-18T21:35:22Z",
      "closedAt": "2020-09-18T21:35:21Z",
      "comments": [
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "By \"authority\" I meant that the backend is not able to produce a certificate to serve the requested name in SNI (either plaintext or in encrypted form). (The difference between shared and split mode is not important for this logical distinction between \"client-facing server\" and \"backend server\".)\r\n\r\nSome more context on why rejection is not appropriate. Given a CH with the ECH extension, the server can act in some ways (based on Section 3.2):\r\n\r\n1. ECH not supported by client-facing server. Proceed as usual.\r\n2. \"ECH rejection\"\r\n   a. No ECHConfig was found for the given `config_digest`. The client-facing server rejects and sends a `retry_configs` extension.\r\n   b. A valid ECHConfig was found, but decryption fails. Server aborts with a `decrypt_error` alert. (Note an ambiguity on \"decryption failure\" - I filed #290 for that.)\r\n3. \"ECH acceptance\"\r\n  a. A valid ECHConfig was found, and the backend is authoritative for the decrypted SNI. Client-facing server accepts.\r\n  b. A valid ECHConfig was found, and the backend is not authoritative for the decrypted SNI. (This issue.)\r\n\r\nIn case (3b), rejecting as is done in (2a) is wrong because the next retried connection will fail similarly.\r\n\r\nIn the current specification, the decrypted CH is forwarded to the backend and is treated as \"ECH acceptance\". The backend could subsequently send an \"unrecognized_name\" alert instead of the Server Hello, send a default self-signed certificate, etc. Whether the backend is authoritative is invisible to the client-facing server.\r\n\r\nHowever if #283 gets implemented, ECH confirmation will be explicit and requires backend cooperation. This is not possible if the backend sends an alert before the Server Hello. Rejection on the other hand is also not valid for the reason mentioned before. Hence the explicit suggestion for an alert.\r\n\r\n\r\n",
          "createdAt": "2020-08-28T09:48:32Z",
          "updatedAt": "2020-08-28T09:48:32Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there a reason the behavior for an unknown encrypted server name needs to be different from seeing an unknown public server name? I would have expected the ECH logic, after decrypting the inner ClientHello, just passes it along to the same ClientHello dispatching logic as usual.\r\n\r\nThat is, the text in https://tools.ietf.org/html/rfc6066#section-3 which recommends either `unrecognized_name` or continuing with I guess a default backend. I'm not entirely sure why folks continue with default backend when the client has explicitly told you what name it wants, but whatever.\r\n\r\nIn particular, I expect TLS implementations which expose a callback for selecting certificates will just call the callback with the inner ClientHello information, and let the application continue with whatever it normally wants. That way adopting ECH requires fewer changes to server software.",
          "createdAt": "2020-08-28T20:11:49Z",
          "updatedAt": "2020-08-28T20:11:49Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is there a reason the behavior for an unknown encrypted server name needs to be different from seeing an unknown public server name? I would have expected the ECH logic, after decrypting the inner ClientHello, just passes it along to the same ClientHello dispatching logic as usual.\r\n\r\nNope, these should be treated the same! The semantics of the \"server_name\" extension cover this. Thanks for pointing it out.\r\n\r\n(I'll close this issue once @Lekensteyn has had a chance to chime in.)",
          "createdAt": "2020-08-28T20:43:36Z",
          "updatedAt": "2020-08-28T20:43:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton it might be worth noting that servers ought to treat these two the same. Perhaps we can use this issue to track that?",
          "createdAt": "2020-08-30T15:33:58Z",
          "updatedAt": "2020-08-30T15:33:58Z"
        },
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the TLS stack should treat the unencrypted SNI and successfully decrypted SNI the same way. This could be made explicit if not already, but I still wonder how it interacts with #283 adding changes to the Server Hello (which seems to break Split Mode in any case).\r\n\r\nI would be fine closing this issue (with or without the clarification) and defer this lack of ECH acceptance signal to #283.",
          "createdAt": "2020-09-01T10:11:22Z",
          "updatedAt": "2020-09-01T10:11:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood \r\n\r\n> it might be worth noting that servers ought to treat these two the same.\r\n\r\nI think this is implied by the following paragraph in the spec:\r\n\r\n> Upon determining the true SNI, the client-facing server then either serves the connection directly (if in Shared Mode), in which case it executes the steps in the following section, or forwards the TLS connection to the backend server (if in Split Mode). In the latter case, it does not make any changes to the TLS messages, but just blindly forwards them.\r\n\r\nSo think mentioning this is a bit redundant. I would suggest closing this issue without changing the text.",
          "createdAt": "2020-09-18T21:33:02Z",
          "updatedAt": "2020-09-18T21:33:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, on reflection, you may be right. Closing.",
          "createdAt": "2020-09-18T21:35:21Z",
          "updatedAt": "2020-09-18T21:35:21Z"
        }
      ]
    },
    {
      "number": 290,
      "id": "MDU6SXNzdWU2ODc5NDI4OTU=",
      "title": "What to do on ECH decryption failure?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/290",
      "state": "CLOSED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Two sections suggest to ignore the extension on decryption failure, but one suggests to send an alert. What should happen?\r\n\r\nIgnoring the extension on unrecognized `config_digest` failures sounds reasonable in order to \"not stick out\". However, it is not entirely unambiguous what to do if a valid ECHConfig is found but decryption fails.\r\n\r\n[3.2. Encrypted ClientHello (ECH)](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-3.2) says:\r\n\r\n> Upon receiving the ClientHelloOuter, the client-facing server takes one of the following actions:\r\n> [..]\r\n> 3. If it supports ECH but cannot decrypt it, then it ignores the extension and proceeds with the handshake as usual.\r\n\r\n[7.3.2.1. Authenticating for the public name](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-7.3.2.1) says:\r\n\r\n> When the server cannot decrypt or does not process the \"encrypted_client_hello\" extension, it continues with the handshake using the plaintext \"server_name\" extension instead (see Section 8).\r\n\r\n[8. Client-Facing Server Behavior](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-8) says:\r\n\r\n> If the ClientEncryptedCH value matches a known ECHConfig, the server then decrypts ClientEncryptedCH.encrypted_ch, [..]\r\n> If decryption fails, the server MUST abort the connection with a \"decrypt_error\" alert.",
      "createdAt": "2020-08-28T09:30:56Z",
      "updatedAt": "2020-09-18T21:20:11Z",
      "closedAt": "2020-09-18T21:20:11Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the first two statements apply when the config_digest doesn't correspond to a known ECHConfig (i.e., \"I can't decrypt this\"); the last is when the ECHConfig is known, but decryption fails (\"I should be able to decrypt this, but the ciphertext is invalid\"). The text could be a lot clearer here.",
          "createdAt": "2020-08-28T15:16:13Z",
          "updatedAt": "2020-08-28T15:17:18Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton Yes, your interpretation is correct. I think this is the result of a number of uncoordinated changes.",
          "createdAt": "2020-09-03T14:15:04Z",
          "updatedAt": "2020-09-03T14:15:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved.",
          "createdAt": "2020-09-18T21:20:11Z",
          "updatedAt": "2020-09-18T21:20:11Z"
        }
      ]
    },
    {
      "number": 294,
      "id": "MDU6SXNzdWU2OTA3Mzg1MTk=",
      "title": "Questions about client behavior",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/294",
      "state": "CLOSED",
      "author": "D-Sinus",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Cause I'm quite new to ECH, I'm little bit confused when reading this draft.\r\nSo I want to ask some questions...\r\n\r\nParagraph 7.1. Sending an encrypted ClientHello says...\r\n> pkR = HPKE.KEM.Unmarshal(ECHConfig.public_key)\r\n> enc, context = SetupBaseS(pkR, \"tls13-ech\")\r\n> ech_nonce_value = context.Export(\"tls13-ech-nonce\", 16)\r\n> ech_hrr_key = context.Export(\"tls13-ech-hrr-key\", 16)\r\n\r\nQ1. Is 'Unmarshal()' above equal to general meaning of unmarshalling -get public key from ECHConfig structure- ?\r\nQ2. I think 'hrr' in the fourth line is the abbreviation of 'HelloRetryRequest', is it correct? If so, could you add some explanation about that?",
      "createdAt": "2020-09-02T05:53:02Z",
      "updatedAt": "2020-09-03T13:49:24Z",
      "closedAt": "2020-09-03T13:49:24Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Q1: It should be defined in the HPKE draft, though it looks like the HPKE draft has since renamed it and it should probably say Deserialize now.\r\nhttps://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#name-cryptographic-dependencies\r\n\r\nQ2: hrr is HelloRetryRequest, yes. The use of the key is described later on in the HelloRetryRequest section.\r\nhttps://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-7.3.3",
          "createdAt": "2020-09-02T15:50:55Z",
          "updatedAt": "2020-09-02T15:50:55Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Q1. Is 'Unmarshal()' above equal to general meaning of unmarshalling -get public key from ECHConfig structure- ?\r\n\r\nThe first line appears to be pseudocode for \"interpret `ECHConfig.public_key` as a public key for the KEM algorithm identified by `ECHConfig.kem_id`. IMO we should get rid of this pseudocode and say what `pkR` is.\r\n\r\n> Q2. I think 'hrr' in the fourth line is the abbreviation of 'HelloRetryRequest', is it correct? If so, could you add some explanation about that?\r\n\r\n@davidben beat me to it!",
          "createdAt": "2020-09-02T15:52:33Z",
          "updatedAt": "2020-09-02T15:53:09Z"
        },
        {
          "author": "D-Sinus",
          "authorAssociation": "NONE",
          "body": "Oh, it was Deserialize()... thanks!",
          "createdAt": "2020-09-03T02:05:04Z",
          "updatedAt": "2020-09-03T02:05:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved. ",
          "createdAt": "2020-09-03T13:49:24Z",
          "updatedAt": "2020-09-03T13:49:24Z"
        }
      ]
    },
    {
      "number": 295,
      "id": "MDU6SXNzdWU2OTExMzk0OTg=",
      "title": "Greasing to supporting servers",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/295",
      "state": "CLOSED",
      "author": "wbl",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "@cjpatton and I were sitting down and thinking and we realized the following scenario can happen:\r\n\r\n1. example.com is on hosting.com, which supports ECH\r\n1. example.com has an HTTPS record, an A record, AAAA record pointing at the IP for hosting.com\r\n1. A user of a browsers latest release that supports ECH and greases the extension is using a resolver that doesn't resolve HTTPS records\r\n\r\nThis results in an ECH request being made with SNI=example.com, and a rejection of the ECH. So now the question is what the client should do and what should servers expect?\r\n* Try again, with the outer SNI the one matching the one in the new config\r\n* Use the connection authoritatively for example.com since the connection has already revealed the issue.\r\n\r\n",
      "createdAt": "2020-09-02T15:52:47Z",
      "updatedAt": "2020-10-05T15:28:21Z",
      "closedAt": "2020-10-05T15:28:21Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The intention was the latter, but the text could probably be clearer. I don't think there's much point in trying again since the name has already been revealed. See https://github.com/tlswg/draft-ietf-tls-esni/issues/274#issuecomment-680182501",
          "createdAt": "2020-09-02T15:57:46Z",
          "updatedAt": "2020-09-02T15:57:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@wbl is this still an issue now that #287 is merged?",
          "createdAt": "2020-09-22T21:30:41Z",
          "updatedAt": "2020-09-22T21:30:41Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "NONE",
          "body": "I think the client behavior remains equally unspecified. In particular the lengthy argument @cjpatton and I had about server enforcement of the client behavior I think isn't changed.",
          "createdAt": "2020-09-22T22:23:42Z",
          "updatedAt": "2020-09-22T22:23:42Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Care to file a PR, presuming the latter behavior is intended?",
          "createdAt": "2020-09-22T22:36:18Z",
          "updatedAt": "2020-09-22T22:36:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A proposed resolution is here: #319.",
          "createdAt": "2020-10-01T01:26:41Z",
          "updatedAt": "2020-10-01T01:26:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@wbl, a proposed fix has been merged. See #321.",
          "createdAt": "2020-10-01T17:38:21Z",
          "updatedAt": "2020-10-01T17:38:21Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "NONE",
          "body": "I think this text works.",
          "createdAt": "2020-10-05T15:28:19Z",
          "updatedAt": "2020-10-05T15:28:19Z"
        }
      ]
    },
    {
      "number": 297,
      "id": "MDU6SXNzdWU2OTEzMzQ0ODQ=",
      "title": "Proposal: Add version indication to ClientEncryptedCH",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/297",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The ECH version is negotiated as follows: the server indicates which versions of ECH it supports by advertising a configuration for each supported version, and the client selects the version by selecting a configuration. The selected configuration is currently indicated by `ClientEncryptedCH.config_digest`.\r\n\r\nThe `ClientEncryptedCH` structure is defined as follows:\r\n```\r\n      struct {\r\n          HpkeCipherSuite suite;\r\n          opaque config_digest<0..2^16-1>;\r\n          opaque enc<1..2^16-1>;\r\n          opaque encrypted_ch<1..2^16-1>;\r\n      } ClientEncryptedCH;\r\n```\r\n\r\nBecause the negotiated version is determined by the configuration, future versions of ECH that change the structure of `ClientEncryptedCH` --- in particular, the way the selected configuration is indicated--- will break backwards compatibility. Therefore, I would like to propose adding the ECH version to to this structure.",
      "createdAt": "2020-09-02T18:54:50Z",
      "updatedAt": "2020-09-18T21:32:49Z",
      "closedAt": "2020-09-18T21:32:49Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh nice catch. I agree that the versioning scheme doesn't work here, though our experience adding extension points inside extension points has not been good. Implementations keep messing them up and we lose the extension point anyway. (\"Have one joint and keep it well-oiled.\")\r\n\r\nDo we actually need the versioning scheme after the draft is done? If it weren't for the SVCB code point, I would say we should simply pick different extension code points for each deployed draft. But perhaps we should just do that for the SVCB code point too? If we did that, would we need versions in the first place?",
          "createdAt": "2020-09-02T19:00:38Z",
          "updatedAt": "2020-09-02T19:00:38Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, strictly speaking they will only do so if they break the first two fields, right? Because the rest can be conditioned on the config_digest.",
          "createdAt": "2020-09-03T14:13:28Z",
          "updatedAt": "2020-09-03T14:13:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True, but to @davidben's point, I wonder if versioning ECHConfigContents is necessary. Would it be sufficient to update the code point for the draft whenever this changes?",
          "createdAt": "2020-09-03T14:41:41Z",
          "updatedAt": "2020-09-03T15:31:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Unless we advertise the version here, we're committing to the first two fields being the same in future versions. Unless we anticipate these changing, let's stick with the status quo.",
          "createdAt": "2020-09-03T18:04:37Z",
          "updatedAt": "2020-09-03T18:04:37Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Each HPKE suite has a fixed-length key encapsulation (`Nenc`), so the length field of `enc` is redundant.  If we concatenate `enc` and `encrypted_ch` into a single opaque field, that might be more future-proof.",
          "createdAt": "2020-09-04T17:01:18Z",
          "updatedAt": "2020-09-04T17:01:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see how that helps, since the fields that can't change are cipher_suties and config_id.",
          "createdAt": "2020-09-04T17:10:36Z",
          "updatedAt": "2020-09-04T17:10:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "By way of addressing this issue, I've created a PR that \"locks\" ECHConfig.version to the extension code point. https://github.com/tlswg/draft-ietf-tls-esni/pull/303\r\n\r\nThis provides an unambiguous signal of which version of ECH is selected by the client.",
          "createdAt": "2020-09-18T21:22:37Z",
          "updatedAt": "2020-09-18T21:22:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure the choice of code point (ff08) is available. I picked it because it reflects the next draft (08).",
          "createdAt": "2020-09-18T21:23:22Z",
          "updatedAt": "2020-09-18T21:23:22Z"
        }
      ]
    },
    {
      "number": 300,
      "id": "MDU6SXNzdWU2OTM1OTkwNjI=",
      "title": "Proposal: remove 'length' field from ECHConfig",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/300",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current structure is:\r\n```\r\n    struct {\r\n        uint16 version;\r\n        uint16 length;\r\n        select (ECHConfig.version) {\r\n          case 0xff07: ECHConfigContents;\r\n        }\r\n    } ECHConfig;\r\n```\r\n\r\nThe length is meant to indicate the length the (unnamed) field that follows it. But because we know how to parse the remainder of the structure based on the version, this field doesn't seem necessary to me. I'd like to suggest we drop it.\r\n```\r\n    struct {\r\n        uint16 version;\r\n        select (ECHConfig.version) {\r\n          case 0xff08: ECHConfigContents contents;\r\n        }\r\n    } ECHConfig;\r\n```\r\n\r\nNote that I've also advanced the version number and named the last field `contents`.",
      "createdAt": "2020-09-04T20:38:57Z",
      "updatedAt": "2020-09-10T12:11:27Z",
      "closedAt": "2020-09-10T12:11:27Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The length field is necessary for an ECHConfigs (what actually goes in DNS) to be parsable. Otherwise you don't know how to skip over configs you don't recognize.\r\n\r\n```\r\n  ECHConfig ECHConfigs<1..2^16-1>;\r\n```\r\n\r\nIf we got rid of it, we'd need to switch to allocating separate SVCB code points per version, at which point the ECH-level versioning should go away altogether. (Which I would actually be in favor of, but I think people didn't like the idea of allocating SVCB code points every time we want to do a deployment snapshot or otherwise change the wire format.)",
          "createdAt": "2020-09-05T00:00:44Z",
          "updatedAt": "2020-09-05T00:00:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The length field is necessary for an ECHConfigs (what actually goes in DNS) to be parsable.\r\n\r\nWell, the version effectively determines the length of the next ECHConfig in the ECHConfigs, right? \r\n\r\nEDIT: What's weird about the current design is that to read the next config in the ECHConfigs, you have to first inspect the version, then you determine the length of the remainder. The length field is redundant, since the version is determines the length.\r\n\r\n> ... , at which point the ECH-level versioning should go away altogether. \r\n\r\nI'm in favor of keeping the version field in the ECHConfig, as this will make our deployment easier.",
          "createdAt": "2020-09-08T17:04:07Z",
          "updatedAt": "2020-09-08T17:17:11Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The version determines the length, but only if you know the version. If you're consuming an ECHConfigs and want to pick a common version between you and the server, you'll need to account for versions you don't understand and correctly skip over them.",
          "createdAt": "2020-09-09T22:27:52Z",
          "updatedAt": "2020-09-09T22:27:52Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right you are! Thanks for setting me straight.\r\n\r\nWe can close this issue.",
          "createdAt": "2020-09-09T23:32:49Z",
          "updatedAt": "2020-09-09T23:32:49Z"
        }
      ]
    },
    {
      "number": 301,
      "id": "MDU6SXNzdWU2OTU1NTMyMzc=",
      "title": "Question about encrypted_ch and encrypted_ch_inner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/301",
      "state": "CLOSED",
      "author": "D-Sinus",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "While reading the draft, I'm confused with ClientEncryptedCH structure.\r\n\r\nSection : The \"encrypted_client_hello\" extension says...\r\n\r\n~~~~\r\n    struct {\r\n       HpkeCipherSuite cipher_suite;\r\n       opaque config_id<0..255>;\r\n       opaque enc<1..2^16-1>;\r\n       opaque encrypted_ch<1..2^16-1>;\r\n    } ClientEncryptedCH;\r\n~~~~\r\n>enc : The HPKE encapsulated key, used by servers to decrypt the corresponding `encrypted_ch` field.\r\n>encrypted_ch : The serialized and encrypted ClientHelloInner structure, encrypted using HPKE as described in {{send-ech}}.\r\n\r\nand Section : Sending an encrypted ClientHello says...\r\n\r\n>The encrypted ClientHello value is then computed as:\r\n\r\n~~~~\r\n    encrypted_ch = context.Seal(\"\", ClientHelloInner)\r\n~~~~\r\n\r\nCause output of the context.Seal() function is ciphertext output of AEAD encryption (According to draft-irtf-cfrg-hpke-05),\r\nI think encrypted_ch has only ciphertext value of the ClientHelloInner, not the enc value.\r\nBut the same section also says...\r\n>encrypted_ch contains the HPKE encapsulated key (enc) and the ClientHelloInner ciphertext (encrypted_ch_inner).\r\n\r\nQ. Does encrypted_ch have enc and encrypted_ch_inner?\r\nOr it just has the ciphertext of ClientHelloInner and encrypted_ch_inner is just mistype?\r\n",
      "createdAt": "2020-09-08T05:13:32Z",
      "updatedAt": "2020-09-18T21:11:14Z",
      "closedAt": "2020-09-18T21:11:14Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Nice catch! `encrypted_ch` should just be the AEAD ciphertext. The following text is wrong:\r\n\r\n> - encrypted_ch contains the HPKE encapsulated key (enc) and the ClientHelloInner                                                                                             \r\n  ciphertext (encrypted_ch_inner).\r\n\r\nIt should be:\r\n\r\n> - encrypted_ch contains the AEAD-encrypted ClientHelloInner.\r\n\r\ncc/ @chris-wood",
          "createdAt": "2020-09-08T21:26:01Z",
          "updatedAt": "2020-09-08T21:26:01Z"
        },
        {
          "author": "D-Sinus",
          "authorAssociation": "NONE",
          "body": "OK, there's no `encrypted_ch_inner`.. thanks!",
          "createdAt": "2020-09-10T03:35:28Z",
          "updatedAt": "2020-09-10T03:35:28Z"
        }
      ]
    },
    {
      "number": 307,
      "id": "MDU6SXNzdWU3MDY2ODMzODU=",
      "title": "Add note on network/transport failure probability and ECH confirmation collision",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/307",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/tlswg/draft-ietf-tls-esni/pull/287#discussion_r492802148.",
      "createdAt": "2020-09-22T20:49:24Z",
      "updatedAt": "2020-10-07T14:35:46Z",
      "closedAt": "2020-10-07T14:35:46Z",
      "comments": []
    },
    {
      "number": 309,
      "id": "MDU6SXNzdWU3MTA0NjUyOTM=",
      "title": "Ensuring 1.3 is used when ECH is accepted",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/309",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Usage of 1.3 is enforced by the following rules.\r\n\r\n* Client (Section 6.1):\r\n    > It MUST offer to negotiate TLS 1.3 or above [in ClientHelloOuter]. [...] It MUST NOT offer to negotiate TLS 1.2 or below [in ClientHelloInner].\r\n\r\n* Client-facing server (7.1):\r\n    > Upon receiving an \"encrypted_client_hello\" extension, the client-facing server MUST check that it is able to negotiate TLS 1.3 or greater. If not, it MUST abort the connection with a \"handshake_failure\" alert.\r\n\r\n* The backend server does not enforce 1.3 usage. (At least, I couldn't find an explicit rule in the text.)\r\n\r\nRequiring that 1.3 is the only version offered in the ClientHelloInner is sufficient to ensure that 1.3 is negotiated by the client and backend server in case of acceptance. However, my sense is that the client would be easier to implement if this rule were softened to:\r\n\r\n> It MUST offer to negotiate TLS 1.3 in the ClientHelloInner.\r\n\r\nWe could then add the following behavior to the backend server (Section 7.2):\r\n\r\n> If the ClientHelloInner indicates ECH was accepted [i.e., there is an empty \"encrypted_client_hello\" extension in the ClientHello], but the client does not offer support for TLS 1.3 or above, then the backend server MUST abort the handshake with a \"[some error]\" alert.\r\n\r\nWhat do y'all think?",
      "createdAt": "2020-09-28T17:54:54Z",
      "updatedAt": "2020-10-01T15:59:12Z",
      "closedAt": "2020-09-30T16:09:48Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm happy to put together a PR if folks are happy with this change.",
          "createdAt": "2020-09-28T17:55:35Z",
          "updatedAt": "2020-09-28T17:55:35Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't feel strongly either way. I actually hadn't realized the client was already forbidden from offering TLS 1.2. The server needs to check anyway, and it's much more natural to check the negotiated version, so I don't think it helps the server in either direction. (@dmcardle since we were talking about this recently.)\r\n\r\nThere's no real reason for the client to offer TLS 1.2 in the inner ClientHello, and it could send a potentially smaller ClientHello (fewer cipher suites, omit renegotiation_info, extended_master_secret, shorter supported_versions). One footnote is a shorter supported_versions is still more bytes than a compressed supported_versions, but I think the savings elsewhere exceed that. (At least for now. Maybe 10 years from now, there will be very few TLS 1.2 ciphers and very many post-TLS-1.2 versions before TLS 1.2 is gone??)\r\n\r\nI guess the other factor is it may also be more convenient for the client not to have juggle two different min_version values around in its ClientHello construction logic. But I feel like the client should decide based on how many bytes it takes on the wire.",
          "createdAt": "2020-09-28T18:10:12Z",
          "updatedAt": "2020-09-28T18:10:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @davidben: The server needs to check anyway, and it's much more natural to check the negotiated version, so I don't think it helps the server in either direction.\r\n\r\nWhich server? the client-facing server or the backend server? AFAICT the backend server doesn't currently enforce the version.",
          "createdAt": "2020-09-28T18:13:47Z",
          "updatedAt": "2020-09-28T18:13:47Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I mostly do not believe in split mode, but I suppose it'd be the client-facing server. I suppose that's a little odd since the client-facing server isn't the one that negotiates a version. But either way, both the existing text and your proposed replacement discusses the negotiated version.",
          "createdAt": "2020-09-28T18:16:40Z",
          "updatedAt": "2020-09-28T18:16:40Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would favor relaxing the requirement on the client side and having the backend server abort if 1.3 isn't offered. It seems conceptually cleaner, since it reduces the amount of things one has to think about when constructing the ClientHelloInner.",
          "createdAt": "2020-09-28T21:37:23Z",
          "updatedAt": "2020-09-28T21:37:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I would favor relaxing the requirement on the client side and having the backend server abort if 1.3 isn't offered. It seems conceptually cleaner, since it reduces the amount of things one has to think about when constructing the ClientHelloInner.\r\n\r\nI would argue that this is *less* clean, since it requires us to also specify client behavior in the event of a 1.2 SH (which could maliciously be inserted by someone between the client-facing and backend server). Beyond that, I don't see why prohibiting everything below 1.3 in ClientHelloInner is cleaner. This is a protocol for TLS 1.3, so why continue adding legacy cruft where it can't possibly be used?",
          "createdAt": "2020-09-29T00:45:36Z",
          "updatedAt": "2020-09-29T00:45:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n> I would argue that this is _less_ clean, since it requires us to also specify client behavior in the event of a 1.2 SH (which could maliciously be inserted by someone between the client-facing and backend server).\r\n\r\nGood point!\r\n\r\n> This is a protocol for TLS 1.3, so why continue adding legacy cruft where it can't possibly be used?\r\n\r\nThe idea is that it would make implementing the client easier. I don't have a strong opinion either way, so I'm happy to drop this and go with the status-quo.\r\n\r\n",
          "createdAt": "2020-09-29T15:45:29Z",
          "updatedAt": "2020-09-29T15:45:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In fact, @chris-wood's observations means it's probably a wash :/",
          "createdAt": "2020-09-29T15:55:09Z",
          "updatedAt": "2020-09-29T15:55:09Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing as resolved. No action taken.",
          "createdAt": "2020-09-30T16:09:48Z",
          "updatedAt": "2020-09-30T16:09:48Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#319 made me realize there's more weird things around the version text. The client-facing server text doesn't even make sense because it's a check on the outer ClientHello, rather than the inner ClientHello. This means that actually no checks on the server side ensure we don't accidentally negotiate TLS 1.2 and leak the server name, and the client text in 6.1 is actually load-bearing.\r\n\r\nI'll upload a PR to fix up the 7.1 text. Maybe also worth an optional sanity-check in Shared Mode? Not sure.",
          "createdAt": "2020-10-01T15:59:12Z",
          "updatedAt": "2020-10-01T15:59:12Z"
        }
      ]
    },
    {
      "number": 310,
      "id": "MDU6SXNzdWU3MTA0NzY0NTY=",
      "title": "legacy_session_id should match between inner and outer",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/310",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "If the client uses TLS 1.3's [middlebox compatibility mode](https://tools.ietf.org/html/rfc8446#appendix-D.4), there are a couple subtle points:\r\n\r\n* Even though the middlebox will never see the inner ClientHello, we still need a non-empty legacy_session_id, because some servers use that value to condition the other bits.\r\n\r\n* More importantly, the inner legacy_session_id needs to match the outer legacy_session_id! Otherwise the server will echo back the wrong one and trip up all the buggy middleboxes again.\r\n\r\nAlternatively, we could say the server uses the outer ClientHello to negotiate middlebox compatibility mode. That would reduce bytes on the wire, but it'd upset all the split mode arrangements.",
      "createdAt": "2020-09-28T18:14:05Z",
      "updatedAt": "2020-09-29T00:46:06Z",
      "closedAt": "2020-09-29T00:46:06Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch. I'd be fine with this matching constraint. Could you please propose text?",
          "createdAt": "2020-09-28T20:27:46Z",
          "updatedAt": "2020-09-28T20:27:46Z"
        }
      ]
    },
    {
      "number": 322,
      "id": "MDU6SXNzdWU3MTMyMzQ3MzY=",
      "title": "Tidy up all codepoints before -08",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/322",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Note to self. Let's pick a set and range that works.",
      "createdAt": "2020-10-01T22:53:36Z",
      "updatedAt": "2020-10-16T18:57:12Z",
      "closedAt": "2020-10-16T18:57:12Z",
      "comments": []
    },
    {
      "number": 323,
      "id": "MDU6SXNzdWU3MTUyMjYyMTA=",
      "title": "Re-re-visit outer ClientHello binding (saves 65 bytes)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/323",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We previously decided not to bind the outer ClientHello to the ECH decryption, because doing so is rather a hassle. We'd need something similar to the TLS 1.3 PSK binder mess, with the added complexity of ordering relative to the PSK binders themselves. Additionally, while the binding helps with some of the don't stick out properties, there were other attacks on distinguishability anyway. So, instead, we mitigated the inner ClientHello malleability with OuterExtensions.inner_digest and left the outer ClientHello unbound.\r\n\r\nHowever, we've since decided not to allow PSKs in the outer ClientHello. Perhaps we should revisit this. Suppose the AD parameter to the ECH decryption were the entire outer ClientHello, minus the ECH extension. I believe this means we no longer need OuterExtensions.inner_digest. That would give an immediate 33-byte savings. It would then unlock a further 32 byte savings by amending #312 to say:\r\n\r\n* Client always encodes an empty legacy_session_id in ECH plaintext.\r\n* Client-facing server copies outer legacy_session_id to inner ClientHello as part of decompression.\r\n\r\n(The reason we can't do this easily right now is that, if the inner ClientHello lacks outer_extension, nothing's authenticating legacy_session_id. Since the field in TLS 1.3 is all but ignored, it's \"obvious\" that the malleability doesn't matter, but it's nicer to not need to think about such things.)\r\n\r\nFrom looking at Chrome's ClientHellos and working through what we'd send (drop 1.2-only extensions, compress most), it looks like the inner ClientHello will be maybe 130-140 bytes, plus a padded server_name. The 65 bytes above would almost halve the overhead.\r\n\r\nIn some sense what's going on here is our 16-byte tag on the AEAD in the ECH ciphertext is going to waste. We didn't authenticate everything that goes into reconstructing the inner ClientHello (outer_extensions), so instead we authenticate another hash (OuterExtensions.inner_digest) and check that afterwards. (To that end, if we do this, we probably need to say the server MUST reject encrypted_client_hello showing up in outer_extensions, that way all inputs to decompression are authenticated. Equivalently, decompression is done relative to the ECH-extension-less AD input rather than the original outer ClientHello.)",
      "createdAt": "2020-10-05T23:22:06Z",
      "updatedAt": "2020-10-16T18:57:52Z",
      "closedAt": "2020-10-16T18:57:52Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this idea. How do you think the AD ought to be structured? The ClientHelloOuter, but with an an empty \"encrypted_client_hello\" extension?",
          "createdAt": "2020-10-07T16:46:27Z",
          "updatedAt": "2020-10-07T16:46:27Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, that's seems the simplest to me. Filling it with zeros, as @bemasc pointed out to me, requires predicting the length of the encrypted inner ClientHello. This isn't strictly impossible (ADs don't change ciphertext length), but it seems needlessly fussy and ECH is already requiring we be able re-encode ClientHellos, lengths and all.\r\n\r\nNote this assumes there are no computed PSK binders in the outer ClientHello because otherwise there's a circular dependency. (If we wanted to allow that, the AD would need to zero/trim the binders or so.)",
          "createdAt": "2020-10-07T17:50:14Z",
          "updatedAt": "2020-10-07T17:50:14Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another benefit is it stops the attacker from probing information about compressed extensions. Currently an attacker can learn which extensions are compressed in the inner ClientHello by removing them from the outer ClientHello and seeing if the server still responds. This isn't a huge deal, as compressed extensions are assumed public, but this way we remove that vector and leave only the fuzzier signal from the ciphertext length.",
          "createdAt": "2020-10-07T21:41:00Z",
          "updatedAt": "2020-10-07T21:41:00Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Filling it with zeros, as @bemasc pointed out to me, requires predicting the length of the encrypted inner ClientHello. This isn't strictly impossible (ADs don't change ciphertext length), but it seems needlessly fussy and ECH is already requiring we be able re-encode ClientHellos, lengths and all.\r\n\r\nOn second thought, a lot of implementations will need to do that prediction anyway. The workaround for the old F5 bug means we'll need to know the eventual size for the padding extension. (On the other hand, you can probably assume anyone doing ECH is not running those things. On the other hand, turning off the workaround would stick out.) Ah well. We did it for PSK already.\r\n\r\n(I wonder if we can do drop that workaround now that TLS 1.0 and 1.1 are gone...)",
          "createdAt": "2020-10-08T01:16:40Z",
          "updatedAt": "2020-10-08T01:16:40Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What's the \"old F5 bug\"?\r\nWhat's the value in authenticating the length of the \"encrypted_client_hello\" extension? This is authenticated by the handshake already, no?",
          "createdAt": "2020-10-08T22:23:55Z",
          "updatedAt": "2020-10-08T22:23:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> What's the \"old F5 bug\"?\r\n\r\nhttps://www.imperialviolet.org/2013/10/07/f5update.html\r\nhttps://mailarchive.ietf.org/arch/msg/tls/8wXwhM1d5WSmROHFSgrTyFmWN2o/\r\nIt's why we have a padding extension.\r\n\r\n> What's the value in authenticating the length of the \"encrypted_client_hello\" extension? This is authenticated by the handshake already, no?\r\n\r\nThere isn't. It's just a question of what's easier to deal with. Filling it with zeros means that, when computing the AD on the receiving side, you don't need to fully reconstruct a modified outer ClientHello with updated length prefixes. We avoided this when computing the PSK binder in RFC8446.\r\n\r\nIt's a mild hassle but not a huge deal. More importantly, we've thoroughly given up on that elsewhere in the spec. The F5 padding business also means computing this AD will likely take some length prediction anyway, but so it goes.",
          "createdAt": "2020-10-09T02:10:16Z",
          "updatedAt": "2020-10-09T02:21:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, it's not a big hassle.",
          "createdAt": "2020-10-09T15:23:53Z",
          "updatedAt": "2020-10-09T15:23:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I like this idea. How do you think the AD ought to be structured? The ClientHelloOuter, but with an an empty \"encrypted_client_hello\" extension?\r\n\r\nRather than make the extension empty, can we just omit the `enc` and `payload` fields? (The `cipher_suite` and `config_id` should arguably be included, a la #326).",
          "createdAt": "2020-10-09T15:57:29Z",
          "updatedAt": "2020-10-09T15:57:29Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That works, though it's even more fussy for the client to construct, since it needs to half-encode the ECH extension before fully encoding it.\r\n\r\n`cipher_suite` is already bound into HPKE itself. `config_id` is less clear, but I thought our model already said all this didn't matter? Isn't the binding here just to replace `inner_digest` and provide malleability? If there's something more going on, I'd like us to have some principled answer here, so we can answer questions like... what about the handshake transcript, which may not be empty on HRR? If we do that, what's going on with ech_hrr_key?",
          "createdAt": "2020-10-09T17:23:12Z",
          "updatedAt": "2020-10-09T17:23:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The principle I was following is: include as much as possible in the AD. Yeah, it's more of a pain, and we've gotten away with *no* binding whatsoever up to now, so maybe we don't need it. I'm happy to start with an empty ECH extension and then consider the other parts later, if that'll help.",
          "createdAt": "2020-10-09T18:51:55Z",
          "updatedAt": "2020-10-09T18:51:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't feel very strongly either way.",
          "createdAt": "2020-10-09T18:57:14Z",
          "updatedAt": "2020-10-09T18:57:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's just do the simpler thing now, then! :-)",
          "createdAt": "2020-10-09T21:06:07Z",
          "updatedAt": "2020-10-09T21:06:07Z"
        }
      ]
    },
    {
      "number": 324,
      "id": "MDU6SXNzdWU3MTUyNTk1NTM=",
      "title": "Clarify that CHInner ECH payload contents",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/324",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Unless I missed it, nowhere in the spec does it say that clients SHOULD/MUST send an empty ECH extension in CHInner (to trigger the confirmation signal). Should we add this?\r\n\r\ncc @davidben, @cjpatton",
      "createdAt": "2020-10-06T00:57:38Z",
      "updatedAt": "2020-10-07T16:55:04Z",
      "closedAt": "2020-10-07T16:55:04Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is covered in Section 5: \r\n> When offering the \"encrypted_client_hello\" extension in its ClientHelloOuter, the client MUST also offer an empty \"encrypted_client_hello\" extension in its ClientHelloInner, wherever applicable. (This requirement is not applicable when the extension is generated as described in Section 6.4.)",
          "createdAt": "2020-10-07T16:49:23Z",
          "updatedAt": "2020-10-07T16:49:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, thank you! Closing.",
          "createdAt": "2020-10-07T16:55:04Z",
          "updatedAt": "2020-10-07T16:55:04Z"
        }
      ]
    },
    {
      "number": 325,
      "id": "MDU6SXNzdWU3MTUyNjAxMjY=",
      "title": "Specify cross-HRR key rotation issue(s)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/325",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If a server implements ECH decryption via an RPC call, it's possible for the client's ECH keys to be valid for CH1 but invalid for CH2, perhaps due to a race condition that updates the server's keys across these messages. This should be exceedingly rare in practice, so failing the connection with an alert is probably fine, but we should probably be clear about this.\r\n\r\ncc @cjpatton ",
      "createdAt": "2020-10-06T00:59:13Z",
      "updatedAt": "2020-10-16T15:29:11Z",
      "closedAt": "2020-10-16T15:29:11Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are two ways a accept-then-HRR-then-reject can happen:\r\n1. The client sends a `config_id` after HRR that differs from the `config_id` it sent before HRR.\r\n1. The `config_id` is the same, but the server no longer recognizes it.\r\n\r\nThe latter is the server's fault, and I think the only thing to do is abort with \"internal_error\". However, I think requiring that the `config_id` doesn't change is a good idea. I wonder if this is implied by the client behavior?\r\n\r\n> If the server sends a HelloRetryRequest in response to the ClientHello, the client sends a second updated ClientHello per the rules in [RFC8446]. However, at this point, the client does not know whether the server processed ClientHelloOuter or ClientHelloInner, and MUST regenerate both values to be acceptable. Note: if the inner and outer ClientHellos use different groups for their key shares or differ in some other way, then the HelloRetryRequest may actually be invalid for one or the other ClientHello, in which case a fresh ClientHello MUST be generated, ignoring the instructions in HelloRetryRequest. Otherwise, the usual rules for HelloRetryRequest processing apply.\r\n\r\nIn any case, I think we should have the server abort with \"illegal_parameter\" if the `config_id` changes over HRR.",
          "createdAt": "2020-10-07T17:01:01Z",
          "updatedAt": "2020-10-07T17:01:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is this any different from, say, the server's cipher suite capabilities changing in between CH1 and CH2 and thus the server not being able to meet what they said with HRR?\r\n\r\nI guess I've always assumed that, within the context of a single \"handshake\" from the perspective of the client, we expect the server to behave self-consistently and, if it can't, I guess the server can internal_error and live with failing one or two connections across server restarts.",
          "createdAt": "2020-10-07T17:40:48Z",
          "updatedAt": "2020-10-07T17:40:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is this any different from, say, the server's cipher suite capabilities changing in between CH1 and CH2 and thus the server not being able to meet what they said with HRR?\r\n\r\nI think this is a little different, since it can be triggered by changing the set of ECHConfigs the server knows, and not necessarily the set of cipher suites.\r\n\r\n> I guess I've always assumed that, within the context of a single \"handshake\" from the perspective of the client, we expect the server to behave self-consistently and, if it can't, I guess the server can internal_error and live with failing one or two connections across server restarts.\r\n\r\nI agree. And even though the situation is a bit different, I think \"internal_error\" is appropriate here as well. However, I also think the client SHOULD NOT change the ECHConfig across HRR. If it does, I think the server SHOULD abort with \"illegal_paramter\". \r\n\r\nDo you think this would be hard for the server to enforce? In particular, a QUIC server might want to handle the HRR path statelessly, and this check requires remembering the previous `config_id`.\r\n\r\n",
          "createdAt": "2020-10-08T20:08:56Z",
          "updatedAt": "2020-10-08T20:08:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> However, I also think the client SHOULD NOT change the ECHConfig across HRR.\r\n\r\nI think that's already true. The client can't change things across HRR unless explicitly allowed. (https://tools.ietf.org/html/rfc8446#section-4.1.2)\r\n\r\n> If it does, I think the server SHOULD abort with \"illegal_parameter\".\r\n\r\nExactly what the server enforces on HRR is... all over the place. I'm normally in favor of maximal enforcement, but enforcing all the rules of HRR is such a mess. It's especially messy for folks who do stateless HRR, because any state carried over across the two increases the size of the cookie. So I think we need to be a little careful here. Honestly, I think we didn't really get HRR right.\r\n\r\n> In particular, a QUIC server might want to handle the HRR path statelessly, and this check requires remembering the previous config_id.\r\n\r\nQUIC does not care about stateless HRR. It did in the original design, but that's been dropped. DTLS does, though. And I believe NSS always implements it statelessly? (BoringSSL currently only does stateful.)",
          "createdAt": "2020-10-09T19:04:20Z",
          "updatedAt": "2020-10-09T19:04:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It sounds like a weak \"MAY\" would be most appropriate.",
          "createdAt": "2020-10-09T20:34:27Z",
          "updatedAt": "2020-10-09T20:34:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It sounds like a weak \"MAY\" would be most appropriate.\r\n\r\nCan you elaborate?",
          "createdAt": "2020-10-11T11:27:20Z",
          "updatedAt": "2020-10-11T11:27:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looking at this again, I suspect the minimal thing that needs to be checked across CH1 and CH2 is that the server cannot change its mind on whether it used ECH in CH2 and, if using ECH, it needs to have remembered ech_hrr_key (and HPKE cipher suites?) to bind the two. Dunno if it makes sense to just also remember the config_id at that point.",
          "createdAt": "2020-10-11T15:34:35Z",
          "updatedAt": "2020-10-11T15:34:35Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> , I suspect the minimal thing that needs to be checked across CH1 and CH2 is that the server cannot change its mind on whether it used ECH in CH2 and, if using ECH, it needs to have remembered ech_hrr_key (and HPKE cipher suites?) to bind the two. \r\n\r\nI agree, but I don't think tracking the `ech_hrr_key` is sufficient. Suppose the client sends an acceptable `config_id` in CH1 but a rejecting `config_id` in CH2. In this case `ech_hrr_key` doesn't provide the binding we need, since the client-facing server won't attempt to decrypt the payload in CH2.\r\n\r\nA conservative way to ensure the server doesn't change its mind is as follows:\r\n1. Require that the `cipher_suite` does not change across HRR. If it does, then abort with \"illegal_parameter\" alert.\\**\r\n1. Require that the `config_id` does not change across HRR. If it does, then abort with \"illegal_parameter\" alert.\r\n1. If `config_id` isn't recognized after HRR --- say because of key rotation -- then abort with \"internal_error\" alert.\r\n\r\n\\** I'm not sure 1. is strictly necessary. If the `cipher_suite` isn't supported by the ECH configuration, then the server would abort with \"illegal_parameter\". (This is already specified.) Moreover, I don't think we have any agility issues here, given that the derived AEAD key is bound to the cipher suite. However, this does ensure that the server chooses the HPKE cipher suite and KEM key in the same way before and after HRR. This may turn out to be useful.",
          "createdAt": "2020-10-12T23:07:42Z",
          "updatedAt": "2020-10-12T23:07:42Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Suppose the client sends an acceptable config_id in CH1 but a rejecting config_id in CH2. In this case ech_hrr_key doesn't provide the binding we need, since the client-facing server won't attempt to decrypt the payload in CH2.\r\n\r\nRight, this is what I mean by \"the server cannot change its mind on whether it used ECH in CH2\". If you declined ECH in CH1, you ignore ECH in CH2. If you accepted ECH in CH1, failure to handle ECH in CH2 is fatal. But, yeah, if you remember the config used, you can check a bit more accurately, so maybe we should just do that and ask stateless HRRs make an even larger cookie. (Need to be a bit careful about `config_id` itself because we allow a trial decryption flow too.)",
          "createdAt": "2020-10-13T03:15:30Z",
          "updatedAt": "2020-10-13T03:22:24Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For what it's worth, I'm not a huge fan of CH2 having a fresh HPKE exchange in the first place. That seems an unnecessary asymmetric operation. Were it not for stateless HRR, I think I'd advocate we just make CH2's ECH payload a second pop at the HPKE context's Seal() function (next sequence number), with the rest ignored. But with stateless HRR, we need to serialize the HPKE context into the cookie, which is mildly annoying.",
          "createdAt": "2020-10-13T03:21:19Z",
          "updatedAt": "2020-10-13T03:21:33Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see how you can avoid CH2 having a new payload.  Unless you are looking to just perform address validation (DTLS), you only send HRR to correct something in the ClientHello.",
          "createdAt": "2020-10-13T03:25:59Z",
          "updatedAt": "2020-10-13T03:25:59Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @martinthomson: I don't see how you can avoid CH2 having a new payload. Unless you are looking to just perform address validation (DTLS), you only send HRR to correct something in the ClientHello.\r\n\r\nI think what @davidben means is that the AEAD ciphertext could change without changing the encapsulating key. Hence, the ClientHelloInner can be changed without updating the HPKE shared secret.\r\n\r\n> @davidben: But with stateless HRR, we need to serialize the HPKE context into the cookie, which is mildly annoying.\r\n\r\nWouldn't this leak the HPKE encryption key? The cookie extension is transmitted in the HRR in plaintext, right?\r\n\r\n",
          "createdAt": "2020-10-13T14:23:09Z",
          "updatedAt": "2020-10-13T14:24:39Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">> @martinthomson: I don't see how you can avoid CH2 having a new payload. Unless you are looking to just perform address validation (DTLS), you only send HRR to correct something in the ClientHello.\r\n>\r\n> I think what @davidben means is that the AEAD ciphertext could change without changing the encapsulating key. Hence, the ClientHelloInner can be changed without updating the HPKE shared secret.\r\n\r\nSpecifically, HPKE supports multiple sequential encryption calls on a context with an internal sequence number.\r\nhttps://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#name-encryption-and-decryption\r\n\r\n>> @davidben: But with stateless HRR, we need to serialize the HPKE context into the cookie, which is mildly annoying.\r\n>\r\n> Wouldn't this leak the HPKE encryption key? The cookie extension is transmitted in the HRR in plaintext, right?\r\n\r\nThe cookie already needs to encrypted and authenticated by the server like tickets. It certainly needs to be authenticated independent of ECH, otherwise the attacker can manipulate it anyway. And then the existing ech_hrr_key construction requires encryption too.\r\n\r\n(If you didn't encrypt the cookie for some reason and only MAC'd it, this design would allow you to, rather than serializing the HPKE encryption key, remember the expected HPKE config, redo the KEM operation, and bump the sequence number up. But if you're remembering some secret for the MAC, may as well encrypt it...)",
          "createdAt": "2020-10-13T15:39:26Z",
          "updatedAt": "2020-10-13T15:39:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The cookie already needs to encrypted and authenticated by the server like tickets. \r\n\r\nRight, thanks for *again* clarifying a misunderstanding of mine about the TLS spec :)\r\n\r\nIncidentally, I brought up specifying HPKE context serialization here: https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/161. There doesn't seem to be a lot of appetite for it. I suppose we could specify it in ECH, but there are so many use cases for it that I think it would be worth specifying it in the HPKE draft.",
          "createdAt": "2020-10-13T16:12:19Z",
          "updatedAt": "2020-10-13T16:12:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given the uncertainty about stateless HRR pointed out in #333, let's permit the client-facing server to abort if ECH usage changes after HRR. This allows stateful-HRR servers to enforce this behavior, but leaves it as an \"OPEN ISSUE\" about how stateful-hRR servers will enforce this.\r\n\r\nI'll prepare a PR tomorrow or Thursday.",
          "createdAt": "2020-10-13T20:53:18Z",
          "updatedAt": "2020-10-13T20:53:18Z"
        }
      ]
    },
    {
      "number": 326,
      "id": "MDU6SXNzdWU3MTUyNjA1MzA=",
      "title": "Include ECH context in ClientHelloOuterAAD",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/326",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@davidben mentions possibly binding the outer CH to the ECH encryption in #323. If we don't do that, we should at least bind the encryption to the non-encrypted parts of the ECH extension (`config_id`, `suite`, and so on).\r\n\r\ncc @cjpatton ",
      "createdAt": "2020-10-06T01:00:24Z",
      "updatedAt": "2020-11-18T23:57:21Z",
      "closedAt": "2020-11-18T23:57:21Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also like this idea :) AD is cheap.",
          "createdAt": "2020-10-07T16:48:01Z",
          "updatedAt": "2020-10-07T16:48:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #323. We can revisit the ECH extension AD information later if desired.",
          "createdAt": "2020-10-11T11:24:54Z",
          "updatedAt": "2020-10-11T11:24:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Re-opening to consider adding *all* data to AAD. @davidben wrote out the flow if we did this:\r\n\r\n- Make your CHInner. This should largely be running through your usual CH assembly logic.\r\n- Encode it with the extensions you expect to compress.\r\n- Make your CHOuter, minus the ECH extension. This should largely run through your existing CH assembly logic.\r\n- Run Deserialize and SetupBaseS.\r\n- Compute CHOuterAAD with half an ECH extension.\r\n- Take EncodedCHInner and CHOuterAAD and run through the context.Seal logic to assemble the final CHOuter.\r\n\r\nSo, not great, but also not too terrible. I'd prefer we avoid falling into the \"gee, I sure wish we bound more to the encryption\" state, given the history of ECH, though I agree that this isn't cheap. \r\n\r\n@ekr, what do you think?",
          "createdAt": "2020-11-04T19:33:34Z",
          "updatedAt": "2020-11-04T19:33:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To be clear, the suggestion is to change AEAD encryption so that it authenticates `ClientECH.cipher_suite`, `.config_id`, and `.enc`, correct? This change seems sensible to me. One might argue that this is redundant because these parameters are incorporated into the transcript (on ECH rejection). On the other hand, ECH usage is resolved before the transcript is known! It seems like a good idea to authenticate these parameters before consuming them.",
          "createdAt": "2020-11-04T19:43:31Z",
          "updatedAt": "2020-11-04T19:47:03Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "They aren't incorporated on ECH accept, which is mildly interesting. ECH accept also doesn't negotiate with them, so it's probably okay, though there is a \"don't stick out\" failure (depending on threat model) for the optional config_id flow if we don't authenticate them.",
          "createdAt": "2020-11-04T19:48:40Z",
          "updatedAt": "2020-11-04T19:48:40Z"
        }
      ]
    },
    {
      "number": 329,
      "id": "MDU6SXNzdWU3MTc4MDk1OTY=",
      "title": "ClientHello construction order is inconsistent",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/329",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I noticed this while drafting a PR for #323. We're a little inconsistent about whether the ClientHelloInner or ClientHelloOuter is constructed first.\r\n\r\nSection 4 says inner before outer:\r\n> When a client wants to establish a TLS session with the backend server, it constructs its ClientHello as usual (we will refer to this as the ClientHelloInner message) and then encrypts this message using the public key of the ECH configuration. It then constructs a new ClientHello (ClientHelloOuter)\r\n\r\nSection 5.1 implies inner before outer:\r\n> When sending ClientHello, the client first computes ClientHelloInner, including any PSK binders, and then MAY substitute extensions which it knows will be duplicated in ClientHelloOuter.\r\n\r\nBut section 6.1 says outer before inner:\r\n> Next, the client constructs the ClientHelloOuter message just as it does a standard ClientHello, with the exception of the following rules:\r\n> ...\r\n> The client then constructs the ClientHelloInner message just as it does a standard ClientHello, with the exception of the following rules:\r\n\r\nI think inner before outer makes more sense. You certainly can't finish the outer one before you've computed the inner one. (Of course, an implementation can pick whatever order is most convenient, but I think the spec should be consistent with itself.)",
      "createdAt": "2020-10-09T02:52:06Z",
      "updatedAt": "2020-10-11T11:22:43Z",
      "closedAt": "2020-10-11T11:22:43Z",
      "comments": []
    },
    {
      "number": 331,
      "id": "MDU6SXNzdWU3MTc4MTI3NjU=",
      "title": "Encoded vs actual ClientHelloInner is a little ambiguous",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/331",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There are two ClientHelloInners, the actual one used in the handshake, and the encoded one with outer_extensions substituted in. Both are described as ClientHelloInner, but this makes it slightly ambiguous which goes into, say, the handshake transcript.\r\n\r\n(It's late now, so I'll leave this as an issue without a PR. If we don't end up resolving this separately, I'll probably fix this as part of #323. If we decide to implicitly copy over legacy_session_id, the encryption payload becomes less and less defensibly an actual ClientHelloInner.)",
      "createdAt": "2020-10-09T03:02:34Z",
      "updatedAt": "2020-10-14T20:07:50Z",
      "closedAt": "2020-10-14T20:07:50Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In my own implementation, I've been referring to the plaintext payload as CompressedClientHelloInner. Which is terrible, but unambiguous.",
          "createdAt": "2020-10-09T16:17:34Z",
          "updatedAt": "2020-10-09T16:17:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Works for me. I was thinking EncodedClientHelloInner because it's shorter and still works even if you choose not to compress anything. (A no-op encoding is still an encoding.)",
          "createdAt": "2020-10-09T16:33:46Z",
          "updatedAt": "2020-10-09T16:33:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to EncodedClientHelloInner, given that compression is optional. @davidben, if you have time, could you whip up a PR?",
          "createdAt": "2020-10-11T11:24:13Z",
          "updatedAt": "2020-10-11T11:24:13Z"
        }
      ]
    },
    {
      "number": 333,
      "id": "MDU6SXNzdWU3MTg4NjY1OTM=",
      "title": "Stateless HRR and split mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/333",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I was thinking about #316 and the discussion on server HRR checks started by https://github.com/tlswg/draft-ietf-tls-esni/issues/325#issuecomment-705796082, and I'm not sure HRR cookies even work in split mode right now. First off, suppose we don't merge something like #316. The current text says:\r\n\r\n> Note: if the inner and outer ClientHellos use different groups for\r\n> their key shares or differ in some other way, then the HelloRetryRequest may\t\r\n> actually be invalid for one or the other ClientHello, in which case a fresh\t\r\n> ClientHello MUST be generated, ignoring the instructions in HelloRetryRequest.\t\r\n> Otherwise, the usual rules for HelloRetryRequest processing apply\r\n\r\nThis means if you get a cookied HRR only good for ClientHelloInner, there's no requirement to stick the cookie in ClientHelloOuter! But now the client-facing server can't see the cookie, so it can't be stateless. It would seem like #316 fixes this, but now we have a more fundamental problem: whose cookie?\r\n\r\nSuppose the client-facing server wishes to handle HRR statelessly. It decrypts the first ClientHelloInner and forwards it to the backend server. If the backend server responds with HRR, the client-facing server must forward the HRR as-is, or the transcript breaks. But the client-facing server has no opportunity to bind its state (ech_hrr_key) into the HRR cookie. (Perhaps there isn't even one. If there is, it's encrypted with the backend server's key anyway. Either way, it's fixed now.)\r\n\r\nThe simplest solution to all this is to only support stateful client-facing servers in split mode, unless the client-facing and backend servers can coordinate enough to share one cookie. I don't know if that would satisfy everyone. I could imagine doing something horrific to HRR.cookie, akin to what we did to ServerHello.random, but that sounds really messy.",
      "createdAt": "2020-10-11T15:59:26Z",
      "updatedAt": "2020-11-19T12:09:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's mark this as an \"OPEN ISSUE\" in the draft.",
          "createdAt": "2020-10-13T20:46:03Z",
          "updatedAt": "2020-10-13T20:46:03Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Let's mark this as an \"OPEN ISSUE\" in the draft.\r\n\r\nDone. https://github.com/tlswg/draft-ietf-tls-esni/pull/338",
          "createdAt": "2020-10-13T20:56:31Z",
          "updatedAt": "2020-10-13T20:56:31Z"
        }
      ]
    },
    {
      "number": 342,
      "id": "MDU6SXNzdWU3MjMzMjU4NTQ=",
      "title": "Consider shortening config_id to 8 bytes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/342",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This matches the acceptance signal length, and we've already accepted that probability of collision.",
      "createdAt": "2020-10-16T15:34:13Z",
      "updatedAt": "2020-11-03T20:52:43Z",
      "closedAt": "2020-11-03T20:52:43Z",
      "comments": []
    },
    {
      "number": 348,
      "id": "MDU6SXNzdWU3MjQ5NzgxMjY=",
      "title": "Define separate codepoint (and name) for inner ECH extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/348",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It is unclear how a general TLS server is supposed to react to an ECH extension. It's sometimes empty and sometimes a ClientECH. An empty extension is not a valid ClientECH extension, so a server expending ClientECH should produce a `decode_error` (and vice versa).\r\n\r\nThe spec does talk about client-facing and backend servers as separate kinds of servers, but I thought the theory behind Split Mode was that backend servers were meant to be mostly standard TLS servers. That would suggest that backend-server-specific logic should be common to all TLS server implementations that know about ECH. In that case, perhaps we should say that:\r\n\r\n* The client ECH extension is either empty or a ClientECH structure.\r\n* If you see empty, this is an inner ClientHello. Do the ServerHello.random thing and otherwise handshake normally.\r\n* If you see non-empty and have ECHConfigs, parse as a ClientECH and decode_error on parse failure as usual. Do the client-facing server thing.\r\n\r\nOr is the idea that client-facing and backend servers are completely separate beasts and everyone always knows which they are? In that case, what happens if a client-facing server sees an empty ECH extension? What happens if a backend server sees a ClientECH-carrying ECH extension. Failure to parse an extension is normally fatal, but the two categories of server believe different parses are valid. In particular, this requires a backend server *never* see a general-purpose client connection, since it'd get confused by (possibly GREASE) ClientECH extensions.",
      "createdAt": "2020-10-19T21:10:47Z",
      "updatedAt": "2020-11-19T00:06:38Z",
      "closedAt": "2020-11-19T00:06:37Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The spec does talk about client-facing and backend servers as separate kinds of servers, but I thought the theory behind Split Mode was that backend servers were meant to be mostly standard TLS servers. That would suggest that backend-server-specific logic should be common to all TLS server implementations that know about ECH. \r\n\r\nI think this is the intention, yeah. This is how I understand the spec:\r\n1. Every TLS server is a backend server. If a TLS server knows a set of ECHConfigs, then it is also a client-facing server.\r\n1. An empty ECH extension signals that the server should play the role of the backend server. (Hence, the client-facing server would skip ECH processing and proceed as if it were a backend server.)\r\n1. A non-empty ECH extension signals that the server should play the role of the client-facing server. (The server ignores the extension if it is not a client-facing server.)",
          "createdAt": "2020-10-19T23:17:36Z",
          "updatedAt": "2020-10-19T23:27:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, sounds like you and I are on the same page there. But I'm not sure the spec text actually supports that interpretation. Let's fix that.",
          "createdAt": "2020-10-20T00:37:53Z",
          "updatedAt": "2020-10-20T00:37:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Who wants to take the PR?",
          "createdAt": "2020-10-20T22:20:45Z",
          "updatedAt": "2020-10-20T22:20:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd be happy to take it, since David did a lot of the heavy lifting last week. Unless you want to take a crack at it, David?",
          "createdAt": "2020-10-20T23:18:50Z",
          "updatedAt": "2020-10-20T23:18:50Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm working on a PR.",
          "createdAt": "2020-10-21T15:49:47Z",
          "updatedAt": "2020-10-21T15:49:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR ready. Note that it also clarifies how the client's role (real or GREASE) is determined.",
          "createdAt": "2020-10-21T16:35:29Z",
          "updatedAt": "2020-10-21T16:35:29Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another thought: we could also avoid this odd \"maybe empty, maybe not\" behavior by just using a different codepoint for the \"please give me an ECH acceptance signal\" extension. As things stand, the {{server-hrr}} text is also kinda off:\r\n\r\n> If CH1 contains the \"encrypted_client_hello\" extension but CH2 does not, or if CH2 contains the \"encrypted_client_hello\" extension but CH1 does not, then the server MUST abort the handshake with an \"illegal_parameter\" alert.\r\n\r\nThat text doesn't account for CH1 containing a ClientECH \"encrypted_client_hello\" extension and CH2 containing an empty \"encrypted_client_hello\" extension. If the two modes are different codepoints, we don't have to keep expending words to talk about the two flavors.",
          "createdAt": "2020-10-30T03:50:38Z",
          "updatedAt": "2020-10-30T03:50:38Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The downside of two codepoints is it's now possible to construct a ClientHello with both extensions at once and we need to decide whether, on ECH reject, the client-facing server is expected to do the ServerHello.random computation, error, or ignore it. I don't care strongly there. Any of option seems fine.\r\n\r\nDoing the computation has a nice orthogonality to it. We'd just be saying:\r\n* There's this swizzle_server_random extension. If you see it in the ClientHello you process, go do the thing. Whatever.\r\n* Independently, there's an encrypted_client_hello extension. If you see it, try to decrypt it and use it.\r\n* Backend servers behind client-facing servers MUST support swizzle_server_random and the client MUST stick swizzle_server_random in ClientHelloInner. These two rules together avoid the trial decryption mess.",
          "createdAt": "2020-10-30T03:56:34Z",
          "updatedAt": "2020-10-30T03:56:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd support this change. Is there a downside to relaxing the client requirement to \"MAY stick swizzle_server_random in CHI\"? That would allow client implementations to bear the burden of trial decryption, if they want. (I don't think it make a difference on the server side.)\r\n\r\nIIRC a similar idea came in the long-long ago of #287 and people didn't seem to like it. I could be wrong though.",
          "createdAt": "2020-10-30T22:48:26Z",
          "updatedAt": "2020-10-30T22:48:26Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What would be the point of allowing that? Having two ways to do something adds complexity to the protocol and ecosystem. (E.g. a client that does trial decrypt instead will fail to ensure backend servers implement their requirements.) We should add options in the protocol as a last resort when we really need it, not because we can.\r\n\r\n(Elsewhere, TLS 1.2 session tickets specified two different ways to check something. We ended up with random downstream protocol picking the wrong one and a security vulnerability in OpenSSL.)",
          "createdAt": "2020-10-30T23:25:54Z",
          "updatedAt": "2020-10-30T23:25:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed, just wanted to confirm.",
          "createdAt": "2020-10-30T23:45:38Z",
          "updatedAt": "2020-10-30T23:45:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben, can we merge #350 before we consider changing the codepoint of the inner ECH extension?",
          "createdAt": "2020-11-02T17:05:04Z",
          "updatedAt": "2020-11-02T17:19:23Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh sorry, missed that was waiting on me. Looking.",
          "createdAt": "2020-11-02T18:35:36Z",
          "updatedAt": "2020-11-02T18:35:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I landed #350. We can spin up a PR with separate codepoints now, if desired. (I also like the idea!)",
          "createdAt": "2020-11-03T21:04:45Z",
          "updatedAt": "2020-11-03T21:04:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cbartle891 is going to take a stab at this!",
          "createdAt": "2020-11-12T01:59:42Z",
          "updatedAt": "2020-11-12T01:59:42Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that this seems like the right direction. Haven't reviewed the PR.",
          "createdAt": "2020-11-17T06:42:48Z",
          "updatedAt": "2020-11-17T06:42:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #360. Closing.",
          "createdAt": "2020-11-19T00:06:37Z",
          "updatedAt": "2020-11-19T00:06:37Z"
        }
      ]
    },
    {
      "number": 349,
      "id": "MDU6SXNzdWU3MjYwOTQxMzA=",
      "title": "Avoid computing a new HPKE contexts on HRR?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/349",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "ECH currently adds an ECDH operation on *both* the first and second ClientHello. That's extra asymmetric operations, and if folks end up offloading those keys, it's two RPCs. Given that we need to bind the two decryptions together anyway, and HPKE supports multiple encrypted messages (it has an internal sequence number), perhaps it's better to just use that.\r\n\r\nHere's a possibility: the first ClientHello makes a new HPKE context and calls context.Seal on it. The second ClientHello simply calls context.Seal on the same context, which internally increments the sequence number. Probably we copy over the first ClientHello's cipher_suite, config_id, and enc, even though they don't really do anything.\r\n\r\nThe server, if stateful, just calls context.Open to mirror the client behavior. If stateless, probably the simplest thing is to pickle the AEAD key inside the cookie. [Edit: I accidentally wrote \"ticket\" earlier.] It probably could also recompute the HPKE context and bump the sequence number up by one, maybe checking the selected ECHConfig and enc values didn't change. (The text already requires checking the former.)",
      "createdAt": "2020-10-21T03:12:01Z",
      "updatedAt": "2020-11-17T23:21:00Z",
      "closedAt": "2020-11-17T23:21:00Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "EDITED: s/ticket/cookie/\r\n\r\nI like this suggestion overall. A few comments:\r\n1. It's not sufficient to store only the key in the cookie: minimally we'll need the key and the initialization vector (called \"nonce\" in the HPKE spec, unfortunately). We may also end up needing the exporter secret as well, although this is currently only used in ECH to compute the HRR PSK for `SetupPSKS()` and this call would go away if we decided to adopt this change.\r\n1. In case of ECH acceptance, the backend server stores the key/IV in the cookie. This is a problem for \"Split Mode\": as you previously pointed out, there is currently no way for the client-facing server to convey cookie content to the backend server. Perhaps a solution to #333 is a prerequisite to this?\r\n1. HPKE does not specify serialization of the HPKE context. This use case makes me think it should.",
          "createdAt": "2020-10-21T16:53:17Z",
          "updatedAt": "2020-10-21T19:55:28Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(I think you want to s/ticket/cookie/g since ticket is the resumption thing. That was my bad. I wrote ticket instead of cookie too.)\r\n\r\n> It's not sufficient to store only the key in the ticket:\r\n\r\nGood catch. Yes, we need to store both derived values. Although the difference between storing one short byte string or two short byte strings is largely one of semantics. (You can just as easily concatenate them and store the one resulting short byte string.) You could also store the root secret and rederive it. Whichever.\r\n\r\n> We may also end up needing the exporter secret as well, although this is currently only used in ECH to compute the HRR PSK for SetupPSKS() and this call would go away if we decided to adopt this change.\r\n\r\nWe wouldn't need the exporter secret or SetupPSK in this design.\r\n\r\n> In case of ECH acceptance, the backend server stores the key/IV in the ticket. [...] Perhaps a solution to #333 is a prerequisite to this?\r\n\r\nI don't think this introduces a new problem, so there's no need to block on #333. Though we need to deal with that too. In both this design and the status quo, the client-facing server needs to either be stateful or store *something* secret in the cookie. Right now it's ech_hrr_key. In this design it's the key/IV. (Though this design introduces the alternate strategy of storing a less secret thing, where you just remember the client's public bits and recompute the HPKE context.)\r\n\r\n> HPKE does not specify serialization of the HPKE context. This use case makes me think it should.\r\n\r\nThe serialization doesn't need to be standard or anything. A TLS server might want to keep its cookie small by observing it doesn't need the exporter secret. But some guidance might be useful, sure.\r\n\r\n(The only thing that needs to consume the cookie is the server, who also produced it. Just as TLS doesn't (and shouldn't) specify session state serialization, yet every TLS implementation has a session state serialization. I could also implement TLS by, rather than keeping connection state in memory, write it to disk and read it back out on every packet. Even an in-memory representation is a serialization.)",
          "createdAt": "2020-10-21T17:11:31Z",
          "updatedAt": "2020-10-21T17:11:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is an interesting consideration. On one hand, I agree that it's simpler to simply reuse the existing context, though on the other hand it seems to run against the general desire to use primarily CH2 for \"everything.\" That said, ECH annoyingly requires binding between the two CHs, which we currently address by tying them together with a PSK, and this proposal is arguably simpler. \r\n\r\n(Anecdotally, I recall some server stacks verifying PSK binders on CH1 and then ignoring them on CH2, which was a situation that wasn't carefully analyzed in the formal analyses. I think that was fixed, though I don't recall how: are binders verified for both CHs, or only for the latter? And if verifying a binder involves a public key operation, why would ECH be any different?)",
          "createdAt": "2020-10-21T23:54:20Z",
          "updatedAt": "2020-10-21T23:54:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The \"use CH2 for everything\" theory mostly assumes you don't negotiate very many parameters on CH1, whereas you need to resolve ECH early to even get at CH1. And, as you note, we need to bind the two. So I think we're pretty stuck with having ECH resolved at CH1 rather than CH2 anyway.\r\n\r\nVerifying a binder doesn't require a public key operation. It's mostly an HMAC. If you resolved the PSK at CH1, you've got the PSK available for CH2 and can compute the binder easily enough. If you resolved the PSK at CH2[*], then you just do it normally.\r\n\r\n[*] As an aside, you only sort of are able to do this. If your stack implements psk_ke, which thankfully most folks didn't, you need to resolve PSK at CH1 to know if you need a key share at all. Whereas if you know you only support psk_dhe_ke, then you can proceed assuming you need a key share and defer sorting out the PSK to later.",
          "createdAt": "2020-10-22T00:17:37Z",
          "updatedAt": "2020-10-22T00:17:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The \"use CH2 for everything\" theory mostly assumes you don't negotiate very many parameters on CH1, whereas you need to resolve ECH early to even get at CH1. And, as you note, we need to bind the two. So I think we're pretty stuck with having ECH resolved at CH1 rather than CH2 anyway.\r\n\r\nYeah, I think that's right.\r\n\r\n> Verifying a binder doesn't require a public key operation. It's mostly an HMAC. If you resolved the PSK at CH1, you've got the PSK available for CH2 and can compute the binder easily enough. If you resolved the PSK at CH2[*], then you just do it normally.\r\n\r\nWhat if the key is inside a ticket? Doesn't that require a public key operation? (I should have clarified that I was referring to the whole process, involving getting the key and then using it to verify the binder. Sorry!)",
          "createdAt": "2020-10-22T00:38:06Z",
          "updatedAt": "2020-10-22T00:38:06Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> What if the key is inside a ticket? Doesn't that require a public key operation? (I should have clarified that I was referring to the whole process, involving getting the key and then using it to verify the binder. Sorry!)\r\n\r\nI guess it depends on how you do your tickets. They're typically just encrypted with a symmetric key, but I've also seen folks use asymmetric stuff. But, in any case, if you decrypt the ticket at CH1, by CH2 you've already gotten the decrypted ticket so you just compute the binder and don't redo the ticket business. If you decrypt the ticket at CH2, you only have the one ticket decryption by construction.",
          "createdAt": "2020-10-22T12:34:07Z",
          "updatedAt": "2020-10-22T12:34:07Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR in #352.",
          "createdAt": "2020-10-30T04:40:44Z",
          "updatedAt": "2020-10-30T04:40:44Z"
        }
      ]
    },
    {
      "number": 354,
      "id": "MDU6SXNzdWU3MzQ5NTAyMzA=",
      "title": "\"Don't stick out\" considerations for ECH",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/354",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The primary \"don't stick out\" [RFC8744] consideration for ECH is to ensure that the new extension does not trigger middlebox misbehavior. To accomplish this, the draft specifies two protocol variants: in the \"real-ECH\" protocol the client offers the ECH extension, which is processed by the server; in the \"grease-ECH\" protocol, the client generates a dummy ECH extension, which is ignored or rejected by the server. Grease-ECH is designed to look enough like real-ECH so that middleboxes do not differentiate the latter from the former, the idea being that if grease-ECH can be deployed without triggering middlebox misbehavior, then real-ECH ought to be deployable, too.\r\n\r\nBut what do we mean when we say grease-ECH should \"look like\" real-ECH? In ECH-08 the stated goal is \"to hide, to some extent, **(a)** whether or not a specific server supports ECH and **(b)** whether or not ECH was accepted for a particular connection\" [ECH-08, [Sec.10.1](https://tools.ietf.org/html/draft-ietf-tls-esni-08#section-10.1)]. These goals are hard to meet. First, an attacker can violate **(a)** by simply running grease-ECH with the server to see if it returns retry configs. Second, there are a number of ways to distinguish real-ECH from grease-ECH, thereby violating **(b)**:\r\n1. @huitema's [client-reaction attack](https://mailarchive.ietf.org/arch/msg/tls/EAeKCNq7JAFm8DFaoe2MwSslZTQ/).\r\n1. If the ECH config is known to the attacker, then it can use ClientECH.config_id to distinguish real-ECH from grease-ECH. \r\n1. The outer SNI must match ECHConfig.public_name. Hence, for connections to a given backend server, the outer SNI will be different in real-ECH than in grease-ECH.\r\n1. The client and server must negotiate TLS 1.3 when ECH is accepted, but may otherwise negotiate an earlier version. In particular, it is valid for a client to run grease-ECH but not indicate support for 1.3.\r\n1. PSK must not be offered in the outer CH in real-ECH, but may be offered in grease-ECH. In general, the set of extensions negotiated may depend on whether ECH was accepted.\r\n1. The client-facing server must not request client authentication when rejecting ECH, but the backend server may request client authentication when ECH was accepted.\r\n1. Whether or not an HRR message is issued by the server may depend on ECH acceptance.\r\n1. There are a few active distinguisher attacks that exploit the HRR codepath.\r\n\r\nSome of these distinguishers can be mitigated by careful implementation, while mitigating others would require changes to the specification. (E.g., #353.) However, it's unlikely that _all_ implementations will mitigate _all_ of these distinguishers. Moreover, future extensions are likely to change the shape of TLS in a way that leads to yet more distinguishers.\r\n\r\nGiven all of this, I wonder if indistinguishability (of real-ECH from grease-ECH) is the right way to think about this problem. It seems to me that it's stronger than strictly necessary, since the existence of a distinguisher does not necessarily imply that some feature of real-ECH will trigger middlebox misbehavior that would not otherwise be triggered by grease-ECH. For example, while the outer SNI might be a dead give away of likely ECH usage, this value is unlikely to impact middlebox behavior. Similarly, the absence of the PSK extension in real-ECH is unlikely to cause issues.\r\n\r\nIf it were possible to enumerate the set of properties that impact middlebox behavior, then ensuring that middleboxes don't differentiate between real-ECH and grease-ECH may simply be a matter of ensuring that this set of properties does not vary. This approach would be roughly analogous to the design of \"Middlebox Compatibility Mode\" in TLS 1.3, which makes the handshake \"look like\" a particular mode of 1.2 that middleboxes are known to tolerate. Of course, a curious adversary (e.g., a censor) can easily distinguish between these, but experience suggests that middleboxes do not treat them differently.\r\n\r\nThis leaves us the daunting task of deciding what features are known to impact the behavior of existing middleboxes. Here's a preliminary list of things that might fit in this category. For the sake of discussion, let's call them **differentiable features**:\r\n1. The set of extensions that appear to be negotiated;\r\n1. Visible alerts, e.g., \"bad_record_mac\";\r\n1. Number of round trips in a given transport context (e.g., TCP connection);\r\n1. Packet size, or the number of packets comprising a single message;\r\n1. Timing;\r\n1. ...\r\n\r\nI think we should set the following goals for ECH-09 (or some draft that follows it).\r\n1. If we can agree on a set of differentiable features, then we should ensure that this set does not vary between real-ECH and grease-ECH.\r\n1. ECH-08 aims only to mitigate **passive** \"don't stick out\" attacks, but there is a lot of evidence that middleboxes exhibit **active** behavior. (For example, middleboxes have been observed removing CH extensions they don't recognize or adding their own.) Thus, we should aim to thwart attacks that change the set of differentiable features in real-ECH vs. grease-ECH. This includes @huitema's attack in particular: see #353.\r\n1. To the greatest extent possible, the spec should allow for implementations to aim for the strongest possible notion of security. For example, we might consider relaxing the requirement that the outer SNI matches ECHConfig.public_name, so long as this change doesn't impact interoperability.\r\n",
      "createdAt": "2020-11-03T01:28:48Z",
      "updatedAt": "2020-12-17T21:44:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kjacobs-moz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For the PSK extension specifically, I think we have two distinguishers to consider:\r\n\r\n- GREASE ECH + PSK extension in a Client Hello identifies GREASE ECH, due to PSKs being disallowed in CHOuter.\r\n- Real ECH + resumption (or any accepted PSK) identifies accepted ECH. CHOuter contains no PSK extension, but SH will contain the pre_shared_key extension (selected_identity).\r\n\r\n\r\n\r\n",
          "createdAt": "2020-11-24T21:29:50Z",
          "updatedAt": "2020-11-24T21:29:50Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Due to assertions stated in IETF meetings that ECH isn't an anti-censorship tool, and the literally innumerable difficulties in making real ECH indistinguishable from GREASE ECH (as mentioned above), I propose dropping the \"do not stick out\" goal. The primary aim of ECH is to make the SNI private, and it's possible to keep the SNI private while telegraphing that we're using ECH.\r\n\r\nWe can, however, still use GREASE to make sure middleboxes are prepared to handle the code point and the larger size of the ClientHello.",
          "createdAt": "2020-12-10T20:55:25Z",
          "updatedAt": "2020-12-10T20:55:25Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with cjpatton's analysis.\r\n\r\nI don't think anyone is asking that these things be \"indistinguishable\" to a determined active intermediary in the common case.  That is clearly impossible (e.g. cjpatton's attack 2).  Instead, the goal is to minimize barriers to deployment of ECH.  If ECH isn't reliable in practice, it won't be widely deployed, and so will not keep the SNI private.\r\n\r\nIn my view, the minimum threshold is: a passive intermediary with only per-connection state must not be able to distinguish ECH from GREASE with confidence for a typical client and server configuration.  Defenses for less common protocol uses and low-grade active intermediaries (e.g. simple replay) are good to have but we shouldn't delay the protocol if they prove difficult.\r\n\r\nI think the only remaining issue to reach this level is Real ECH + resumption (kjacobs second attack).  All the other attacks (a) only affect a subset of GREASE (e.g. resumption GREASE), (b) require the intermediary to be active (emitting or modifying packets), or (c) require the intermediary to have per-server state (e.g. a DNS database or a persistent server profile).  We should build defenses for those cases too where we can, but some are intractable, and that's OK.",
          "createdAt": "2020-12-11T16:40:59Z",
          "updatedAt": "2020-12-11T16:40:59Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is kind of sad, but I agree with the analysis. The sticking out starts with the definition of ECH as an extension, which already provides a differentiation from standard TLS. The theory that grease will fix that by making it hard to distinguish \"real\" and \"fake\" ECH is most probably wrong, except if the middlebox is really naive. That means the only sure way to grease the ECH function is to actually use it, even when the inner SNI is the same as the outer ECH -- only a real ECH is undistinguishable from a real ECH.",
          "createdAt": "2020-12-11T17:23:57Z",
          "updatedAt": "2020-12-11T17:23:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @bemasc. The ECH goals in the document mostly align with this proposed minimum threshold. I think we should close this with no action, or tweak language to make this more clear, assuming we have consensus.\r\n\r\n@ekr, @davidben, @martinthomson, @kazuho: what do you think?",
          "createdAt": "2020-12-11T17:47:00Z",
          "updatedAt": "2020-12-11T17:50:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think action is needed at this point, but I think we should keep the issue open until we're closer to RFC. We're pretty close to interop, and we should expect real-world experiments to follow shortly thereafter. Those experiments will reveal if we missed anything, and it will be useful to have this issue as a reference.",
          "createdAt": "2020-12-11T18:08:22Z",
          "updatedAt": "2020-12-11T18:08:22Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> In my view, the minimum threshold is: a passive intermediary with only per-connection state must not be able to distinguish ECH from GREASE with confidence for a typical client and server configuration.\r\n\r\nThis seems like a reasonable objective for avoiding operational/ossification issues.",
          "createdAt": "2020-12-11T18:15:21Z",
          "updatedAt": "2020-12-11T18:15:21Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc's description sounds right. I would note that this seems to actually make #353 unnecessary, right? Not saying we necessarily need to not do it, but...\r\n\r\n",
          "createdAt": "2020-12-13T00:13:38Z",
          "updatedAt": "2020-12-13T00:13:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to see about sharpening @bemasc's description: if an attacker needs to interfere with a connection in such a way that it would cause a failure in that connection in order to determine whether ECH is in use, that's out of scope, right?",
          "createdAt": "2020-12-13T00:15:24Z",
          "updatedAt": "2020-12-13T00:15:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> if an attacker needs to interfere with a connection in such a way that it would cause a failure in that connection in order to determine whether ECH is in use, that's out of scope, right?\r\n\r\nYes, that seems like a higher threshold than the one I proposed (purely passive).  I'm not sure about \"out of scope\".  For example, I fully support #353.  I think that when we run into problems like this, we should solve them if we have a solution available, but not delay the protocol if we have to go searching for one.",
          "createdAt": "2020-12-13T21:07:55Z",
          "updatedAt": "2020-12-13T21:07:55Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": ">  I think that when we run into problems like this, we should solve them if we have a solution available, but not delay the protocol if we have to go searching for one.\r\n\r\nI disagree. I think that if a particular threat model is out of scope, it's out of scope, and any mitigations of them shouldn't be in the document. There's no point in half-measures that ultimately won't be sufficient for addressing certain types of attackers but will add complexity.",
          "createdAt": "2020-12-15T00:42:31Z",
          "updatedAt": "2020-12-15T00:42:31Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> if an attacker needs to interfere with a connection in such a way that it would cause a failure in that connection in order to determine whether ECH is in use, that's out of scope, right?\r\n\r\nAn interesting detail on this one: interfering with the bytes and observing either client or server's response will break that connection, but observing the server's response is a little different from observing the client. One can often make a second connection to the server. (Perhaps a \"passive and a half\" attack.)\r\n\r\nThat is, suppose the server sent decrypt_failure on bad ECH decryptions. (It no longer does.) You can determine whether ECH is in use by flipping a bit in the ciphertext and seeing if the server notices. That breaks the connection, but you could make a second connection to the server, send your perturbed ClientHello, and not interfere with the original connection.\r\n\r\nWhereas, if your attack involves probing the client's behavior, you'd need to induce the client to start a second connection and not notice the first. Systems do tend to retry on failure, so this isn't _entirely_ implausible, but harder than the first attack.",
          "createdAt": "2020-12-17T21:44:29Z",
          "updatedAt": "2020-12-17T21:44:52Z"
        }
      ]
    },
    {
      "number": 356,
      "id": "MDU6SXNzdWU3MzcyNzIzNzg=",
      "title": "Clients should send consistent GREASE ECH extensions between CH1 and CH2",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/356",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'll try to put together a PR for this later, but filing this now so I don't forget. (@dmcardle FYI) The draft currently says you randomize this both times, which won't work.\r\n\r\nAlso \"MUST check the extension syntactically\" appears to have been a little ambiguous, since how deeply you parse ECHConfigs gets a little complicated. I'll adjust that too.",
      "createdAt": "2020-11-05T21:12:25Z",
      "updatedAt": "2020-11-17T23:21:00Z",
      "closedAt": "2020-11-17T23:21:00Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'll try to put together a PR for this later, but filing this now so I don't forget. (@dmcardle FYI) The draft currently says you randomize this both times, which won't work.\r\n\r\nWhat fields are suggesting to not randomize?",
          "createdAt": "2020-11-06T15:59:55Z",
          "updatedAt": "2020-11-06T15:59:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`cipher_suite`. The draft doesn't quite say to randomize it, but it does say to vary it. (I'm not sure that's correct, actually. It depends on how much variation to expect in server ECHConfigs. If everyone does the AES-GCM / ChaCha20 pair, as they should, then the client will always pick one matching its cipher preference.)\r\n\r\nAdditionally, after #352, `enc` also should not be re-randomized on CH2.",
          "createdAt": "2020-11-06T16:07:00Z",
          "updatedAt": "2020-11-06T16:07:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben what is the concern here?",
          "createdAt": "2020-11-06T17:21:52Z",
          "updatedAt": "2020-11-06T17:21:52Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just that GREASE and ECH should be consistent in which fields get copied over and the text doesn't say that right now.",
          "createdAt": "2020-11-06T17:34:34Z",
          "updatedAt": "2020-11-06T17:34:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh, apparently I already thought of this in #352 and included some text about this:\r\n\r\n> When sending a second ClientHello in response to a HelloRetryRequest, the\r\n> client copies the \"cipher_suite\", \"config_id\", and \"enc\" fields. It generates a\r\n> new \"payload\" field, using the length of a padded second EncodedClientHelloInner\r\n> for L.\r\n\r\nSo I'll just mark #352 as closing this too but leave this open just in case we decide not to do #352.",
          "createdAt": "2020-11-06T21:11:30Z",
          "updatedAt": "2020-11-06T21:11:30Z"
        }
      ]
    },
    {
      "number": 358,
      "id": "MDU6SXNzdWU3MzgwNDIzNTY=",
      "title": "ECH contradicts second ClientHello consistency requirements in RFC8446",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/358",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I just noticed this as I was pondering our various HRR issues. RFC8446, section 4.1.2 says:\r\n\r\n> [...] The client will also send a ClientHello when the server has responded to its ClientHello with a HelloRetryRequest.  In that case, the client MUST send the same ClientHello without modification, except as follows:\r\n>\r\n> * [...various cases regarding existing extensions...]\r\n>\r\n> *  Other modifications that may be allowed by an extension defined in the future *and present in the HelloRetryRequest*.\r\n\r\nhttps://tools.ietf.org/html/rfc8446#section-4.1.2\r\n\r\nThe \"and present in the HelloRetryRequest\" portion is fun. In RFC8446 as written, we're not allowed to change the `encrypted_client_hello` extension on the second ClientHello unless the server sent `encrypted_client_hello` in HelloRetryRequest, which it doesn't. With the protocol as-is, it seems we'll at least need some text to deal with the contradiction.\r\n\r\nThe impact is practice is thankfully limited. If the servers does not enforce consistency between the two ClientHellos, it doesn't matter. (They're not required to, but they're not explicitly forbidden from it either, and a stateless server may need to enforce some minimum consistency to avoid getting into a broken state.) If a server does, ECH's behavior on HRR will break it. Such a server is supposed to handshake with ClientHelloOuter, so it just affects the retry flow. That's maybe okay, but mildly annoying. Administrators using server software that checks need to know to first upgrade to a version that doesn't check before trying to deploy ECH.\r\n\r\nWe can also add an ECH extension to HRR. Then, on ECH-reject + HRR, the server perhaps wouldn't send the extension and the client would be required to replay the extension. This is a waste in many ways, but would work. This would break don't stick out, but some threat models, don't stick out with HRR is hopeless anyway. (See https://github.com/tlswg/draft-ietf-tls-esni/pull/352#issuecomment-721824226.) It would also be weirdly asymmetric between ECH and SH.\r\n\r\nThat said, this constraint is also pretty obnoxious. For instance, #313 currently adds a new padding extension codepoint, because the old one isn't defined for other messages. However, the RFC8446 allowance only works for the existing padding code point, so you don't want to send any other code points in ClientHello, lest the server force you to keep it unchanged in ClientHello2. So maybe we should confirm no servers did the fully strict check and undo that constraint? (Although, for #313, I personally favor the padding message strategy anyway.)",
      "createdAt": "2020-11-06T21:05:33Z",
      "updatedAt": "2020-11-19T12:09:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton points out the Go implementation does check CH1 and CH2 consistency. Fortunately, it only checks known extensions, so it's still compatible with the ECH draft.\r\nhttps://golang.org/src/crypto/tls/handshake_server_tls13.go#L457\r\n\r\nChecking only know extensions is basically saying we should strike \"and present in the HelloRetryRequest\" in rfc8446bis and make sure everyone knows not to check this.",
          "createdAt": "2020-11-10T23:28:39Z",
          "updatedAt": "2020-11-10T23:28:39Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we can *just* strike this text because the point of that text was that you couldn't like change your KeyShares if the HRR didn't tell you to. But I agree we can sharpen this in some sensible way.",
          "createdAt": "2020-11-17T06:44:40Z",
          "updatedAt": "2020-11-17T06:44:40Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I figured that case was covered by \"defined in the future\", which I'm not proposing we delete. key_share isn't defined in the future, so it falls under existing rules. The existing rules (bullet points over that one) only let you change key_share \"[i]f a \"key_share\" extension was supplied in the HelloRetryRequest\". But perhaps that's a little roundabout. The rules I'm thinking of are (changes *emphasized*):\r\n\r\n* Each extension gets to define how it reacts to HRR.\r\n* It typically is sensitive the corresponding HRR extension, *but doesn't have to be*.\r\n* RFC8446(bis) defines the rules for all existing extensions.\r\n* Future extensions define their own rules. (And probably if they don't say anything, we assume they don't get to change.)\r\n* As a server, you can make assumptions based on the rules for extensions you know about. *You have to tolerate random changes in extensions you don't know about, because you don't know their rules.*\r\n\r\nI'm running a probe on a bunch of servers to see how they react to changes in cipher suites, curves, and a random extension. It seems most don't notice. Some (I'm guessing Go) notice cipher suites and curves. None notice a random extension. That suggests the change will be compatible.",
          "createdAt": "2020-11-17T07:03:50Z",
          "updatedAt": "2020-11-17T07:03:50Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm running a probe on a bunch of servers to see how they react to changes in cipher suites, curves, and a random extension. It seems most don't notice. Some (I'm guessing Go) notice cipher suites and curves. None notice a random extension. That suggests the change will be compatible.\r\n\r\nI spoke too soon. LibreSSL breaks if you change an extension they don't recognize. :-(",
          "createdAt": "2020-11-17T07:39:08Z",
          "updatedAt": "2020-11-17T07:39:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So draft-09 isn't tied up with this, I've uploaded https://github.com/tlswg/draft-ietf-tls-esni/pull/361 as a bandaid for the potential compatibility issue.\r\n\r\n(I say potential because it's only a problem if the server checks unknown extensions *and* has different enough key share preferences from the client that it needs HRR. HRR is pretty rare, so it may not actually be an issue. For Chrome, at least, I don't think the particular servers I found actually trigger HRR. But it is still a risk for clients or servers with different configurations.)",
          "createdAt": "2020-11-18T00:10:23Z",
          "updatedAt": "2020-11-18T00:10:23Z"
        }
      ]
    },
    {
      "number": 359,
      "id": "MDU6SXNzdWU3NDI1ODk5NDQ=",
      "title": "Transcript hash construction",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/359",
      "state": "OPEN",
      "author": "kylon94",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "ready-for-text"
      ],
      "body": "I heard about Encrypted Client Hello recently. Looks like a good idea. I have been thinking about implementing and suggest a clarification in the draft.\r\n\r\nIt needs to specify which ClientHello the client should use to compute the transcript hash. I assume if the connection to the backend server is successful it should use the ClientHelloInner, Else, if it authenticates to the public name it should use the ClientHelloOuter.\r\n\r\nMight be kind of obvious, but explicit > implicit. Maybe some text extending Section 4.4.1 of RFC8446 should be added.",
      "createdAt": "2020-11-13T16:36:25Z",
      "updatedAt": "2020-12-21T13:35:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @kylon94! We'll try and clarify this.",
          "createdAt": "2020-11-16T16:48:47Z",
          "updatedAt": "2020-11-16T16:48:47Z"
        },
        {
          "author": "kylon94",
          "authorAssociation": "NONE",
          "body": "Looking at section 5.1, I think some clarification would be helpful. It makes sense that the full ClientHelloInner with the outer extensions should be included in the hash but this isn't clear. In particular highlighting the change in message length between the ClientHelloInner and EncodedClientHelloInner would help. Like the issue above, not a big deal but it could trip up a developer.",
          "createdAt": "2020-12-10T15:12:55Z",
          "updatedAt": "2020-12-10T15:12:55Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "@kylon94 Why would highlighting the change in message length help with this?",
          "createdAt": "2020-12-15T00:27:07Z",
          "updatedAt": "2020-12-15T00:27:07Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Blocked on the issues discussed in https://github.com/tlswg/draft-ietf-tls-esni/issues/373.",
          "createdAt": "2020-12-16T18:01:38Z",
          "updatedAt": "2020-12-16T18:01:38Z"
        },
        {
          "author": "kylon94",
          "authorAssociation": "NONE",
          "body": "> @kylon94 Why would highlighting the change in message length help with this?\r\n\r\nBecause the ClientHello encoding process is new for ECH, a developer might use the wrong message length in the transcript hash even if they used the correct content. Being clear about using the full ClientHelloInner with outer extensions is more important, but mentioning the length too might help out some developers.",
          "createdAt": "2020-12-21T13:35:29Z",
          "updatedAt": "2020-12-21T13:35:29Z"
        }
      ]
    },
    {
      "number": 369,
      "id": "MDU6SXNzdWU3NTAxMDMzMzA=",
      "title": "Potential SNI leak via cross-ECH resumption",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/369",
      "state": "CLOSED",
      "author": "kjacobs-moz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Martin pointed out a potential SNI leak via resumption under the following conditions:\r\n1. A client connects to server \"A\" without ECH, and receives a session ticket.\r\n2. The client later resumes the connection to server \"A\" using ECH. An observer can see that a PSK was accepted (via SH containing pre_shared_key). \r\n4. If any of the hosts previously visited by the client are known, an attacker can do a lookup of each for a config_id matching the resumed session. \r\n\r\nThis effectively reduces the size of the anonymity set for a particular client/victim.\r\n\r\nWhile it's true that the hostname is already leaked by the first connection without ECH, this seems to violate the security goals as they are written. We used to require separation between non-ECH and ECH PSKs, but it was removed in #285.",
      "createdAt": "2020-11-24T22:08:33Z",
      "updatedAt": "2020-12-16T16:25:37Z",
      "closedAt": "2020-12-16T16:25:37Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah fun. I agree that observing a resumption does increase the probability the connection was one of the previous non-ECH connections the client made, when server just deployed ECH. (Though the client could also be visiting someone else in the anonymity set for a second time.) I'm not sure I follow what's going on in (3) though. Is that just checking if one of the previously-visited hosts shares a client-facing server with the connection under attack? That seems like something the attacker can regardless. (With or without resumption, one would expect a client's visited sites pre-ECH-deployment to somewhat predict with the ones post-ECH-deployment.)\r\n\r\nAs an aside, even if SH.pre_shared_key was hidden, the observer can infer resumption based on whether the server responded with a lot of data (it sent a certificate in there), or very little data (it sent no certificate in there). Unless the server adds some truly wasteful padding on resumption connections.",
          "createdAt": "2020-11-25T19:30:57Z",
          "updatedAt": "2020-11-25T19:30:57Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(3) just provides additional evidence that the SNI guess is correct (by further constraining set of possible hostnames). ",
          "createdAt": "2020-11-30T20:47:34Z",
          "updatedAt": "2020-11-30T20:47:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To mitigate this, it ought to be sufficient to have the client track whether a given PSK was established ruing a ECH handshake or a non-ECH handshake. It seems like this would be a lot more involved for a server to manage.",
          "createdAt": "2020-11-30T21:57:50Z",
          "updatedAt": "2020-11-30T21:57:50Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is it actually additional evidence? It doesn't seem to narrow the usual ECH anonymity set, just identifies it. If I understand you correctly, (3) is:\r\n\r\n* The attacker observes a connection from the client with some config_id and some secret SNI A.\r\n* The attacker queries DNS or the recovery flow[*] for the cleartext SNIs that the client previously visited and sees if one of them, B, has an ECHConfig with matching config_id.\r\n* If there is a match, the attacker learns that B was in the same anonymity set as A.\r\n\r\nThe attacker learns this whether or not the connection resumes. The attacker also hasn't expanded the anonymity sent. In fact, they didn't even need to query sites the client previously visited. They could just as easily query the top N sites or a list of popular hosting providers known to support ECH. I think this information is part of the baseline for our security goals.\r\n\r\nIt is true that a client which, before ECH, leaked that it visited A many times is more likely to visit A again in the future. That seems fundamental. I think the interesting thing is that (2) tells the observer that it is *some* repeat visit, which increases the chance it's A. (But doesn't guarantee it. Maybe I've found a new site in the anonymity set that I like.)\r\n\r\nI don't think PSK separation even mitigates this. Repeat post-ECH visits still reveal whether resumption happened in ServerHello. And even if we fixed that, depending on how much padding the client is willing to add, the ClientHello size will reveal whether the client had a ticket to offer. I think the only thing PSK separation mitigates is that _immediately_ after the client/server pair deploys ECH, you get to reset the repeat visit counter. But once you count to 2 again, you've got the same signal as before.\r\n\r\n[*] Although there's no actual requirement that the recovery flow use the same ECHConfig as the long-lived DNS config...",
          "createdAt": "2020-11-30T22:02:45Z",
          "updatedAt": "2020-11-30T22:05:20Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> In fact, they didn't even need to query sites the client previously visited.\r\n\r\nWell no, but since they have that information, they can further reduce the anonymity set. (The attacker doesn't need to consider the sites the user never visited.)\r\n\r\nAs soon as you involve non-ECH in a session, the security guarantees just don't hold. I'm fine with just being explicit about that in the draft.",
          "createdAt": "2020-12-10T04:22:34Z",
          "updatedAt": "2020-12-10T04:22:34Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > In fact, they didn't even need to query sites the client previously visited.\r\n> \r\n> Well no, but since they have that information, they can further reduce the anonymity set. (The attacker doesn't need to consider the sites the user never visited.)\r\n> \r\n> As soon as you involve non-ECH in a session, the security guarantees just don't hold. I'm fine with just being explicit about that in the draft.\r\n\r\nThat's probably the best way to resolve this, given the impracticality and constraints (to time of deployment or enablement). I'll have a PR up by the end of the week. \r\n",
          "createdAt": "2020-12-10T15:36:14Z",
          "updatedAt": "2020-12-10T15:36:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That works for me. Thanks, @kjacobs-moz!",
          "createdAt": "2020-12-10T15:58:34Z",
          "updatedAt": "2020-12-10T15:58:34Z"
        }
      ]
    },
    {
      "number": 373,
      "id": "MDU6SXNzdWU3Njg0MTg1MDQ=",
      "title": "CHI vs. CHO when HRR is sent",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/373",
      "state": "OPEN",
      "author": "cbartle891",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "While attempting to draft a change for https://github.com/tlswg/draft-ietf-tls-esni/issues/359, I was confused by this part of section 6.1.4:\r\n\r\n\"If the server sends a HelloRetryRequest in response to the ClientHello, the client sends a second updated ClientHello per the rules in [RFC8446]. However, at this point, the client does not know whether the server processed ClientHelloOuter or ClientHelloInner\"\r\n\r\nWhen does the client learn whether the server processed ClientHelloOuter or ClientHelloInner? If the client sees that the last 8 bytes of ServerHello.random were set to the first 8 bytes of `accept_confirmation`, does it just assume that the first ClientHello that the server processed was a ClientHelloInner? That seems like a big assumption. Couldn't the following happen?:\r\n\r\n```\r\nClient                           Client-facing server             Backend server\r\n              CHO(CHI)\r\n           ------------->\r\n                                   (processes CHO)\r\n                HRR\r\n           <-------------\r\n              CHO(CHI)\r\n           ------------->\r\n                                                          CHI\r\n                                                      ----------->\r\n                                                                  (processes CHI)\r\n                            SH\r\n          <-----------------------------------------------------\r\n\r\n```\r\n\r\nIf this can happen, the client will assume, after it receives the SH, that the server processed the first ClientHelloInner, but this is in fact not the case, and the transcript will break. I mean, I guess that's okay if you don't want this behavior to succeed, but AFAICT, the draft doesn't explicitly say that the client-facing server shouldn't do this. Should it?\r\n\r\n(Sorry if this is in fact already resolved somewhere in the draft. Also I'm pretty sure it's a different issue from https://github.com/tlswg/draft-ietf-tls-esni/issues/333.)",
      "createdAt": "2020-12-16T03:35:19Z",
      "updatedAt": "2020-12-16T18:26:05Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, this is one of the HRR headaches. :-) We don't know until SH whether CHO or CHI was used, so the second ClientHello needs to evaluate _both_ CHO and CHI against HRR. #316 patched the worst of the headache (what if evaluating HRR is an error for CHO but not for CHI?), but it's a really awkward solution.\r\n\r\n(I still need to write up the two HRRs solution we've been muttering about.)",
          "createdAt": "2020-12-16T16:38:12Z",
          "updatedAt": "2020-12-16T16:38:12Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Why can't the backend server just set HelloRetryRequest.random the way it sets ServerHello.random? I believe it'll be a different value in the HRR vs SH if we still care about sticking out, which we don't. ;-) (Or is that one of the two solutions?)",
          "createdAt": "2020-12-16T16:53:12Z",
          "updatedAt": "2020-12-16T16:56:00Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Oh sorry, by \"two HRRs solution\" I didn't mean two solutions for HRR, but a single solution involving two HRRs. :-) )\r\n\r\nAs part of the middlebox compatibility goofiness, a HelloRetryRequest message is encoded as a ServerHello message with a special fixed value for ServerHello.random. It's kind of a mess.\r\n\r\nI suppose we could declare that the HRR indicator is now actually 24 bytes instead of 32 and then reapply the SH.random trick? I dunno, given #358, I figure this ought to look like a HelloRetryRequest.encrypted_client_hello extension (as sticking out in HRR flows is hopeless). That then gives us room to solve #333 and then... yeah that is basically the solution I need to write up. :-)",
          "createdAt": "2020-12-16T17:05:01Z",
          "updatedAt": "2020-12-16T17:05:01Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> (Oh sorry, by \"two HRRs solution\" I didn't mean two solutions for HRR, but a single solution involving two HRRs. :-) )\r\n\r\nOh haha. Read that too fast. Where is this solution described? I don't see it in the open HRR issues.\r\n\r\n> As part of the middlebox compatibility goofiness, a HelloRetryRequest message is encoded as a ServerHello message with a special fixed value for ServerHello.random. It's kind of a mess.\r\n\r\nOh. Is that an implementation detail or part of the spec? I don't see that in section 4.1.4 of RFC 8446.\r\n",
          "createdAt": "2020-12-16T18:00:54Z",
          "updatedAt": "2020-12-16T18:00:54Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Oh haha. Read that too fast. Where is this solution described? I don't see it in the open HRR issues.\r\n\r\nNowhere yet. :-( It's the thing we mumbled about at our last sync and I still need to write up a description.\r\n\r\n> Oh. Is that an implementation detail or part of the spec? I don't see that in section 4.1.4 of RFC 8446.\r\n\r\nLooks like it's spread out a bit. 4.1.4 says:\r\n\r\n> As discussed in Section 4.1.3, the HelloRetryRequest\r\n>   has the same format as a ServerHello message, and the legacy_version,\r\n>   legacy_session_id_echo, cipher_suite, and legacy_compression_method\r\n >  fields have the same meaning.  However, for convenience we discuss\r\n>   \"HelloRetryRequest\" throughout this document as if it were a distinct\r\n>   message.\r\n\r\nAnd then 4.1.3 says:\r\n\r\n>   For reasons of backward compatibility with middleboxes (see\r\n>   Appendix D.4), the HelloRetryRequest message uses the same structure\r\n>   as the ServerHello, but with Random set to the special value of the\r\n>   SHA-256 of \"HelloRetryRequest\":\r\n>\r\n>     CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91\r\n>     C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C\r\n>\r\n>   Upon receiving a message with type server_hello, implementations MUST\r\n>   first examine the Random value and, if it matches this value, process\r\n>   it as described in Section 4.1.4).",
          "createdAt": "2020-12-16T18:07:37Z",
          "updatedAt": "2020-12-16T18:07:37Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Agh, thanks.\r\n\r\n> I suppose we could declare that the HRR indicator is now actually 24 bytes instead of 32 and then reapply the SH.random trick?\r\n\r\nWouldn't that break middleboxes?\r\n\r\n> I figure this ought to look like a HelloRetryRequest.encrypted_client_hello extension\r\n\r\nSGTM",
          "createdAt": "2020-12-16T18:26:05Z",
          "updatedAt": "2020-12-16T18:26:05Z"
        }
      ]
    },
    {
      "number": 374,
      "id": "MDU6SXNzdWU3NzA0MzUwMDI=",
      "title": "Proposal: Introduce HelloRetryRequestOuter/Inner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/374",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I wanted to jot this down before the holidays, in advance of writing a more rigorous PR. This is a proposal to go fix all our HRR problems in one swoop (#233, #373, #358, and #333).\r\n\r\nFirst, whatever our \"don't stick out\" goals are (#354), sticking out on true HRR flows is pretty much hopeless if the attacker is allowed to make a second connection and probe server behavior: replay the first ClientHello and then perturb the second ClientHello's ciphertext. The server can't change its mind after the fact. So I'm going to intentionally give up on that, which means fixing #358 is possible. The proposal is thus:\r\n\r\n* The client sends ClientHelloOuter1 and ClientHelloInner1 as in the current document.\r\n* If client-facing server accepts ECH, it forwards ClientHelloInner1 to the backend server, as before.\r\n* If the backend server sends HelloRetryRequest in response, call this HelloRetryRequestInner.\r\n* The backend server constructs HelloRetryRequestOuter containing the following:\r\n  * An encrypted_client_hello extension with the HelloRetryRequestInner, encrypted with the HPKE context (see open questions).\r\n  * Optionally, a cookie extension with the outer cookie (fixes #333)\r\n  * No other extensions are allowed, though future extensions, if solicited by ClientHelloOuter1 may change this. (See open questions.)\r\n* HelloRetryRequests signals to the client whether ECH was accepted or not (fixes #373, avoids #316) by the presence of the encrypted_client_hello extension:\r\n* If there is no encrypted_client_hello extension, the client computes ClientHello2 based on ClientHelloOuter1 and HelloRetryRequest. There is no more ClientHelloInner2. We're not doing ECH, and HRR may not even be valid for CHI2 (the #316 mess). Instead, it blindly copies over ClientHelloOuter1's extension. This is a waste of bytes, but fixes #358.\r\n* If there is an encrypted_client_hello extension...\r\n  * First, the client decrypts HelloRetryRequestInner. If it fails, it sends decrypt_failure and aborts. GREASE ECH is considered to always fail to decrypt and always sends decrypt_failure.\r\n  * Otherwise, the client computes ClientHelloInner2 based on HelloRetryRequestInner in the usual way, handling errors in the usual way.\r\n  * The client constructs ClientHelloOuter2 containing the encrypted ClientHelloInner2 and HelloRetryRequestOuter.cookie. We know the server is accepting ECH at this point, so there is no need to send much of any other fields. See open questions below.\r\n* HRR or not, the ServerHello is required to have an ECH acceptance confirmation as usual. The client processes it as follows:\r\n  * If there was no HRR, do what the document currently says and figure out ECH acceptance here.\r\n  * If there was an HRR, you already know ECH accept or reject. If ECH reject, move and and complete the outer handshake without any fuss. The inner handshake terminated too early to compute handshake_secret anyway. If ECH accept, check the acceptance confirmation and send illegal_parameter or so if it's wrong. (See open questions below)\r\n\r\nI believe this solves our various HRR problems:\r\n\r\n* The client-facing server can send an HRR cookie without coordinating with the inner handshake (#333).\r\n* The client does not need to evaluate one HRR against two different ClientHellos, so the two ClientHellos can have arbitrarily different preferences (#233, #316).\r\n* The client knows ECH accept at the first server response, so it does not need to construct two different second ClientHellos (#373).\r\n* The ECH extension only changes when solicited (#358).\r\n\r\nThoughts?\r\n\r\n### Open questions\r\n\r\n#### How and should we encrypt HelloRetryRequestInner?\r\n\r\nThe above sketch encrypts HRRInner, but HPKE only allows the sender to encrypt. This is easy to specify though: use the exporters to derive another AEAD key and toss it into the HPKE cipher suite's AEAD.\r\n\r\nAs for why encrypt it, things should still work if we stick it in the clear. But we may want to for two reasons:\r\n\r\n1. Like backend server tickets, backend server cookies are, today, not particularly constrained w.r.t. what they reveal. A ticket or cookie from one TLS implementation may be different from the other, and Split Mode servers may have multiple backend implementations in their anonymity set. It may also vary for other reasons. NewSessionTicket is encrypted, as is the pre_shared_key extension, so we've solved it for tickets. ClientHello.cookie is also encrypted, which leaves HRR.cookie. Encrypting HRRInner fills that in.\r\n2. If HRRInner is not authenticated by the HPKE context, an attacker can try to distinguish GREASE by sending a fake cleartext HRRInner and seeing how the client responds. Authenticating HRRInner means you cannot spoof an inner HRR flow.\r\n\r\nWhether the second property is worthwhile is unclear (https://github.com/tlswg/draft-ietf-tls-esni/issues/354#issuecomment-743924431), but I think the first property is valuable, at which point we get the second anyway.\r\n\r\n#### Other HelloRetryRequestOuter extensions? What is ClientHelloOuter2?\r\n\r\nThis design avoids #316 by assembling a cursory ClientHelloOuter2, rather than actually trying to continue the outer handshake. We would need to decide how to do that. I can think of a few possibilities:\r\n\r\n1. Simply specify throwaway values for all the non-extension fields and declare ClientHelloOuter2 contains exactly two extensions, an optional cookie and encrypted_client_hello. EncodedClientHelloInner2 does not bother with outer_extensions because there is nothing to compress.\r\n2. Make up a new message type to avoid the throwaway fields.\r\n3. ~~Compute an actual ClientHelloOuter2, following RFC8446, based on ClientHelloOuter1 and HelloRetryRequestOuter. If HelloRetryRequestOuter wants to request new key_shares, that's fine. it's just pointless.~~\r\n\r\nI don't like option 3. It's conceptually kinda clever, but adds unnecessary fuss to the protocol. Consider a client which sends CHO1.key_share == CHI1.key_share and compresses them. Key share preferences are rarely secret and this avoids doubling up potentially large post-quantum values.\r\n\r\nThe backend server now requests HRR because it wanted a different key share. So CHI2.key_share != CHI1.key_share and is based on HRRI.key_share. But the client-facing server probably did the straightforward thing and didn't send HRRO.key_share because there's no point. It'll never process CHO2.\r\n\r\nOption 3 would then require that CHO2.key_share == CHO1.key_share because HRRO did not request a change. That means CHO2.key_share != CHI2.key_share and the client must waste a lot of bytes sending two of them. In contrast, options 1 and 2 say that CHO2.key_share doesn't exist anyway, so we only ever send one key share.\r\n\r\nIt also adds implementation complexity to the client, which now needs to evaluate two different full-featured HRRs in one handshake, despite it being unused.\r\n\r\nOption 1 and 2 are basically equivalent, though it's worth noting that HRRO and CHO2 do not _quite_ have the same rules as anymore, so whether we want to stick them in the same message type is interesting...\r\n\r\n#### SH.random acceptance signal after HRR?\r\n\r\nAfter HRR, the SH.random acceptance signal doesn't do anything. We could just as easily omit it, because the client has already gotten the signal. The above sketch keeps it in, mostly for consistency's sake: right now we require that backend servers support the ech_is_inner extension. Getting this wrong will be noticed because the client will not successfully complete the connection. If we omit the acceptance signal in HRR flows, the client will no longer consistently notice. As long as we have this requirement, enforcing it uniformly is more robust, so I'm thinking we keep it in there.\r\n\r\n#### Copy or omit CH2.encrypted_client_hello on reject?\r\n\r\nThis sketch says to copy CH2.encrypted_client_hello on ECH reject. This is a waste of bytes but retains compatibility with RFC8446's rules. In particular, we know of a compatibility issue in #358. It seemed from the WG discussion we generally think the RFC8446 rules are wrong, so we could intentionally break them and drop the extension.\r\n\r\nMy inclination is we should try to get the rule changed and implementations fixed, but maybe that should happen separately from ECH and we copy it for now.",
      "createdAt": "2020-12-17T22:58:11Z",
      "updatedAt": "2021-02-24T04:34:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr, I'm curious what your thoughts are. I remember you said at the WG meeting you wanted to avoid #316 in the final design.",
          "createdAt": "2020-12-17T23:04:00Z",
          "updatedAt": "2020-12-17T23:04:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll need to stew on this for a bit, but I support this idea overall. One request: It seems like some design decisions are aimed at reducing the communication overhead compared to ECH-09. For now, I would prefer we leave out of t he PR any such optimization that adds implementation complexity. In particular, I think the client should compute a real ClientHelloOuter2 as usual (as in option (3.) above) rather than do something different (as in option (1.) or (2.)). The alternatives seem somewhat invasive; and if their only benefit is improved communication overhead, then given how rare the HRR code path is in practice, I don't think it's worth doing.\r\n\r\nAlso, I'm sold on the privacy benefits of encrypting HRRInner. However, I think we should punt this to a future PR. Two reasons. First, I think this privacy consideration is orthogonal to the issue at hand. Second, the details aren't straight-forward; we'll have to agree on how to pick the nonce, associated data, how to pad, and so on. I think we'll do ourselves a big favor by untangling these things :)",
          "createdAt": "2020-12-18T17:50:48Z",
          "updatedAt": "2020-12-18T17:50:48Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The issue with option 3 isn't just communication overhead. It's also implementation cost in mocking out an outer handshake on the client, even though we already know that it will be ignored. Either of options 1 or 2 would be *dramatically* simpler to implement and carry lower risk of mishaps from the complexity.",
          "createdAt": "2020-12-19T20:39:33Z",
          "updatedAt": "2020-12-19T20:39:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've updated the description in the PR to make this clearer. The only benefit of option 3 is as a conceptual reference or perhaps something to profile down from. As an actual protocol, it's a not a good option.",
          "createdAt": "2020-12-19T20:42:24Z",
          "updatedAt": "2020-12-19T20:43:50Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> After HRR, the SH.random acceptance signal doesn't do anything. We could just as easily omit it, because the client has already gotten the signal.\r\n\r\nI don't really understand this. Sure, the client gets the signal that the backend server sent the HRR, but without SH.random, how can the client be sure the client-facing server didn't send the SH? The handshake will ultimately fail because the transcripts won't match, but not until then. Isn't it better if the client is able to terminate immediately after receiving the SH?\r\n\r\n> The backend server now requests HRR because it wanted a different key share. So CHI2.key_share != CHI1.key_share and is based on HRRI.key_share. But the client-facing server probably did the straightforward thing and didn't send HRRO.key_share because there's no point. It'll never process CHO2.\r\n\r\nWait why would the client-facing server send anything at all in this case? Doesn't the backend server send the HRR to the client without (ideally) any modification from the client-facing server?",
          "createdAt": "2021-01-09T04:19:39Z",
          "updatedAt": "2021-01-09T04:19:39Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">> After HRR, the SH.random acceptance signal doesn't do anything. We could just as easily omit it, because the client has already gotten the signal.\r\n>\r\n> I don't really understand this. Sure, the client gets the signal that the backend server sent the HRR, but without SH.random, how can the client be sure the client-facing server didn't send the SH? The handshake will ultimately fail because the transcripts won't match, but not until then. Isn't it better if the client is able to terminate immediately after receiving the SH?\r\n\r\nDo you mean a malicious or well-behaved client-facing server? A well-behaved client-facing server doesn't get to change its mind about whether ECH was accepted partway through. If we've got an HRR from the backend server, the SH will be from the backend server too.\r\n\r\nIf it's a malicious client-facing server, yeah, we're relying on how TLS defends against network attackers, including how it uses the transcript. But that's true of TLS in general. If we're worried about when the client notices, the transcript figures into handshake encryption, CertificateVerify, and Finished, which are all in the same flight as ServerHello. (Plus the SH.random signal is all of 8 bytes, so it's not especially cryptographically significant.)\r\n\r\n(But I don't think we should omit it anyway. Just observing that we could.)\r\n\r\n>> The backend server now requests HRR because it wanted a different key share. So CHI2.key_share != CHI1.key_share and is based on HRRI.key_share. But the client-facing server probably did the straightforward thing and didn't send HRRO.key_share because there's no point. It'll never process CHO2.\r\n>\r\n> Wait why would the client-facing server send anything at all in this case? Doesn't the backend server send the HRR to the client without (ideally) any modification from the client-facing server?\r\n\r\nRight. I'm saying I don't like option 3 because it _allows_ the client-facing server to send HRROuter.key_share. That means the client must have code to handle it. And then we need to reason about how this mess interacts with not wanting to waste bytes in the second ClientHello sending two key shares. And, despite all that complexity, the client-facing server doesn't actually care, so we made everything a mess for nothing.\r\n\r\nThus, option 3 is a useful conceptual reference, but I don't think we should actaully do it.",
          "createdAt": "2021-01-11T19:53:53Z",
          "updatedAt": "2021-01-11T19:54:17Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> If we're worried about when the client notices, the transcript figures into handshake encryption, CertificateVerify, and Finished, which are all in the same flight as ServerHello. (Plus the SH.random signal is all of 8 bytes, so it's not especially cryptographically significant.)\r\n\r\n> (But I don't think we should omit it anyway. Just observing that we could.)\r\n\r\nOk, cool.\r\n\r\n> I'm saying I don't like option 3 because it allows the client-facing server to send HRROuter.key_share. That means the client must have code to handle it.\r\n\r\nAha, ok.\r\n",
          "createdAt": "2021-01-11T21:15:02Z",
          "updatedAt": "2021-01-11T21:15:10Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "This sounds good to me then. I'm sold on encrypting the HRRInner to prevent cookie fingerprinting.",
          "createdAt": "2021-01-11T21:25:00Z",
          "updatedAt": "2021-01-11T21:25:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm sold as well. I'd say this issue is ready for text.",
          "createdAt": "2021-01-19T19:06:04Z",
          "updatedAt": "2021-01-19T19:06:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben, when do you think you can get to a PR for this? ",
          "createdAt": "2021-02-24T04:34:31Z",
          "updatedAt": "2021-02-24T04:34:31Z"
        }
      ]
    },
    {
      "number": 375,
      "id": "MDU6SXNzdWU3OTM4NTc0NTM=",
      "title": "Replace config_id with a server-chosen key_id",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/375",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After very useful discussion with many folks, it seems now is the time to remove config_id. There are a couple reasons to do this:\r\n\r\n- Servers need to know the correct hash function to use when computing the ID, and possibly need to compute multiple IDs for a given public key (since a config can have multiple hash-based KDFs), which is somewhat annoying and redundant.\r\n- The entire ECHConfig is already authenticated, so using a hash to prove that the client made a determination based on the correct config contents is unnecessary.\r\n- Servers will likely only ever have a small handful of keys in motion at any point in time, so anything more than a couple of bits to identify one of said keys is excessive.\r\n- ... there are probably more.\r\n\r\nThe original design [had a server-chosen label, but we removed it](https://github.com/tlswg/draft-ietf-tls-esni/pull/43). (Oops!) It seems we're now in a better position to bring this back, but with some simplifications. ",
      "createdAt": "2021-01-26T01:46:27Z",
      "updatedAt": "2021-02-15T20:08:01Z",
      "closedAt": "2021-02-15T20:08:01Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nHiya,\n\nOn 26/01/2021 01:46, Christopher Wood wrote:\n> After very useful discussion with many folks, \n\nCan you send a pointer to those discussions? (Sorry, I seem\nto have missed 'em;-)\n\nTa,\nS.\n",
          "createdAt": "2021-01-26T01:56:13Z",
          "updatedAt": "2021-01-26T01:56:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can you send a pointer to those discussions? (Sorry, I seem to have missed 'em;-)\r\n\r\nSorry -- these were informal conversations off-list.\r\n",
          "createdAt": "2021-01-26T02:29:02Z",
          "updatedAt": "2021-01-26T02:29:02Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 26/01/2021 02:29, Christopher Wood wrote:\n>> Can you send a pointer to those discussions? (Sorry, I seem to have missed 'em;-)\n> \n> Sorry -- these were informal conversations off-list.\n\nAh. That's a recurring problem. And even this exchange is\nactually off-list.\n\nCan we please fix that? I think I've whined about that a\nfew times now, and would hope that continual whining is\nnot a requirement;-)\n\nS.\n\n\n> \n> \n",
          "createdAt": "2021-01-26T02:35:03Z",
          "updatedAt": "2021-01-26T02:35:03Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can we please fix that? I think I've whined about that a\r\nfew times now, and would hope that continual whining is\r\nnot a requirement;-)\r\n\r\nFix what? A few of us had a private conversation about some ideas and came to the conclusion that it would be better to replace the hash with a key_id. Then Chris and Martin brought it to a Github issue. This is precisely in line with the WG consensus to use Github issue discussion mode, as documented in 8874 S 5.3. \r\n",
          "createdAt": "2021-01-26T02:38:24Z",
          "updatedAt": "2021-01-26T02:38:48Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 26/01/2021 02:38, ekr wrote:\n> \n> Fix what? A few of us had a private conversation about some ideas \n\nI'm guessing that was a private discussion amongst what could\nwell be described as the usual suspects or an old-boys club\n(or are a few of you \"many folks?\"). Correct me if I'm wrong\nbut that had zero visibility and zero traceability and zero\naccountability for anyone who isn't one of those old boys.\n\nAnd yet we're zapping a field in a PDU from what was declared\nas an \"implementation draft\" a day or so after one major\ndeployment declared they had an interop target. To me, that\nsmells of disrespect for outsiders tbh.\n\nYou can probably guess what I think about that state of\naffairs:-)\n\n> and\n> came to the conclusion that it would be better to replace the hash\n> with a key_id. Then Chris and Martin brought it to a Github issue.\n> This is precisely in line with the WG consensus to use Github issue\n> discussion mode, as documented in 8874 S 5.3.\nI don't buy that tbh. Chris' mail was presented as a\nconclusion, from a wg-chair following a private discussion\nthat for sure excluded some implementers. (Me being one,\nalbeit a not very good one:-)\n\nAnd you yourself are an ex WG-chair so I'd guess you ought\nalso care about exclusivity here. What gain is there from\nthat kind of behaviour? I don't see it myself.\n\nIMO, there is no need nor benefit from being so exclusive\nwrt this spec, yet that is what is happening and has been\nfor a few years. I'd encourage those of you who may be\n\"old-boys\" to consider whether or not that is really the\nbest way to proceed. IMO - it is not, you lose way more than\nyou might think you gain, almost all the time.\n\nCheers,\nS.\n\nPS: I don't disagree with the outcome, though have opinions\non what -10 might contain. I do very much dislike the awful\nprocess, which is my point here.\n\n\n",
          "createdAt": "2021-01-26T03:02:46Z",
          "updatedAt": "2021-01-26T03:02:46Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "NONE",
          "body": "@sftcd I would completely agree with you had the proposed PR been merged and the associated issue been closed. That has not happened. Further, it appears that you might be reading a bit more into Chris' issue summary than is really there. He is not acting in his WG chair capacity here because he is an author; I know he knows that and I really hope you can give him the benefit of the doubt here so that we do not have to suffer the \"no WG chair hat on\" in every message/post.\r\n\r\nThe process, as I see it, is pretty darn near normal. Somebody files an issue and optionally (but preferably) files a PR to address said issue. Discussion ensues amd if substantive it's taken to the list. The PR may or may not be modified based on that discussion. If consensus is reached, the PR is merged and the issue is closed.\r\n\r\nWe are at the discussion point. Can we do that now?",
          "createdAt": "2021-01-28T16:56:39Z",
          "updatedAt": "2021-01-28T16:56:39Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 28/01/2021 16:56, Sean Turner wrote:\n> @sftcd I would completely agree with you had the proposed PR been\n> merged and the associated issue been closed. That has not happened.\n> Further, it appears that you might be reading a bit more into Chris'\n> issue summary than is really there. He is not acting in his WG chair\n> capacity here because he is an author; I know he knows that and I\n> really hope you can give him the benefit of the doubt here so that we\n> do not have to suffer the \"no WG chair hat on\" in every\n> message/post.\n\nPerhaps it'd be better to not start a mail with \"After very\nuseful discussion with many folks, it seems now is the time to remove \nconfig_id.\" in cases where that discussion was\npurely private? I can understand it being hard to keep track\nwith the various tools, but for me, that still reads as a\ndecision being announced even if that was not the intent.\n\nSorry for being over-sensitive to this but IMO there is a\nhistory and ongoing tendency with this spec for a subset of\npeople to act as if they and not the IETF/WG have change\ncontrol. I fully accept that they are not deliberately\naiming to avoid having to garner WG consensus but consider\nthat ongoing instances of carelessness such as the above\ndemonstrate that there is an insider/outsider thing going\non here.\n\nS.\n\n> \n> The process, as I see it, is pretty darn near normal. Somebody files\n> an issue and optionally (but preferably) files a PR to address said\n> issue. Discussion ensues amd if substantive it's taken to the list.\n> The PR may or may not be modified based on that discussion. If\n> consensus is reached, the PR is merged and the issue is closed.\n> \n> We are at the discussion point. Can we do that now?\n> \n",
          "createdAt": "2021-01-28T17:20:43Z",
          "updatedAt": "2021-01-28T17:20:43Z"
        }
      ]
    },
    {
      "number": 378,
      "id": "MDU6SXNzdWU4MDI1NDE2MDg=",
      "title": "Naive outer_extensions decoding is a DoS risk",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/378",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A naive implementation of decoding the inner ClientHello can easily go quadratic when processing outer_extensions. Thus far, nothing in TLS has required searching for O(N) extensions, only O(implemented extensions). It's likely a lot of TLS implementations handle the extensions list linearly most of the time.\r\n\r\nouter_extensions is now the first time you have to search for extensions you may not have implemented. A naive implementation would then go quadratic, which is a server DoS risk. It doesn't need to go quadratic (for instance, you can sort ClientHelloOuter's extensions and then binary search per lookup), but it's probably worth at least calling this out, if not switching to a simpler decoding scheme.\r\n\r\n(For a simpler decoder, we already require CHInner group the compressed extensions consecutively. We could do the same with CHOuter, at which point we only need to reference one byte slice, be it by offset/length or some goofier scheme.)",
      "createdAt": "2021-02-05T23:33:28Z",
      "updatedAt": "2021-03-08T16:51:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 05/02/2021 23:33, David Benjamin wrote:\n> A naive implementation of decoding the inner ClientHello can easily\n> go quadratic when processing outer_extensions. Thus far, nothing in\n> TLS has required searching for O(N) extensions, only O(implemented\n> extensions). It's likely a lot of TLS implementations handle the\n> extensions list linearly most of the time.\n> \n> outer_extensions is now the first time you have to search for\n> extensions you may not have implemented. A naive implementation would\n> then go quadratic, which is a server DoS risk. It doesn't need to go\n> quadratic (for instance, you can sort ClientHelloOuter's extensions\n> and then binary search per lookup), but it's probably worth at least\n> calling this out, if not switching to a simpler decoding scheme.\n\nSwitching to a simpler scheme: yes please. Just dropping the\ncompression idea entirely: even better:-)\n\nGiven this optimisation is really mostly for PQ schemes, I'd\nargue it'd be better to just drop the current idea and have\na more constrained one, e.g. using a bit mask as the value\nof outer_extensions, so implementation know exactly which\nextensions can ever be copied from the outer CH.\n\nAnd I'd further argue we can leave defining all of that\nuntil later too.\n\nThe current scheme also imposes quite a testing burden.\nAt least with OpenSSL most extensions have some side-effect\nand testing that all combinations of those are handled\ncorrectly for the inner CH isn't trivial. (That's partly\ndown to old code being a bit awful but I guess won't be\nsimple for any code base.)\n\nCheers,\nS.\n\n\n\n> \n> (For a simpler decoder, we already require CHInner group the\n> compressed extensions consecutively. We could do the same with\n> CHOuter, at which point we only need to reference one byte slice, be\n> it by offset/length or some goofier scheme.)\n> \n",
          "createdAt": "2021-02-06T00:01:19Z",
          "updatedAt": "2021-02-06T00:01:19Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not sure I follow the concern with side effects. Are you processing the extensions as part of decompression?\r\n\r\nIn order to make the handshake work, you'd have to construct the ClientHello by bytes anyway. Thus it seems the natural implementation would be to resolve ECH early, before ClientHello processing, then compute the inner ClientHello as bytes, then run the handshake with the resulting ClientHello. This aligns nicely with the model in split mode, etc.\r\n\r\nThe issue I have in mind is simply that the decoding process, a pure function from a pair of byte strings to a byte string, is easy to accidentally make inefficient.",
          "createdAt": "2021-02-06T03:35:41Z",
          "updatedAt": "2021-02-06T03:35:41Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We could do the same with CHOuter, at which point we only need to reference one byte slice, be it by offset/length or some goofier scheme.\r\n\r\nIt occurs to me this might cause some conflicts between wanting ECH-ful and ECH-less ClientHellos to look similar (don't stick out) and pressures on ClientHello extension order. The order *should* be irrelevant, but compat concerns have cropped up before. (If only we required extensions be sorted...)\r\n\r\nAnother possibility for a simpler decode would be if outer_extensions listed indexes into the extension list, rather than extension IDs. Though we would need to answer silly questions like whether it's an index into ClientHelloOuter or ClientHelloOuterAAD.",
          "createdAt": "2021-02-08T22:51:32Z",
          "updatedAt": "2021-02-08T22:51:32Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Since this is more of an implementation detail, let's just add a warning to handle this responsibly (i.e. the sort and binary search).",
          "createdAt": "2021-02-16T21:37:31Z",
          "updatedAt": "2021-02-16T21:37:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yet another way to address this is with a simple hash map, e.g.: https://github.com/cloudflare/go/blob/cf/src/crypto/tls/ech.go#L652-L768.\r\n\r\nMy vote is to leave the encoding scheme as-is and simply leave a warning.",
          "createdAt": "2021-02-18T20:14:07Z",
          "updatedAt": "2021-02-18T20:14:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d @cjpatton, @cbartle891, could one of you please propose text for that warning?",
          "createdAt": "2021-02-18T23:13:12Z",
          "updatedAt": "2021-02-18T23:13:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another DoS risk to be careful of: implementations typically enforce size limits on TLS messages so they aren't forced to buffer 2^24 bytes. Whatever size limit is enforced on ClientHello needs to also be enforced on the inner ClientHello *before* allocating memory for it.\r\n\r\nIn particular, if ClientHelloOuter has a single giant extension, and it is referenced multiple times in OuterExtensions, you can blow up the server's resource usage. (Though I can't think of any case without repeating an extension where the resulting size grows dramatically.)",
          "createdAt": "2021-02-20T23:11:45Z",
          "updatedAt": "2021-02-20T23:11:45Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there any valid reason why an extension would appear multiple times in a ClientHello? If not, maybe we should specify that the server must abort if OuterExtensions references an extension more than once.",
          "createdAt": "2021-02-22T17:18:47Z",
          "updatedAt": "2021-02-22T17:18:47Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems reasonable. I think the combination of \"no duplicate extensions\" and \"no referencing the ECH extension\" imply that sizeof(ClientHelloInner) < sizeof(ClientHelloOuter).",
          "createdAt": "2021-02-22T19:50:41Z",
          "updatedAt": "2021-02-22T19:50:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Keeping this opening to track @davidben's and @sftcd's comments on CH sizes. @sftcd, could you please send a PR if you have cycles?",
          "createdAt": "2021-02-23T01:37:42Z",
          "updatedAt": "2021-02-23T01:44:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in 110: Will propose text to address the second vector and then close this issue.",
          "createdAt": "2021-03-08T16:51:11Z",
          "updatedAt": "2021-03-08T16:51:11Z"
        }
      ]
    },
    {
      "number": 379,
      "id": "MDU6SXNzdWU4MDQwMjE1NjY=",
      "title": "Consider a shorter config ID length",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/379",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Assuming #376 lands, we need to decide how long we want this server-chosen identifier to be. There are various operational and privacy considerations at play. For example, shorter identifiers mean that GREASE clients may produce colliding values with higher probability, and the cost of trial decryption on the server may be an overly expensive operational cost for some deployments. Longer identifiers may also mean that using keys as a tracking vector is easier. (But as @ekr has pointed out, ECH does not assume DNS answer integrity, so there are other tracking mechanisms at play.) Let's use this issue to sort out this question. \r\n\r\ncc @davidben, @cjpatton, @martinthomson ",
      "createdAt": "2021-02-08T22:27:58Z",
      "updatedAt": "2021-03-08T16:40:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(This may just be me misinterpreting what you wrote.) Why would a GREASE/real ID collision be expensive operationally? I could see being concerned about perf costs (the connection needs 1 HPKE op instead of 0), but I'm not sure I see the operational concern.",
          "createdAt": "2021-02-08T22:33:57Z",
          "updatedAt": "2021-02-08T22:33:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Why would a GREASE/real ID collision be expensive operationally? \r\n\r\nIf GREASE collides with a real key ID, then the server attempts decryption to only see that it fails, and then falls back. (The chances of that collision happening are pretty high with a 1-byte ID.) So, yeah, \"expensive operationally\" is \"1 HPKE operation instead of 0.\" Whether or not that's an issue seems server-specific.",
          "createdAt": "2021-02-08T23:48:09Z",
          "updatedAt": "2021-02-08T23:48:09Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, okay. I interpreted \"expensive operationally\" to mean there was some operational challenge, but you just mean it might not perform well in some deployments.",
          "createdAt": "2021-02-08T23:52:18Z",
          "updatedAt": "2021-02-08T23:52:18Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Although, presumably no less well than connections that actually enable ECH.",
          "createdAt": "2021-02-08T23:53:11Z",
          "updatedAt": "2021-02-08T23:53:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From my perspective, I am totally comfortable with a 1/64 (approximately) chance of hitting that 1 bogus HPKE operation.  A server that offers ECH has to be prepared for every connection it receives to use ECH.\r\n\r\nBut I don't operate a server, so take that position with that in mind.",
          "createdAt": "2021-02-09T00:06:19Z",
          "updatedAt": "2021-02-09T00:06:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> From my perspective, I am totally comfortable with a 1/64 (approximately) chance of hitting that 1 bogus HPKE operation.  A server that offers ECH has to be prepared for every connection it receives to use ECH.\n\nLikewise. I see little reason for anything longer than a byte here.",
          "createdAt": "2021-02-09T00:29:58Z",
          "updatedAt": "2021-02-09T00:29:58Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also am not worried about a non-negligible probability of a greased config_id colliding with a real config_Id. I think a more important consideration that came up in #376 is dealing with two real configs having the same config_id. In particular, I think the spec should make it easy for servers to avoid collisions altogether. That way the server doesn't have to resort to trial decryption in case of a collision.\r\n\r\nAt the same time, we need to make it easy for clients to grease. As has been suggested, if we want a 1-byte config_id, I think we should mandate the config_id be chosen at random, but permit rejection sampling in order to allow the server to avoid collisions. This seems like a funky requirement to put in a spec, but also seems perfectly fine from a technical perspective.\r\n\r\n",
          "createdAt": "2021-02-09T20:08:32Z",
          "updatedAt": "2021-02-09T20:12:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd be fine with that as the RECOMMENDED way to generate these identifiers. Perhaps the text could say something like the following?\r\n\r\n> The RECOMMENDED technique for generating a new ECHConfig.config_id is to choose a random byte. This process should be repeated if this config_id matches that of any existing and valid ECHConfig.\r\n\r\nOf course, clients can't validate that servers do this, so the best we can do is recommend some best practice here.",
          "createdAt": "2021-02-09T21:43:31Z",
          "updatedAt": "2021-02-09T21:43:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That seems like a reasonable outcome.  It require coordination, but at a level at which I think is reasonable (you don't want independent processes feeding ECH keys into the system, that is a recipe for failure).",
          "createdAt": "2021-02-10T00:26:49Z",
          "updatedAt": "2021-02-10T00:26:49Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Works for me!",
          "createdAt": "2021-02-10T16:36:04Z",
          "updatedAt": "2021-02-10T16:36:04Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "Can we use an arbitrary length, up to some length, but with a recommendation to use one byte where possible?  There are a number of deployment environments where it may be preferable to use longer config_ids (eg, using a 8-byte config_id would allow for using a hash of a public key as the config_id without needing to do trial-decryption or demuxing).  Server operators who want to abuse this could just not enable ECH or could use a large number of IP addresses.",
          "createdAt": "2021-03-08T16:31:20Z",
          "updatedAt": "2021-03-08T16:31:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in 110: Poll suggested most folks were in favor of 1 byte. We'll move ahead with this plan.",
          "createdAt": "2021-03-08T16:39:39Z",
          "updatedAt": "2021-03-08T16:40:02Z"
        }
      ]
    },
    {
      "number": 380,
      "id": "MDU6SXNzdWU4MDc2MDc5OTI=",
      "title": "Related Privacy Leaks suggests too strong of a correlation across resumption",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/380",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(Filing this as a separate ticket so I don't forget to propose new text.)\r\n\r\n#371 added this text:\r\n\r\n> Attacks that rely on non-ECH traffic to infer server identity in an ECH connection are \r\n> out of scope for this document. For example, a client that connects to a particular host \r\n> prior to ECH deployment may later resume a connection to that same host after ECH \r\n> deployment, thereby linking the resulting ECH connection to the original non-ECH \r\n> connection.\r\n\r\nI think this statement is a bit strong and overstates the issue. It reads as if resuming connections across ECH and non-ECH links the two connections.\r\n\r\nIf we're talking about someone other than the server, this isn't true. Tickets are issued encrypted and, in ECH, even sent encrypted. Even if they were sent in the clear, TLS 1.3's [single-use tickets](https://tools.ietf.org/html/rfc8446#appendix-C.4) protects against such correlations. Rather, the correlation in #369 is a much weaker one: based on either the size of the ClientHello or whether the server accepted the ticket, you learn a single bit for whether it was *some* previous connection made by that client. You don't know which previous connection it was, and you don't know if it was an ECH connection or a non-ECH connection. In fact what you learn... more-or-less aligns with the anonymity set. See https://github.com/tlswg/draft-ietf-tls-esni/issues/369#issuecomment-736083162.\r\n\r\n(If we're talking about the server, yes, resuming allows the server to link the two connections. That's fundamental to resumption and is in the purview of https://github.com/tlswg/tls13-spec/pull/1205. I don't think most applications would consider ECH vs non-ECH a correlation boundary w.r.t. the server itself.)",
      "createdAt": "2021-02-12T23:17:13Z",
      "updatedAt": "2021-02-17T20:20:55Z",
      "closedAt": "2021-02-17T20:20:55Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The original text doesn't necessarily imply that on-the-wire tickets are the linking factor. Rather that the shape of the handshake, time it takes to complete, etc, can be a proxy for whether or not resumption occurred. I don't think we need to change anything here. (But I also would not object to someone else sending a PR!) ",
          "createdAt": "2021-02-15T17:06:58Z",
          "updatedAt": "2021-02-15T17:07:17Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(This came up in a discussion between me and @dmcardle.)\r\n\r\nSo, the current text says \"For example, a client that [does X] may [do Y], thereby linking the resulting ECH connection to the original non-ECH connection\". That implies that doing X and Y allows linking the two connections together.\r\n\r\nYou're right that tickets may not be the only linking factor, but the other channels don't let you link connections, only, as you say, *whether or not resumption occurred*. That single boolean doesn't tell you which non-ECH connection corresponded to the ECH connection, or what the name was. It only tells you that it's the same name as *some* previous connection to the anonymity set. It might be a non-ECH one (but you don't know which) or it might be an ECH one.",
          "createdAt": "2021-02-16T21:48:07Z",
          "updatedAt": "2021-02-16T21:48:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Feel free to suggest text to reword this. I think the example was meant to be general enough to suggest that side channels exist. I definitely do not feel strongly about the exact wording here. ",
          "createdAt": "2021-02-16T23:30:17Z",
          "updatedAt": "2021-02-16T23:30:17Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that the text as-is overstates the issue.",
          "createdAt": "2021-02-17T01:11:45Z",
          "updatedAt": "2021-02-17T01:11:45Z"
        }
      ]
    },
    {
      "number": 384,
      "id": "MDU6SXNzdWU4MTEzOTk0OTM=",
      "title": "PSK usage sticks out",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/384",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "As discussed in #354, there are two real-ECH/grease-ECH differentiators related to the PSK extension we may wish to address.\r\n\r\n1. Real ECH disallows the PSK extension in ClientHelloOuter, whereas grease ECH permits PSK in ClientHello.\r\n2. Real ECH allows PSK in ClientHelloInner. In case of acceptance, the backend server may respond with PSK in ServerHello. The response would appear to be unsolicited. something that would not happen in a grease-ECH or vanilla handshake.\r\n\r\nThe question we will ask ourselves here is if/how to mitigate these differentiators. We might simply say that clients MAY (or SHOULD?) send a dummy PSK in the ClientHello(Outer). This ought to provide sufficient cover.",
      "createdAt": "2021-02-18T19:38:54Z",
      "updatedAt": "2021-03-08T16:24:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't mind a MAY on sending a dummy PSK in case (2), though I don't think it's a good idea for case (1). The case that really matters here is when the outer and inner ClientHello both lack PSKs:\r\n\r\nSuppose the buggy network is sensitive to (1) and only allows ECH extensions when the outer ClientHello has a PSK because it knows those can't be ECH. That network has effectively broken _all_ connections because the only way for the client to get a PSK is to have connected to the server without a PSK at some point.\r\n\r\nSuppose instead the buggy network is sensitive to (2) and breaks if the inner ClientHello has a PSK but the outer does not. The connect will fail, but between single-use tickets and bounded client session caches, the client will quickly exhaust its tickets and get out of case (2). This is a performance issue, but the connections still work. (Though, yeah, adding the option to send a dummy one might help there. *shrug*)",
          "createdAt": "2021-02-18T22:23:58Z",
          "updatedAt": "2021-02-18T22:23:58Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not following the following point. Could you elaborate?\r\n\r\n> Suppose the buggy network is sensitive to (1) and only allows ECH extensions when the outer ClientHello has a PSK because it knows those can't be ECH. That network has effectively broken _all_ connections because the only way for the client to get a PSK is to have connected to the server without a PSK at some point.\r\n\r\nIn any case, the case to mitigate (2) seems more compelling than the case to mitigate (1), since (2) would look like non-compliance to an ECH-ignorant network. Would be curious to see what others think.\r\n\r\n\r\n\r\n",
          "createdAt": "2021-02-19T16:21:25Z",
          "updatedAt": "2021-02-19T16:21:25Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So I think the benefit of GREASE-like strategies is that broader breakages now are more noticeable than focused breakage later. More noticeable breakage is more likely to be fixed, and less likely to make it to the ecosystem in the first place. This applies to ECH GREASE by saying we want all ClientHellos to look like ECH was deployed, so the network is less likely to develop intolerances.\r\n\r\nDifferences between GREASE ECH and actual ECH thus matter because the network be intolerant to something that we failed to simulate. (1) says that, in actual ECH, all outer ClientHellos have no PSK. In GREASE ECH, some outer ClientHellos have a PSK while some do not. If we were to translate that to actual intolerance, it would mean the network rejects outer ClientHellos without a PSK. But that would break everything, ECH or non-ECH, anyway because clients don't send PSKs the first time[*] they connect to a server. Clients only have PSKs to send the second time, and you can't connect a second time if you didn't connect a first time. Thus, even though (1) is a difference, it doesn't seem that difference prevents us from noticing intolerance.\r\n\r\nAgreed that mitigating (2) is more compelling than mitigating (1).\r\n\r\n[*] First time overall, first time after a restart (if sessions aren't persisted), or first time after a long break (sessions expired).",
          "createdAt": "2021-02-19T19:35:14Z",
          "updatedAt": "2021-02-19T19:37:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that (2) is more important. And I'm fine with a \"MAY/SHOULD send an outer dummy PSK if you are using ECH and have an inner PSK.\" @davidben, if we were to append on a dummy PSK, what do you think would be a suitable length? (Bikeshedding over that should be fun.)\r\n\r\nAs an aside, I wanted to drill in on this point:\r\n\r\n> If we were to translate that to actual intolerance, it would mean the network rejects outer ClientHellos without a PSK. But that would break everything, ECH or non-ECH,\r\n\r\nThis seems true, if we're assuming the the intolerance is \"break the connection,\" which I think is the right interpretation. But it occurs to me that there's a slightly weaker form of misbehavior thats's possible with (1): a network may learn information about when a given client uses ECH. This seems out of scope, but maybe something to keep in mind?",
          "createdAt": "2021-02-20T01:41:56Z",
          "updatedAt": "2021-02-20T01:41:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Re length, I dunno leave it to the client to choose? \"Probably not very long.\"\r\n\r\nMaking that in scope sounds exceedingly difficult. For instance, for a given server, you might know that tickets issued today start with 12345 (maybe the ID of today's key), but synthesized dummy tickets won't match that.",
          "createdAt": "2021-02-22T23:26:36Z",
          "updatedAt": "2021-02-22T23:26:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Making that in scope sounds exceedingly difficult. \r\n\r\nYep, no argument there. ",
          "createdAt": "2021-02-22T23:27:35Z",
          "updatedAt": "2021-02-22T23:27:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in 110: Will submit a PR that says \"clients MAY send a dummy PSK if the inner CH uses a PSK.\" ",
          "createdAt": "2021-03-08T16:24:27Z",
          "updatedAt": "2021-03-08T16:24:27Z"
        }
      ]
    },
    {
      "number": 386,
      "id": "MDU6SXNzdWU4MTI0NzQ2NjQ=",
      "title": "Fixed-length values should probably be fixed-length",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/386",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the `ECHConfigContents` struct, we have the following:\r\n\r\n```\r\n    opaque HpkePublicKey<1..2^16-1>;\r\n    ...\r\n\r\n    struct {\r\n        ...\r\n        HpkeKemId kem_id;\r\n        HpkePublicKey public_key;\r\n        ...\r\n    } HpkeKeyConfig;\r\n```\r\n\r\n`HpkeKeyConfig.public_key` is a serialized HPKE public key. However, these keys have a fixed length (`Npk`). We can remove the length prefix around this value and simple define `HpkePublicKey` like so:\r\n\r\n```\r\nopaque HpkePublicKey[Npk];\r\n```\r\n\r\nParsing shouldn't be an issue, since consuming clients first parse the `HpkeKeyConfig.kem_id`. If this corresponds to an unknown KEM, they can't use the `HpkeKeyConfig` or parent `ECHConfigContents`, and can move onto the next `ECHConfig` in the list to check. \r\n\r\nWe may also do this for `ClientECH`, which length-prefixes the `enc` field (of fixed length `Nenc`), but that might complicate  trial decryption use cases. \r\n\r\nNote that [KeyShareEntry keys](https://tools.ietf.org/html/rfc8446#section-4.2.8) are length-prefixed, but I don't think we need to follow that guidance here. HPKE exposed fixed-length keys for a reason. :-) \r\n\r\ncc @martinthomson ",
      "createdAt": "2021-02-20T01:30:11Z",
      "updatedAt": "2021-03-08T16:45:45Z",
      "closedAt": "2021-03-08T16:45:45Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in 110: Makes general purpose parsers more difficult. Closing as a result.",
          "createdAt": "2021-03-08T16:45:45Z",
          "updatedAt": "2021-03-08T16:45:45Z"
        }
      ]
    },
    {
      "number": 387,
      "id": "MDU6SXNzdWU4MTI0Nzc5NDc=",
      "title": "Update to HPKE-08",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/387",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "ready-for-text"
      ],
      "body": "This new version of the draft removes the version-vector dependency, so this should be the last time we update the pinned version.",
      "createdAt": "2021-02-20T01:45:52Z",
      "updatedAt": "2021-02-24T18:05:13Z",
      "closedAt": "2021-02-24T18:05:13Z",
      "comments": []
    },
    {
      "number": 388,
      "id": "MDU6SXNzdWU4MTQwMDMyMDg=",
      "title": "Include changelog going forward",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/388",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Since -09 is the first \"official\" interop target, we should make it easy going forward to track deltas between versions. Let's add a changelog for each revision of the draft to help implementers out.",
      "createdAt": "2021-02-23T01:09:13Z",
      "updatedAt": "2021-03-08T18:54:58Z",
      "closedAt": "2021-03-08T18:54:58Z",
      "comments": []
    },
    {
      "number": 389,
      "id": "MDU6SXNzdWU4MTQxNDU1MjM=",
      "title": "Public name rewriting",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/389",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Is there any sense in having the server validate the value of the server name indication extension in the outer ClientHello?  It seems like it might help avoid a trivial attack on DNS that might otherwise pass without notice or alarm.  That is, an attack that copies the DNS QNAME in the public_name field.  \r\n\r\nThere are various ways in which this might fail, but none of the scenarios that I can think of result in anything that a client or server might recognize as being alarming.\r\n\r\nIt is easy to detect and prevent this sort of interference: the client-facing server checks that the SNI matches the value it expects from the ECHConfig that has been selected.  If the config might have changed, such that multiple values are valid, then the server can allow for that, but generally there will be just one valid value.",
      "createdAt": "2021-02-23T06:08:09Z",
      "updatedAt": "2021-03-01T04:32:07Z",
      "closedAt": "2021-03-01T04:32:07Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nHiya,\n\nOn 23/02/2021 06:08, Martin Thomson wrote:\n> Is there any sense in having the server validate the value of the\n> server name indication extension in the outer ClientHello?  \n\nI think that check ought, at best, be a MAY, and not a\nMUST. The reason being to support non-browser clients,\nand as a possible additional hedge for circumvention\ntools (that may also be non-browser clients). I also\nsuspect, but don't know, that omitting such checks might\nimprove some hosting scenarios that could otherwise be\na pain - where the hoster's lookup of any sni value\nis an expensive DB access to load the right key pair\nand cert. (Sure, that could be optimised but then we'd\nbe adding yet more complexity to ECH deployment, which\nis worse than even all the complexity we've added to\nimplementation;-)\n\nFor example, when we've done work on curl, we allow\nan optional name on the command line that then overrides\nthe ECHConfig.public_name. I don't see any reason to\nprevent that TBH. And I reckon it could enable some\npossibly interesting use-cases there's no reason for\nus to prevent.\n\n> It seems\n> like it might help avoid a trivial attack on DNS that might otherwise\n> pass without notice or alarm.  That is, an attack that copies the DNS\n> QNAME in the public_name field.\n\nI'd have no problem if we said \"if outerCH.sni==innerCH.sni\"\nthen ignore the innerCH, or something similar. But it ought\nbe valid, and maybe even encouraged, to ignore the sni from\nthe outerCH, when the innerCH works.\n\n> There are various ways in which this might fail, but none of the\n> scenarios that I can think of result in anything that a client or\n> server might recognize as being alarming.\n> \n> It is easy to detect and prevent this sort of interference: the\n> client-facing server checks that the SNI matches the value it expects\n> from the ECHConfig that has been selected.  If the config might have\n> changed, such that multiple values are valid, then the server can\n> allow for that, but generally there will be just one valid value.\n\nAgain, I don't see sufficient benefit, so would rather keep\nthe flexibility and easier deployment of omitting that.\n\nCheers,\nS.\n\n\n",
          "createdAt": "2021-02-23T13:05:34Z",
          "updatedAt": "2021-02-23T13:05:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The entire ECHConfig is also bound into the decryption, so if the DNS is messing with ECHConfigs, you won't end up negotiating ECH. Copying the QNAME into the public name probably will successfully bounce ECH off via the recovery flow, but the DNS could just as easily have dropped the ECHConfig itself.",
          "createdAt": "2021-02-23T15:13:14Z",
          "updatedAt": "2021-02-23T15:13:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson can you elaborate on the attack you had in mind? @davidben notes that the entire ECHConfig is now authenticated, so any disagreement between client and server will cause ECH negotiation failure. ",
          "createdAt": "2021-02-27T02:37:38Z",
          "updatedAt": "2021-02-27T02:37:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I should have responded earlier (thought I did...).  The fact that the configuration is covered prevents this from being a problem.  I missed that.",
          "createdAt": "2021-03-01T04:32:07Z",
          "updatedAt": "2021-03-01T04:32:07Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NTg2MDE3",
      "title": "Text",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/1",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-11T22:49:19Z",
      "updatedAt": "2018-05-11T23:09:25Z",
      "closedAt": "2018-05-11T23:09:25Z",
      "mergedAt": "2018-05-11T23:09:25Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "cdd930894881e8f1abab1c2d1e8e5b0107fe46b3",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "ded62dd0faa173577a5f31c3fd80fce854464fd3",
      "mergeCommit": {
        "oid": "ded62dd0faa173577a5f31c3fd80fce854464fd3"
      }
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NTkwMjY5",
      "title": "Add assessment section",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/2",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-11T23:29:04Z",
      "updatedAt": "2018-05-11T23:41:58Z",
      "closedAt": "2018-05-11T23:41:58Z",
      "mergedAt": "2018-05-11T23:41:58Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA1MDg1",
          "commit": {
            "abbreviatedOid": "74bd303"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is good. Added a few comments.",
          "createdAt": "2018-05-11T23:31:32Z",
          "updatedAt": "2018-05-11T23:33:50Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Why is this a problem? You have a label?",
              "createdAt": "2018-05-11T23:31:33Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            },
            {
              "originalPosition": 83,
              "body": "I think you should sharpen this point a bit. The argument I would make is that this is a property of the browser and the server, so it's not suspicious at all. Now, it's true that you need more clients to avoid *blocking* but if you're using a generic browser, there's nothing suspicious about running Safari, Firefox, etc.",
              "createdAt": "2018-05-11T23:33:09Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            },
            {
              "originalPosition": 88,
              "body": "I don't think this is true, because the server's share is static.",
              "createdAt": "2018-05-11T23:33:19Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            },
            {
              "originalPosition": 99,
              "body": "This is true, but I think it's worth pointing to the cleartext DNS for why that's not even needed.",
              "createdAt": "2018-05-11T23:33:37Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA1NTM0",
          "commit": {
            "abbreviatedOid": "74bd303"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T23:35:39Z",
          "updatedAt": "2018-05-11T23:35:39Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Oh, yes, oops. I was forgot we said above just to fail open if there's a label mismatch.",
              "createdAt": "2018-05-11T23:35:39Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA1NjAy",
          "commit": {
            "abbreviatedOid": "74bd303"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T23:36:20Z",
          "updatedAt": "2018-05-11T23:36:20Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "I'm assuming a short TTL for these keys -- so maybe I'll just say not FS by usual definition, but window of exposure is bound by DNS RR TTL",
              "createdAt": "2018-05-11T23:36:20Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA1ODAz",
          "commit": {
            "abbreviatedOid": "74bd303"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T23:38:24Z",
          "updatedAt": "2018-05-11T23:38:24Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Done.",
              "createdAt": "2018-05-11T23:38:24Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5dec6a11f91e314205d86de1d73b9fe0abe0ac26",
      "headRepository": null,
      "headRefName": "caw/assess",
      "headRefOid": "8ef656997e7a3f6c63047939757e9d410eaa2127",
      "mergeCommit": {
        "oid": "483739199977a81d5b6d379e8556e259bd7fc28b"
      }
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NTkxODI4",
      "title": "Cleartext DNS is A-OK.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/3",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-11T23:46:35Z",
      "updatedAt": "2018-05-11T23:57:25Z",
      "closedAt": "2018-05-11T23:57:25Z",
      "mergedAt": "2018-05-11T23:57:25Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA2Nzk5",
          "commit": {
            "abbreviatedOid": "8bd1a4b"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-11T23:49:18Z",
          "updatedAt": "2018-05-11T23:49:22Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I think I would phrase this slightly differently, namely that you can provide a per-domain name IP address. It's not the SNI that's published.\r\n\r\n\r\n\r\n",
              "createdAt": "2018-05-11T23:49:18Z",
              "updatedAt": "2018-05-11T23:54:25Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "483739199977a81d5b6d379e8556e259bd7fc28b",
      "headRepository": null,
      "headRefName": "caw/dns",
      "headRefOid": "02efa31d518f23d395cd20d41b5510f083097320",
      "mergeCommit": {
        "oid": "2a927e6f3884c74c155ca199e61b997d4089546b"
      }
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NTkzNzk3",
      "title": "Small rewrite",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/4",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-12T00:10:45Z",
      "updatedAt": "2018-05-12T00:16:05Z",
      "closedAt": "2018-05-12T00:16:05Z",
      "mergedAt": "2018-05-12T00:16:05Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "maybe also point out that once you control DNS, getting a certificate is usually fairly easy",
          "createdAt": "2018-05-12T00:12:07Z",
          "updatedAt": "2018-05-12T00:12:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA4ODI3",
          "commit": {
            "abbreviatedOid": "4f173e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T00:13:20Z",
          "updatedAt": "2018-05-12T00:13:20Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I'd add that the attacker can also inject its own keys, which causes the client to encrypt the SNI to them.",
              "createdAt": "2018-05-12T00:13:20Z",
              "updatedAt": "2018-05-12T00:13:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA4ODcx",
          "commit": {
            "abbreviatedOid": "4f173e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T00:14:03Z",
          "updatedAt": "2018-05-12T00:14:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Maybe add: In fact, SNI encryption is less useful without encryption of DNS queries in transit via DoH or DPRIVE mechanisms.",
              "createdAt": "2018-05-12T00:14:04Z",
              "updatedAt": "2018-05-12T00:14:04Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2a927e6f3884c74c155ca199e61b997d4089546b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "cleartext_dns",
      "headRefOid": "4f173e07500acdd309f458950fd84b59e6d6c664",
      "mergeCommit": {
        "oid": "4f173e07500acdd309f458950fd84b59e6d6c664"
      }
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjAzNTg4",
      "title": "Address MT's issues.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/9",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Instead of a Fronting SNI field, we should just re-use the Alt-Svc record, which already carries an SNI value to be used.",
      "createdAt": "2018-05-12T04:15:15Z",
      "updatedAt": "2018-05-12T15:12:12Z",
      "closedAt": "2018-05-12T15:12:12Z",
      "mergedAt": "2018-05-12T15:12:12Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI1Mjk3",
          "commit": {
            "abbreviatedOid": "3002a0e"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T12:26:27Z",
          "updatedAt": "2018-05-12T12:27:12Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'm having trouble following this. Is this each record?",
              "createdAt": "2018-05-12T12:26:28Z",
              "updatedAt": "2018-05-12T13:06:58Z"
            },
            {
              "originalPosition": 15,
              "body": "This sentence seems ot just end.",
              "createdAt": "2018-05-12T12:26:57Z",
              "updatedAt": "2018-05-12T13:06:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI2MDI2",
          "commit": {
            "abbreviatedOid": "3002a0e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T13:04:33Z",
          "updatedAt": "2018-05-12T13:04:33Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Missed period -- fixed now.",
              "createdAt": "2018-05-12T13:04:33Z",
              "updatedAt": "2018-05-12T13:06:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI2MDU0",
          "commit": {
            "abbreviatedOid": "3002a0e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T13:06:24Z",
          "updatedAt": "2018-05-12T13:06:24Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Indeed, the sentence is confusing. I just removed it. The point I was trying to make is that if there are multiple IP addresses to choose from with multiple keys, and the server does not configure each of those addresses with the set of keys, the client might pick the wrong address/key combo.",
              "createdAt": "2018-05-12T13:06:24Z",
              "updatedAt": "2018-05-12T13:06:58Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9da97156f4553c7f3424be53047099fe72328f47",
      "headRepository": null,
      "headRefName": "caw/issues",
      "headRefOid": "a6ee53b988d804d8fd8e368c39fd5566f53cdb73",
      "mergeCommit": {
        "oid": "a6ee53b988d804d8fd8e368c39fd5566f53cdb73"
      }
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjE5Njkx",
      "title": "Simplify key schedule. Remove Nonce. Fixes #6",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/11",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-12T12:43:35Z",
      "updatedAt": "2018-05-12T13:14:04Z",
      "closedAt": "2018-05-12T13:13:32Z",
      "mergedAt": "2018-05-12T13:13:32Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI2MTcz",
          "commit": {
            "abbreviatedOid": "314f8e7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T13:13:13Z",
          "updatedAt": "2018-05-12T13:13:14Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "This is an implementation detail, I think. If a client chooses to expand twice when it's not needed then that's their fault. We could simply state (in the other draft, or here) that \"if clients have computed Z for other purposes, an additional extraction is not needed.\"",
              "createdAt": "2018-05-12T13:13:14Z",
              "updatedAt": "2018-05-12T13:13:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI2MTg1",
          "commit": {
            "abbreviatedOid": "314f8e7"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T13:14:04Z",
          "updatedAt": "2018-05-12T13:14:04Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Sorry, I'm not worried about the implementation, but about whether we're guaranteeing key separation",
              "createdAt": "2018-05-12T13:14:04Z",
              "updatedAt": "2018-05-12T13:14:04Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9da97156f4553c7f3424be53047099fe72328f47",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "simplify_keys",
      "headRefOid": "314f8e741554c4defb828f536bae8506d20bc3e2",
      "mergeCommit": {
        "oid": "c30baff03a7471998a775e9f18e25f3f4e8e7eb5"
      }
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjI1NjQz",
      "title": "Don't allow bad labels",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/12",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-12T15:15:00Z",
      "updatedAt": "2018-05-12T15:30:08Z",
      "closedAt": "2018-05-12T15:30:08Z",
      "mergedAt": "2018-05-12T15:30:08Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ",
          "createdAt": "2018-05-12T15:15:19Z",
          "updatedAt": "2018-05-12T15:15:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI5MDg0",
          "commit": {
            "abbreviatedOid": "1772724"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2018-05-12T15:25:25Z",
          "updatedAt": "2018-05-12T15:25:25Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "0a0d116d7ddcf73554597e4716573529ba8f31ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "fail_on_bad_label",
      "headRefOid": "1772724e8da753d3deacb4280a87f8ba91ba12de",
      "mergeCommit": {
        "oid": "eb9af6279dd98f92cfc627f52714b884581b7f89"
      }
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjI2MzAw",
      "title": "Add padding to the encrypted SNI to avoid attacks based on length.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/13",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood PTAL",
      "createdAt": "2018-05-12T15:29:57Z",
      "updatedAt": "2018-05-12T15:38:41Z",
      "closedAt": "2018-05-12T15:38:40Z",
      "mergedAt": "2018-05-12T15:38:40Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI5MzIy",
          "commit": {
            "abbreviatedOid": "29c165f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T15:34:38Z",
          "updatedAt": "2018-05-12T15:35:50Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Should we send decrypt_error instead? (Thinking of POs here.)",
              "createdAt": "2018-05-12T15:34:38Z",
              "updatedAt": "2018-05-12T15:35:50Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "0a0d116d7ddcf73554597e4716573529ba8f31ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "obscure_length",
      "headRefOid": "29c165f147e794c4d266b7b635704ee97b5892a4",
      "mergeCommit": {
        "oid": "a37f5e34927438ee13fe7fa2622eaf9f5e84bad0"
      }
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjMyODYz",
      "title": "Misc. fixes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/16",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A few fixes made while reading through.",
      "createdAt": "2018-05-12T18:00:04Z",
      "updatedAt": "2018-05-12T18:33:25Z",
      "closedAt": "2018-05-12T18:33:25Z",
      "mergedAt": "2018-05-12T18:33:25Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a37f5e34927438ee13fe7fa2622eaf9f5e84bad0",
      "headRepository": null,
      "headRefName": "fixes",
      "headRefOid": "a430e93215f6553185cae4e4e5c5241ce1ba32b4",
      "mergeCommit": {
        "oid": "ea9fc6d00233bad98d90fbb0b6246179359fe796"
      }
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjM1MDYy",
      "title": "Add clarity to the DNS encoding section, require base64 encoding, and\u2026",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/18",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026 deal with TXT string limits.\r\n",
      "createdAt": "2018-05-12T18:53:41Z",
      "updatedAt": "2018-05-13T00:07:31Z",
      "closedAt": "2018-05-13T00:07:31Z",
      "mergedAt": "2018-05-13T00:07:31Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema @ghedo please take a look.",
          "createdAt": "2018-05-12T18:56:01Z",
          "updatedAt": "2018-05-12T18:56:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson @huitema updated based on your feedback -- please take a look!",
          "createdAt": "2018-05-12T23:49:40Z",
          "updatedAt": "2018-05-12T23:49:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM3NjU1",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "The general idea looks good, but I am a bit concerned with the concatenation + reordering process, as in theory servers may return records in random order. On the other hand, RFC 4408 has been out for a long time, so maybe that's not really a problem in practice.",
          "createdAt": "2018-05-12T21:53:20Z",
          "updatedAt": "2018-05-12T21:55:42Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I read the text in RFC 4408 and I am a bit concerned that this is one of those things that does not work in theory but does work in practice. In theory, when there are multiple records of the same type for the same name, DNS servers or recursive resolvers can return the records in whichever order they see fit. If they actually do that, the concatenation becomes unpredictable.",
              "createdAt": "2018-05-12T21:53:21Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            },
            {
              "originalPosition": 30,
              "body": "At most one [each] ... TXT ESNI... Is that compatible with the idea that the string may be split over multiple concatenated records?",
              "createdAt": "2018-05-12T21:53:24Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM4OTg0",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-12T23:21:01Z",
          "updatedAt": "2018-05-12T23:23:02Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Nit extra period after 3.1.3",
              "createdAt": "2018-05-12T23:21:01Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            },
            {
              "originalPosition": 32,
              "body": "I think that you need to more directly address the notion that the anonymity set is the set of domains that share the same IP address.  That deserves a paragraph that includes this last sentence.",
              "createdAt": "2018-05-12T23:22:59Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM5MjYz",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T23:39:05Z",
          "updatedAt": "2018-05-12T23:39:06Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Fixed.",
              "createdAt": "2018-05-12T23:39:06Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM5Mjc4",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T23:40:12Z",
          "updatedAt": "2018-05-12T23:40:12Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Hmm, interesting. I didn't see records being concatenated. Do we think servers will offer up key sets that need to split up across records?",
              "createdAt": "2018-05-12T23:40:12Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM5Mjk0",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T23:41:47Z",
          "updatedAt": "2018-05-12T23:41:47Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "The text here suggests that we'd split up text within a single record, not across multiple records. Indeed, if the latter were the case, I don't think this would work.",
              "createdAt": "2018-05-12T23:41:47Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM5NTA5",
          "commit": {
            "abbreviatedOid": "674f746"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "That's more words than I expected, but they all seem useful.  LGTM.",
          "createdAt": "2018-05-13T00:01:03Z",
          "updatedAt": "2018-05-13T00:01:03Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ea9fc6d00233bad98d90fbb0b6246179359fe796",
      "headRepository": null,
      "headRefName": "caw/encoding",
      "headRefOid": "674f746cf41dd33551002f080cc79919865eea94",
      "mergeCommit": {
        "oid": "a44aea22621347cef696c8fd1a210f92a43e1460"
      }
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjgzODY0",
      "title": "Add Kazuho",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/21",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@kazuho: please double check",
      "createdAt": "2018-05-13T18:33:16Z",
      "updatedAt": "2018-05-13T22:01:12Z",
      "closedAt": "2018-05-13T22:01:01Z",
      "mergedAt": "2018-05-13T22:01:01Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you very much!",
          "createdAt": "2018-05-13T22:01:12Z",
          "updatedAt": "2018-05-13T22:01:12Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a44aea22621347cef696c8fd1a210f92a43e1460",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "add_kazuho",
      "headRefOid": "e78c4f36dc7d5f117727de1c0c8b52e79a669019",
      "mergeCommit": {
        "oid": "77a9cef4ba9de590a1cf327a655e10ce0df6d11d"
      }
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NzA3NzE5",
      "title": "add ESNIKeys.extensions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/22",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "At the moment, there is no extensibility in ESNIKeys. That means that if we want to add additional attributes, we would be forced to define a new DNS record that gets queried simultaneously. I think we do not want to do that.\r\n\r\nHence the extensions field.\r\n\r\nThe text is tentative; please feel free to change in any ways.\r\n\r\nCloses #10.",
      "createdAt": "2018-05-14T02:36:58Z",
      "updatedAt": "2018-05-14T13:16:57Z",
      "closedAt": "2018-05-14T13:16:57Z",
      "mergedAt": "2018-05-14T13:16:57Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM.",
          "createdAt": "2018-05-14T13:15:38Z",
          "updatedAt": "2018-05-14T13:15:38Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "77a9cef4ba9de590a1cf327a655e10ce0df6d11d",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/extensions",
      "headRefOid": "e2362439b34c7e280bb2a9fee2152cbae55016f4",
      "mergeCommit": {
        "oid": "87f70eeeff775e26b57a92cb0d01586f0cf8f58c"
      }
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NzE1MDgy",
      "title": "client-side validation of ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/23",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I expect that the resistance against ESNIKeys will come from web-site owners worrying about ESNIKeys being additional source of service disruption.\r\n\r\nOne might argue that the probability of disruption becomes 2x because now two resource records (A and _esni) are involved instead of just one. One might argue that the probability is higher than that because there could be more issues with carrying large TXT records than carrying A records. One might argue that the probability is below 2x because the two records are transmitted through the same path.\r\n\r\nAnyways, these arguments are about the quantitative difference about the probability.\r\n\r\nI prefer having a qualitative guarantee, that assures that there would be no increase in the probability of service disruption assuming that the owner of the `_esni` record does not misconfigure the service.\r\n\r\nHaving a checksum and validity period fields that can be validated by the client provides such guarantee.\r\n\r\nChecksum provides protection against accidental corruption.\r\n\r\nValidity period provides protection against misconfiguration or bugs in the DNS servers. It acts as a protection against an outdated ESNIKeys sent by an out-of-sync authoritative server or a buggy resolver causing disruption.\r\n\r\nThe downside of having checksum and validity is that the additional payload (currently 20 bytes, I think we can minimize this to 10 bytes by removing `not_before` (it's not that needed) and changing the type of `not_after` from `uint64` to `uint48`), and that the client would be required to do the validation.\r\n\r\nBut I assume that having qualitative guarantee that the probability of service disruption remains the same is worth the effort.\r\n\r\nCloses #20.",
      "createdAt": "2018-05-14T04:02:16Z",
      "updatedAt": "2018-05-14T16:04:43Z",
      "closedAt": "2018-05-14T16:04:43Z",
      "mergedAt": "2018-05-14T16:04:43Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood The PR is now aligned with master. I think we should merge this and rebase #24 upon this regardless of what we end up with on the PR.",
          "createdAt": "2018-05-14T16:03:15Z",
          "updatedAt": "2018-05-14T16:03:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODMwOTA2",
          "commit": {
            "abbreviatedOid": "dfd9bc5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-05-14T13:24:37Z",
          "updatedAt": "2018-05-14T13:24:45Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "While I think this is useful, it requires DNSSEC for this to be safe. Otherwise, a malicious recursive resolver could alter not_before or not_after to prevent a client from using the key as one normally would. It also seems redundant with the TTL field in the RR itself. @ekr thoughts?",
              "createdAt": "2018-05-14T13:24:38Z",
              "updatedAt": "2018-05-14T16:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODc2MjY3",
          "commit": {
            "abbreviatedOid": "dfd9bc5"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T15:05:55Z",
          "updatedAt": "2018-05-14T15:05:56Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "> a malicious recursive resolver could alter not_before or not_after to prevent a client from using the key as one normally would\r\n\r\nI do not think that as an issue, considering the fact that a malicious resolver can do anything including changing the A record or dropping the ESNIKeys entirely.\r\n\r\n> It also seems redundant with the TTL field in the RR itself.\r\n\r\nI do not think so.\r\n\r\nThe issue with TTL is that TTL is always relative to the time when the DNS authoritative server emits the record.\r\n\r\nConsider the case where the authoritative server and the TLS server getting out-of-sync.\r\n\r\nIf we have `not_after`, the servers can be deployed in the a way that it does not cause service disruption. What you need to do setup your system to always generate the ESNIKeys on the TLS server and push it to the authoritative server for distributing it. Then, when the two servers become brain-split, the _esni resource records would become considered as invalid by the clients.\r\n\r\nBut if we do not have `not_after`, the _esni record that the authoritative server will continue to be considered valid, because TTL is set every time the authoritative server emits the record.",
              "createdAt": "2018-05-14T15:05:56Z",
              "updatedAt": "2018-05-14T16:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODc5NTYw",
          "commit": {
            "abbreviatedOid": "dfd9bc5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T15:12:29Z",
          "updatedAt": "2018-05-14T15:12:30Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Fair points! You've convinced me this is needed.",
              "createdAt": "2018-05-14T15:12:30Z",
              "updatedAt": "2018-05-14T16:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5OTAxNzY5",
          "commit": {
            "abbreviatedOid": "ca6c490"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-14T16:02:06Z",
          "updatedAt": "2018-05-14T16:02:06Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "16b8a6ff244862647683be24fcded2ab8b5657e9",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/client-side-validation",
      "headRefOid": "ca6c490833165bf920e6c05af2ebb57c259549a0",
      "mergeCommit": {
        "oid": "3ad81cc1e3a141ca9ad90c5d184773a25cca4af8"
      }
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3ODA0MzEx",
      "title": "prevent downgrade attack",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/24",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In ESNI, the server offers a list of ECDH keys and the client selects one of them. However, there seems to be nothing that prevents a downgrade attack.\r\n\r\nThis PR adds the protection, by sending the list of the Named Groups being offered by ESNIKeys in the EncryptedSNI extension.\r\n\r\nThe bonus is that the size of ESNIKeys becomes smaller when more than one keys are offered (because we now only send one label per the entire key set).",
      "createdAt": "2018-05-14T12:01:06Z",
      "updatedAt": "2018-05-17T13:08:17Z",
      "closedAt": "2018-05-17T13:08:17Z",
      "mergedAt": "2018-05-17T13:08:17Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think the NamedGroupList is necessary to prevent downgrade attacks.\r\n\r\nConsider the case where the authoritative server sends an _esni record containing X448 and X25519 keys. Malicious middlebox rewrites the _esni record to only contain the X25519 key. The client will accept the X25519 key and use that for the TLS handshake.\r\n\r\nI think that is not prevented now, and that we need to prevent it.",
          "createdAt": "2018-05-14T15:08:44Z",
          "updatedAt": "2018-05-14T15:08:44Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: thanks for identifying this. I agree it's a real issue and wish I'd caught it before :(\r\n\r\nThinking about defenses, do you think it might make more sense to ditch the label and instead just carry a hash of the record? Then we could guarantee that it wasn't changed more easily? OTOH, that would preclude self-encryption of the ESNI Key....",
          "createdAt": "2018-05-14T15:11:47Z",
          "updatedAt": "2018-05-14T15:11:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr Servers might want more than one label per record to allow for migration. Why don't we have clients send the hash of the ESNKey structure for the label it chooses? The server could also include that in full in place of the truncated hash.",
          "createdAt": "2018-05-14T15:14:24Z",
          "updatedAt": "2018-05-14T15:14:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho I meant that we don't need to send the NamedGroupsList for mitigation -- we could send something else, e.g., the ESNIKey hash.",
          "createdAt": "2018-05-14T15:15:48Z",
          "updatedAt": "2018-05-14T15:15:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thinking about defenses, do you think it might make more sense to ditch the label and instead just carry a hash of the record? Then we could guarantee that it wasn't changed more easily? OTOH, that would preclude self-encryption of the ESNI Key....\r\n\r\n@ekr The other issue is that you then need to consider negotiating the hash algorithm to be used. I did not want to deal with that and therefore went for the Named Group list.\r\n\r\n@chris-wood Thank you for the clarification. I think the paragraph right above is my answer.",
          "createdAt": "2018-05-14T15:18:19Z",
          "updatedAt": "2018-05-14T15:19:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho The checksum you propose is already computed with SHA256 -- why do you think this is something we ought to negotiate? ",
          "createdAt": "2018-05-14T15:27:43Z",
          "updatedAt": "2018-05-14T15:27:43Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood The checksum is only 32-bits and it's for detecting errors, not preventing attacks.\r\n\r\nNamed Group selection is a cryptographic property of the TLS handshake and it needs to be protected by the digest algorithm of the negotiated cipher-suite. It is either a full-length SHA-256 or SHA-384 at the moment, but could change in the future.",
          "createdAt": "2018-05-14T15:34:11Z",
          "updatedAt": "2018-05-14T15:34:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho The intent of this is to convey to the server that the client saw the right set of options before it chose its key. We don't need to consider any properties of NamedGroup selection with TLS to do so. And picking a suitable cryptographic hash function here is good enough. I really don't think we need agility here. \r\n\r\nAlso, I wasn't suggesting the client echo the 32bit hash found in the record. It should send the full SHA256 hash. ",
          "createdAt": "2018-05-14T15:36:01Z",
          "updatedAt": "2018-05-14T15:37:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, also, what if we decide to add an extension that could influence how clients choose keys? Wouldn't we want downgrade protection for that, too? (A hash would work for that, whereas echoing the NamedGroup list would not.)",
          "createdAt": "2018-05-14T15:39:56Z",
          "updatedAt": "2018-05-14T15:39:56Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My understanding is as follows:\r\n* In TLS 1.3, client offers the Named Groups and server selects one. It is protected by the digest algorithm of the negotiated cipher-suite.\r\n* In TLS 1.3 + ESNI, server offers the Named Groups and client selects one.\r\n\r\nTherefore, I assume that which Named Groups we offered needs to be protected by the digest algorithm of the negotiated cipher-suite, or else we are changing the security properties of TLS 1.3.\r\n\r\n> Oh, also, what if we decide to add an extension that could influence how clients choose keys? Wouldn't we want downgrade protection for that, too? (A hash would work for that, whereas echoing the NamedGroup list would not.)\r\n\r\nI agree. So to me the choice seems to be between a) choose a specific solution (i.e. send Named Group list) or b) add digest algorithm negotiation and send the hash value.\r\n\r\nI went for a, but I won't argue hardly against b.",
          "createdAt": "2018-05-14T15:43:47Z",
          "updatedAt": "2018-05-14T15:44:02Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, we could just use the hash associated with the cipher suite, no?\n\nOn Mon, May 14, 2018 at 8:39 AM, Christopher Wood <notifications@github.com>\nwrote:\n\n> Oh, also, what if we decide to add an extension that could influence how\n> clients choose keys? Wouldn't we want downgrade protection for that, too?\n> (A hash would work for that, whereas echoing the NamedGroup list would not.)\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/pull/24#issuecomment-388862886>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1offG-C6SQ7_u_hTtaxaKcdOw36wYks5tyaVNgaJpZM4T9qTj>\n> .\n>\n",
          "createdAt": "2018-05-14T15:44:37Z",
          "updatedAt": "2018-05-14T15:44:37Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Well, we could just use the hash associated with the cipher suite, no?\r\n\r\n@ekr That's possible, but then the server needs to offer a list of hash algorithms that it understands in ESNIKeys, or the client needs to send hash digests for all the cipher-suites it offers.",
          "createdAt": "2018-05-14T15:48:15Z",
          "updatedAt": "2018-05-14T15:48:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho I don't think that's necessary. We can assume SHA256 or some other MTI hash function for this to work. \r\n\r\nIn the interest of future proofing, let's use a hash. I care much less about agility for the algorithm in question.",
          "createdAt": "2018-05-14T15:49:30Z",
          "updatedAt": "2018-05-14T15:49:30Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think that's necessary. We can assume SHA256 or some other MTI hash function for this to work.\r\n\r\nAssuming that is true, I am happy to go for using hash. The primary reason is that we can remove `label` and use the hash value as the key to identify the ESNIKeys record that the client used.\r\n\r\nOTOH, I am still not convinced why we do not need to negotiate the hash algorithm, especially when we are talking about the possibility of transferring additional extensions in the future that will be under the same protection. But I am not a crypto person and I could well be wrong, especially when it is midnight here.\r\n\r\nAnyways thank you very much for your quick response and for quickly merging the other PR. This PR is now in sync with master. Please feel free to use this as a basis of creating a PR that implements hash-based protection, if the current text looks worth enough.",
          "createdAt": "2018-05-14T16:14:33Z",
          "updatedAt": "2018-05-14T16:14:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting point about using the hash as the label, though it might help to keep the label in the event that we come up with another way to publish ESNI keys. \r\n\r\nRegarding negotiation, I think SHA256 is sufficient for now and the future. Negotiating yet another algorithm seems like unnecessary complexity here. I can take a stab at writing that text, though I think what you have here is nearly there.",
          "createdAt": "2018-05-14T16:18:47Z",
          "updatedAt": "2018-05-14T16:18:47Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, I'm confused: the DNS record contains a list oc cipher suites, each of which is associated with a hash. The client chooses one to use to encrypt the SNI. Why can't that be the one you use to hash the ESNIKeys record",
          "createdAt": "2018-05-14T19:50:36Z",
          "updatedAt": "2018-05-14T19:50:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr That'd work fine, I just think it's unnecessary here.",
          "createdAt": "2018-05-14T19:57:09Z",
          "updatedAt": "2018-05-14T19:57:09Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "So there's the argument that always using SHA-256 should be fine, and there's the argument that that the cipher-suites list can sent in ESNIKeys to solve the issue.\r\n\r\nI disagree to both. I have already explained why I think using SHA256 always is not fine. Let me explain why I think sending cipher-suites list in ESNIKeys is not fine.\r\n\r\n@ekr Traditionally, we have allowed different cipher-suites to be selected depending on the value of SNI. This becomes an even more important property in the ESNI proposal, because we split the server into fronting server and hidden server. Cipher-suite selection is a negotiation between the client and the hidden server, whereas the ESNIKeys is a key-exchange between the client and the fronting server.\r\n\r\nTherefore, we cannot / should not use ESNIKeys as a conveyer of cipher-suite negotiation.\r\n\r\nConsidering that we have disagreement on the how we can uses hashes, maybe it is a good idea to merge this as-is to fix the security hole, and get back to do the improvements later on if necessary. I thought that we wanted to submit this soon.",
          "createdAt": "2018-05-14T22:42:29Z",
          "updatedAt": "2018-05-14T22:42:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho The ciphersuite that's sent by the client in the EncryptedSNI extension only applies to that extension, not to the rest of the handshake or data, right? ",
          "createdAt": "2018-05-14T22:51:33Z",
          "updatedAt": "2018-05-14T22:51:33Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood Ah! That's correct. We now have two cipher-suites. I am fine with using the cipher-suite then.",
          "createdAt": "2018-05-14T22:58:23Z",
          "updatedAt": "2018-05-14T22:58:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool -- I'll propose some text. :-)\r\n",
          "createdAt": "2018-05-14T22:59:36Z",
          "updatedAt": "2018-05-14T22:59:36Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Applied @chris-wood's patch that changes the protection from using a list of Named Groups to using a digest specified by the cipher-suite.",
          "createdAt": "2018-05-15T20:44:35Z",
          "updatedAt": "2018-05-15T20:44:35Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "record_digest is sent together with encrypted_sni in EncryptedSNI which is supposed to be the sensitive information you want to protect from a downgrade attack.\r\n\r\nSo assuming there is a downgrade attack (I'm guessing you get bad key information from the DNS record) the client falls for it, sends the ESNI in a way that allows it to be compromised, and also sends the hash for the server to check whether an attack is going on.\r\n\r\nFronting Server Behavior text says \"If the EncryptedSNI.record_digest value does not match the cryptographic hash of the associated ENSIKeys structure, it MUST abort the connection\"\r\n\r\nBy the time the server realizes the hash is incorrect and drops the connection the ESNI has already been sent over the wire by the client. (And the adversary has intercepted it) So what's the benefit of dropping the connection at that point?\r\n\r\n\r\nAs a side-note, can you explain the specific downgrade attacks you have in mind? My understanding is that the threat here is learning the value of SNI. If you are able to tamper with the DNS record then by definition you know (or can learn) the client's query for the domain name. Why would you need to attack the key material and try to decrypt the ESNI? And on the other hand, if you don't have r/w access to the DNS records, how can you carry out a downgrade attack?",
          "createdAt": "2018-05-16T01:39:51Z",
          "updatedAt": "2018-05-16T01:39:51Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> By the time the server realizes the hash is incorrect and drops the connection the ESNI has already been sent over the wire by the client. (And the adversary has intercepted it) So what's the benefit of dropping the connection at that point?\r\n\r\nThat's a good question.\r\n\r\nThe issue here is the Named Group that is being selected for ESNI protection key will also be used for negotiating the handshake. So the TLS handshake gets compromised (and that is what we are calling downgrade attack here).\r\n\r\nPlease refer to the first paragraph for https://github.com/ekr/draft-rescorla-tls-esni/pull/24#issuecomment-388864250.",
          "createdAt": "2018-05-16T03:24:29Z",
          "updatedAt": "2018-05-16T03:27:03Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "> The issue here is the Named Group that is being selected for ESNI protection key will also be used for negotiating the handshake. So the TLS handshake gets compromised (and that is what we are calling downgrade attack here).\r\n\r\nCan we treat the ESNI key derivation and TLS key derivation as separate processes?\r\n\r\nSeems like the reason we need to protect against downgrade attacks is because we are reusing the (potentially poisoned) ESNIKeys KeyShareEntry structure in the TLS key schedule.\r\n\r\nIf we were to limit its use to just ESNI key derivation would we still need to protect against downgrade attacks?",
          "createdAt": "2018-05-16T04:03:13Z",
          "updatedAt": "2018-05-16T04:03:13Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can we treat the ESNI key derivation and TLS key derivation as separate processes?\r\n\r\nMy understanding is that that is possible, and then we do not need to send the digest value of the ESNIKeys structure assuming that we do not add extensions that need downgrade protection.\r\n\r\nHowever, that would require the client to send and generate one more ECDH key, as well as increasing the probability of HRR due to group mismatch.\r\n\r\nTo put it another way, the approach used in this PR is on par with the amount of the data transmitted (the size of the digest and the ECDH key are roughly equal), has the possibility of cutting a round-trip, requires less CPU cost.",
          "createdAt": "2018-05-17T02:20:52Z",
          "updatedAt": "2018-05-17T02:20:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODI1ODI1",
          "commit": {
            "abbreviatedOid": "5013603"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I'm not sure this change is needed to prevent the attack in question. ",
          "createdAt": "2018-05-14T13:11:54Z",
          "updatedAt": "2018-05-14T13:13:29Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This makes it so that each label maps to a set of keys, which was not the original intent. We want there to be a 1-1 mapping between label and key, as that allows a server to abort a connection with illegal_parameter if there's a label mismatch, i.e., if a client offers a label that the server does not recognize. ",
              "createdAt": "2018-05-14T13:11:54Z",
              "updatedAt": "2018-05-15T22:44:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODQxNTU0",
          "commit": {
            "abbreviatedOid": "5013603"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T13:50:27Z",
          "updatedAt": "2018-05-14T13:50:28Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Please disregard! I did not read your comments in #19. The (label, group) => key mapping seems plausible. Though I don't think the NamedGroupList is necessary to prevent downgrade attacks.",
              "createdAt": "2018-05-14T13:50:27Z",
              "updatedAt": "2018-05-15T22:44:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwNDMzNzg3",
          "commit": {
            "abbreviatedOid": "f95eb78"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This LGTM. @ekr, PTAL when you have time.",
          "createdAt": "2018-05-15T22:11:00Z",
          "updatedAt": "2018-05-15T22:11:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwNDM5ODUw",
          "commit": {
            "abbreviatedOid": "f95eb78"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-15T22:36:44Z",
          "updatedAt": "2018-05-15T22:36:45Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "What is this struct used for?",
              "createdAt": "2018-05-15T22:36:45Z",
              "updatedAt": "2018-05-15T22:44:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwNDQxNjY0",
          "commit": {
            "abbreviatedOid": "f55f9c3"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-15T22:45:25Z",
          "updatedAt": "2018-05-15T22:45:25Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Nice catch! We no longer need it. Addressed in f55f9c3.",
              "createdAt": "2018-05-15T22:45:25Z",
              "updatedAt": "2018-05-15T22:45:25Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3ad81cc1e3a141ca9ad90c5d184773a25cca4af8",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/one-key-per-group",
      "headRefOid": "f55f9c31735eba8fcf04b8e2110966e0dcafa7a4",
      "mergeCommit": {
        "oid": "6276955dbfee725e5db060d38d66cd479d8acf58"
      }
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3ODExNTYw",
      "title": "clarify that limitation of hash-based protection",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/26",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The approach does not work if the mapping between the fronting server and the hidden server contains a wildcard.",
      "createdAt": "2018-05-14T12:31:08Z",
      "updatedAt": "2018-05-14T13:17:38Z",
      "closedAt": "2018-05-14T13:17:38Z",
      "mergedAt": "2018-05-14T13:17:38Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM!",
          "createdAt": "2018-05-14T13:05:17Z",
          "updatedAt": "2018-05-14T13:05:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODIzNDI3",
          "commit": {
            "abbreviatedOid": "ffc7972"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-14T13:05:07Z",
          "updatedAt": "2018-05-14T13:05:07Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "77a9cef4ba9de590a1cf327a655e10ce0df6d11d",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/hash-based-vs-wildcard-delegation",
      "headRefOid": "ffc797263c950cb44cfd5c199f8f55c57209598f",
      "mergeCommit": {
        "oid": "16b8a6ff244862647683be24fcded2ab8b5657e9"
      }
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3OTY2MTM4",
      "title": "Clarify requirements for domains with multiple A, AAAA, ... reconrds",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/31",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See #29 ",
      "createdAt": "2018-05-14T22:17:28Z",
      "updatedAt": "2018-05-14T22:50:00Z",
      "closedAt": "2018-05-14T22:50:00Z",
      "mergedAt": "2018-05-14T22:50:00Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "This looks good to me.\r\n\r\nClarifying the requirements rather than specifying how to act makes more sense here.\r\n\r\nFWIW, I thought the intent of the original text was to encourage _not_ having ESNIKeys shared between multiple hosts whenever possible. This change loses that property. But anyways, that is mentioned in the appendix. Hence my :+1: to the PR.",
          "createdAt": "2018-05-14T22:48:37Z",
          "updatedAt": "2018-05-14T22:48:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwMDMyMzMy",
          "commit": {
            "abbreviatedOid": "103b04c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-14T22:27:31Z",
          "updatedAt": "2018-05-14T22:49:55Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "The ALTSVC records don't matter as much here, and probably shouldn't be bound to the MUST. The rest LGTM.",
              "createdAt": "2018-05-14T22:27:31Z",
              "updatedAt": "2018-05-14T22:49:55Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3ad81cc1e3a141ca9ad90c5d184773a25cca4af8",
      "headRepository": null,
      "headRefName": "mulitple_records",
      "headRefOid": "103b04c10bfa6c946c7b290b13a5365661f0d71a",
      "mergeCommit": {
        "oid": "e19b8088bb5e81983c9b279614766cc8fa7839bf"
      }
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg4MjU3MTU1",
      "title": "normative reference to RFC 4408",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/36",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Lack of the specifier (`!`, `?`) was causing a build error when trying to build the HTML.",
      "createdAt": "2018-05-15T21:11:54Z",
      "updatedAt": "2018-05-15T22:09:55Z",
      "closedAt": "2018-05-15T22:09:55Z",
      "mergedAt": "2018-05-15T22:09:55Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e19b8088bb5e81983c9b279614766cc8fa7839bf",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/normative-reference-to-rfc4408",
      "headRefOid": "279d79a0697d792288df0054161568c76fe5a87e",
      "mergeCommit": {
        "oid": "6ba58db63026fed2bcbabe3290e2af451ee6f5bf"
      }
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg4ODMxMDY2",
      "title": "Remove `label`",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/43",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Now that #24 has been merged, label seems to be an unnecessary complication.\r\n\r\n* label has no actual use on the client\r\n* because labels cannot collide, the key generator needs to either keep some state across all invocations (you need a trustable store), or generate a UUID (it's just a random junk) to be used as a label\r\n* a TLS server is required to at first compare the label and then check the digest.\r\n\r\nThese three issues go away if we eliminate label. Key generators do not need to care about uniqueness. TLS servers can just look for the matching digest and that's it.\r\n\r\nNote that a server operator can still associate an identifier to the ESNIKeys structure for internal use. The private key will be kept in relation to the structure anyways. So having a private identifier does not complicate things at all.",
      "createdAt": "2018-05-17T18:59:43Z",
      "updatedAt": "2018-05-21T02:17:03Z",
      "closedAt": "2018-05-21T02:17:03Z",
      "mergedAt": "2018-05-21T02:17:02Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxMTg4MDY2",
          "commit": {
            "abbreviatedOid": "b5ce410"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGMT -- I much prefer content-based identifiers to labels. ",
          "createdAt": "2018-05-17T19:42:22Z",
          "updatedAt": "2018-05-17T19:42:33Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6276955dbfee725e5db060d38d66cd479d8acf58",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/no-label",
      "headRefOid": "b5ce41040b3f28706ae2f4aa99980e1f705d2e32",
      "mergeCommit": {
        "oid": "1e1a8ffcc57a616ab418e3097f583da96ce40f42"
      }
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg4ODQ1MzM3",
      "title": "Remove reference to ALTSVC",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/44",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #34\r\n\r\nAlso see https://github.com/ekr/draft-rescorla-tls-esni/pull/31#discussion_r188117285",
      "createdAt": "2018-05-17T19:59:40Z",
      "updatedAt": "2018-05-17T20:29:24Z",
      "closedAt": "2018-05-17T20:29:24Z",
      "mergedAt": "2018-05-17T20:29:24Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM -- thanks!",
          "createdAt": "2018-05-17T20:29:20Z",
          "updatedAt": "2018-05-17T20:29:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxMjAzNzA4",
          "commit": {
            "abbreviatedOid": "46b519f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-17T20:29:07Z",
          "updatedAt": "2018-05-17T20:29:07Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6276955dbfee725e5db060d38d66cd479d8acf58",
      "headRepository": null,
      "headRefName": "no-altsvc",
      "headRefOid": "46b519f3105f06796ef8c5dee7d2987179556a52",
      "mergeCommit": {
        "oid": "67ca02fdc6be26906aa401ad8e6a68f839c33a5d"
      }
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5MjU5OTIw",
      "title": "Tone down Fronting Mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/45",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@ghedo, PTAL! I tried Transparent mode, though this seemed subjectively better at the time. I'm happy to be convinced otherwise.",
      "createdAt": "2018-05-20T23:59:08Z",
      "updatedAt": "2018-05-21T00:08:27Z",
      "closedAt": "2018-05-21T00:08:27Z",
      "mergedAt": "2018-05-21T00:08:27Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "67ca02fdc6be26906aa401ad8e6a68f839c33a5d",
      "headRepository": null,
      "headRefName": "caw/nix-fronting",
      "headRefOid": "5b49eeb30048f04acff1fbcc4cfe74bce5111261",
      "mergeCommit": {
        "oid": "14cc61eec9b80485d1356857b20c356a1eda0b23"
      }
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5NDk3Mzg4",
      "title": "add a missing \"and\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/46",
      "state": "MERGED",
      "author": "reaperhulk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just a trivial fix \ud83d\ude04 ",
      "createdAt": "2018-05-21T21:50:35Z",
      "updatedAt": "2018-05-21T21:51:29Z",
      "closedAt": "2018-05-21T21:51:29Z",
      "mergedAt": "2018-05-21T21:51:29Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxOTU5NjM3",
          "commit": {
            "abbreviatedOid": "1a8b50a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-21T21:51:24Z",
          "updatedAt": "2018-05-21T21:51:24Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1e1a8ffcc57a616ab418e3097f583da96ce40f42",
      "headRepository": "reaperhulk/draft-rescorla-tls-esni",
      "headRefName": "patch-1",
      "headRefOid": "1a8b50a4e7240902024dcbdf753db69e34b07605",
      "mergeCommit": {
        "oid": "dd379d3031f72b6137d2bbee6d067d0787187b39"
      }
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkwNDYwNjkw",
      "title": "Add text regarding padding of wildcard delegations, and pad Certificate messages using padding(21)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/48",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-25T01:32:18Z",
      "updatedAt": "2018-06-16T01:49:21Z",
      "closedAt": "2018-06-12T17:28:51Z",
      "mergedAt": "2018-06-12T17:28:51Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzMjQ4MDY4",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for working on this! LGTM aside from the two comments shown below.",
          "createdAt": "2018-05-25T05:30:19Z",
          "updatedAt": "2018-05-25T05:35:11Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Shouldn't we pad the Certificate message so that it would become as large as the largest Certificate message that ~~would be offered from the server's IP address~~ is covered by the same ESNI key?\r\n\r\nThe same goes for the provision in the Split Mode.",
              "createdAt": "2018-05-25T05:30:19Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            },
            {
              "originalPosition": 27,
              "body": "Considering the fact that the distribution of the ESNI keys is not limited to DNS, it might be worth specifying that the 256 chars limitation is specific to when DNS is being used; e.g. \"If the server supports wildcard names *resolved by DNS*\".",
              "createdAt": "2018-05-25T05:34:24Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzMzU1MDcy",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-25T12:38:57Z",
          "updatedAt": "2018-05-25T12:39:03Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I agree with what @kazuho says here. It's not straightforward.\r\n\r\nit's worth noting that this is one case in which random padding might be of some value, because the attacker doesn't know which connections correspond to the same SNI, and therefore can't do simple averageing.",
              "createdAt": "2018-05-25T12:38:57Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNDMxMTM4",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-25T16:10:12Z",
          "updatedAt": "2018-05-25T16:10:13Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "@kazuho I like it -- that's more precise. I'll update accordingly.",
              "createdAt": "2018-05-25T16:10:12Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNDMxMzAx",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-25T16:10:45Z",
          "updatedAt": "2018-05-25T16:10:45Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-05-25T16:10:45Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTQ4ODM5",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-26T06:10:35Z",
          "updatedAt": "2018-05-26T06:10:35Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-05-26T06:10:35Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTkwMDg2",
          "commit": {
            "abbreviatedOid": "e10707d"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-27T17:10:22Z",
          "updatedAt": "2018-05-27T17:10:25Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Why do you think we should use this rather than pad at the record layer?",
              "createdAt": "2018-05-27T17:10:22Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTkwOTkw",
          "commit": {
            "abbreviatedOid": "e10707d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-27T17:51:20Z",
          "updatedAt": "2018-05-27T17:51:20Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "IIUC one could pad Certificate messages offline, if you wanted. One could also pad at the record later. I\u2019ll just note one or the other. ",
              "createdAt": "2018-05-27T17:51:20Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDY3MDEw",
          "commit": {
            "abbreviatedOid": "3d1c6d4"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Sorry, I missed the padding thing, so you'll need to adjust",
          "createdAt": "2018-06-12T17:21:14Z",
          "updatedAt": "2018-06-12T17:22:02Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Actually, you can't use padding here. It's only allowed in CH.",
              "createdAt": "2018-06-12T17:21:15Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDcxNzYw",
          "commit": {
            "abbreviatedOid": "095eae5"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T17:33:54Z",
          "updatedAt": "2018-06-15T23:28:17Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "This change is unrelated. ",
              "createdAt": "2018-06-12T17:33:55Z",
              "updatedAt": "2018-06-15T23:28:17Z"
            },
            {
              "originalPosition": 83,
              "body": "Again, this recommendation describes a single anonymity set.  Because the size of esni and certificate both contribute to information that distinguishes connections, you should include text on padding that addresses the combination of the two fields.",
              "createdAt": "2018-06-15T23:25:47Z",
              "updatedAt": "2018-06-15T23:28:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzUwMzgz",
          "commit": {
            "abbreviatedOid": "095eae5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-16T01:49:04Z",
          "updatedAt": "2018-06-16T01:49:04Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Yeah. The document failed to build with this, so I removed it. ",
              "createdAt": "2018-06-16T01:49:04Z",
              "updatedAt": "2018-06-16T01:49:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzUwMzkw",
          "commit": {
            "abbreviatedOid": "095eae5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-16T01:49:21Z",
          "updatedAt": "2018-06-16T01:49:21Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Yep, good point. I\u2019ll update in a separate PR. ",
              "createdAt": "2018-06-16T01:49:21Z",
              "updatedAt": "2018-06-16T01:49:21Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "dd379d3031f72b6137d2bbee6d067d0787187b39",
      "headRepository": null,
      "headRefName": "caw/padded",
      "headRefOid": "095eae5ab689aaec89bdabbefb7f9b8caace394b",
      "mergeCommit": {
        "oid": "44589659396b2f58fccb980860f270cdcbe42684"
      }
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0MTQ2ODg5",
      "title": "Briefly discuss pros and cons of alternative designs",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/49",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-12T01:56:08Z",
      "updatedAt": "2018-06-20T22:53:19Z",
      "closedAt": "2018-06-20T22:50:19Z",
      "mergedAt": "2018-06-20T22:50:19Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood Thank you for the changes. It's super clear to me now.",
          "createdAt": "2018-06-20T22:53:18Z",
          "updatedAt": "2018-06-20T22:53:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODA1NTQ5",
          "commit": {
            "abbreviatedOid": "e0403f5"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for working on the improvement.\r\n\r\nIt was easy to read, and I like the way you categorize the approaches. I have left my comments in-line.",
          "createdAt": "2018-06-12T02:57:21Z",
          "updatedAt": "2018-06-12T03:02:50Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I am not sure if \"TLS tunnel\" requires a previous session or the use of 0-RTT data.\r\n\r\nWould you mind considering either adjusting the name or adjusting the text? Because what I expect for a scheme called \"TLS tunnel\" is as follows:\r\n\r\n\"TLS tunnel\" is an approach that first establishes a TLS connection to a fronting host, and then, on top of that connection, establishes another TLS connection that uses the hostname of the hidden host.\r\n\r\nIf that is the case, I'd assume that all prior knowledge that is necessary is the binding between two names: name of the fronting host and that of the hidden host.\r\n\r\nIn other words, I'd expect that the \"TLS Tunnel\" scheme will be distributing using DNS the name of the fronting host instead of the ESNI key.\r\n\r\nThe downside of the tunneling is approach will be that there will be additional roundtrip when 0-RTT is not used, as well as the cost of double handshake and double encryption.",
              "createdAt": "2018-06-12T02:57:22Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            },
            {
              "originalPosition": 47,
              "body": "Doesn't the scheme also has the bootstrap problem: i.e. distributing the name of the client-facing server that corresponds to the name of the server that the client actually wants to connect to?\r\n\r\nI can see that such binding can sometimes advertised eagerly using the CERTIFICATE frames, but I do not think that can be done for every host that the client might want to connect to.",
              "createdAt": "2018-06-12T03:01:38Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzE1NjI2",
          "commit": {
            "abbreviatedOid": "e0403f5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-15T20:59:16Z",
          "updatedAt": "2018-06-15T20:59:16Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Depending on how it's done, yeah, bootstrapping is also an issue here. I'll mention that.",
              "createdAt": "2018-06-15T20:59:16Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzE3MjY5",
          "commit": {
            "abbreviatedOid": "2c95fcd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-15T21:05:49Z",
          "updatedAt": "2018-06-15T21:05:49Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "@kazuho The tunnel approach you describe is a simple proxy. We can describe it here, though it's different from what was the \"hide TLS in early data\" proposal. I updated the title to try to make it more clear.",
              "createdAt": "2018-06-15T21:05:49Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5NDI4NTgy",
          "commit": {
            "abbreviatedOid": "2c95fcd"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-18T05:09:11Z",
          "updatedAt": "2018-06-18T05:09:11Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Thank you for the changes.\r\n\r\nNow I think I understand the approach suggested here; it's about encapsulating CH using 0-RTT data of an outer TLS connection, but sending the rest of the TLS transmissions directly (i.e. without double encryption).\r\n\r\nAssuming that that is true, it might be worth clarifying that (e.g., state something like \"Rest of the TLS messages / records are exchanged directly between the peers without double encryption\").\r\n\r\nOther than that, the PR looks to be ready for merge.",
              "createdAt": "2018-06-18T05:09:11Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMTYyMjE3",
          "commit": {
            "abbreviatedOid": "7a96223"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-19T21:13:53Z",
          "updatedAt": "2018-06-19T21:13:53Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "@kazuho I added some clarifying text. Please have a look!",
              "createdAt": "2018-06-19T21:13:53Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMTgyMjIw",
          "commit": {
            "abbreviatedOid": "7a96223"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-19T22:22:58Z",
          "updatedAt": "2018-06-19T22:22:58Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Thank you for explicitly stating that only Client Hello is sent as 0-RTT data.\r\n\r\nMaybe we might want to change the sentence starting from \"All Server Hello ...\" to something like \"Rest of the exchanges between the client and the hidden server, starting from Server Hello, are forwarded by the client-facing server -- unmodified.\", to clarify that exchanges following Server Hello are also forwarded directly.\r\n\r\nOther than that, the PR looks ready for merge to me.",
              "createdAt": "2018-06-19T22:22:58Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMTgyODM3",
          "commit": {
            "abbreviatedOid": "7a96223"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-19T22:25:33Z",
          "updatedAt": "2018-06-19T22:25:33Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "@kazuho  I don't think that's necessary, since the remaining messages must necessarily also be forwarded.",
              "createdAt": "2018-06-19T22:25:33Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMTg1NzM4",
          "commit": {
            "abbreviatedOid": "7a96223"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-19T22:38:48Z",
          "updatedAt": "2018-06-19T22:38:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "The reason I suggested the change is because the paragraph seemed to be unclear to me on whether or not the handshake messages and application data that follows Server Hello is double-encrypted, because it only discusses about Client Hello and Server Hello explicitly.",
              "createdAt": "2018-06-19T22:38:48Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMjA1NzIx",
          "commit": {
            "abbreviatedOid": "35eb736"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-20T00:28:08Z",
          "updatedAt": "2018-06-20T00:28:08Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "@kazuho Should be more clear now!",
              "createdAt": "2018-06-20T00:28:08Z",
              "updatedAt": "2018-06-20T00:28:08Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "44589659396b2f58fccb980860f270cdcbe42684",
      "headRepository": null,
      "headRefName": "caw/alternates",
      "headRefOid": "35eb736a1fd180e0364d3a0ba036cbcd483c1ca2",
      "mergeCommit": {
        "oid": "368ed7d1ba6bd0124fe1afe7f0a7c33c2dd03650"
      }
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1MjkxMjE2",
      "title": "Add Nick",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/50",
      "state": "MERGED",
      "author": "grittygrease",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-15T21:54:29Z",
      "updatedAt": "2018-06-15T21:54:49Z",
      "closedAt": "2018-06-15T21:54:49Z",
      "mergedAt": "2018-06-15T21:54:49Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzI4MTM0",
          "commit": {
            "abbreviatedOid": "d4af1ee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-15T21:54:45Z",
          "updatedAt": "2018-06-15T21:54:45Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "44589659396b2f58fccb980860f270cdcbe42684",
      "headRepository": "grittygrease/draft-rescorla-tls-esni",
      "headRefName": "nick/author",
      "headRefOid": "d4af1ee50283017f52d56ee587f567876514bc90",
      "mergeCommit": {
        "oid": "99de7bde18aed8a52e362ae0b33a89540efbbbba"
      }
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2NjI4NTkw",
      "title": "Self-add author.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/51",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Please do not merge yet!",
      "createdAt": "2018-06-22T03:22:55Z",
      "updatedAt": "2018-06-25T19:42:07Z",
      "closedAt": "2018-06-25T19:42:07Z",
      "mergedAt": "2018-06-25T19:42:07Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "368ed7d1ba6bd0124fe1afe7f0a7c33c2dd03650",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/author",
      "headRefOid": "1a8b0959b887f86ca8bf9f93c4e6652c9a341020",
      "mergeCommit": {
        "oid": "f0e80361e890e99d86477c8c03b86a4b51699f76"
      }
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NTIzMjg2",
      "title": "Fix use of padded_length",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/52",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\"padding_length\" appears out of nowhere and is not defined.",
      "createdAt": "2018-07-01T12:59:36Z",
      "updatedAt": "2018-07-02T14:11:47Z",
      "closedAt": "2018-07-02T14:11:47Z",
      "mergedAt": "2018-07-02T14:11:47Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": null,
      "headRefName": "padding_len",
      "headRefOid": "0348f408b95c833744de9571f9ce9a09de4f1f34",
      "mergeCommit": {
        "oid": "df2fcf152d436683090eb0ae395dddd699ed33f4"
      }
    },
    {
      "number": 53,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NTIzNjc3",
      "title": "Prevent clients from caching keys based on not_after",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/53",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-01T13:09:03Z",
      "updatedAt": "2018-07-02T14:15:50Z",
      "closedAt": "2018-07-02T14:15:50Z",
      "mergedAt": "2018-07-02T14:15:50Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNDU1NzA2",
          "commit": {
            "abbreviatedOid": "9f452fa"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-01T14:19:43Z",
          "updatedAt": "2018-07-01T14:19:43Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I am sympathetic to the proposed change, but might prefer using \"SHOULD NOT\" rather than a \"MUST NOT\" here.\r\n\r\nConsider a client that uses `getaddrinfo`. The client cannot access the TTL value. OTOH, it makes sense for such a client to cache the query result for a short amount of time to reduce the load on the resolver running on the client machine. My understanding is that some clients are implemented that way.",
              "createdAt": "2018-07-01T14:19:43Z",
              "updatedAt": "2018-07-01T14:19:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNTk1MTk2",
          "commit": {
            "abbreviatedOid": "9f452fa"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-02T11:54:59Z",
          "updatedAt": "2018-07-02T11:54:59Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This PR only prevents the client from using \"not_after\" for caching, it doesn't really forbid using another random value (not sure if we want to be more specific on this).\r\n\r\nAnyway, I'm fine changing this to SHOULD NOT.",
              "createdAt": "2018-07-02T11:54:59Z",
              "updatedAt": "2018-07-02T11:54:59Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": null,
      "headRefName": "client_cache",
      "headRefOid": "9f452faf97a5cc082dea2c548a2d9e487a480617",
      "mergeCommit": {
        "oid": "237cb9dd389c23224379eb0cfd1f72211403d0db"
      }
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NTI2MjE1",
      "title": "ServerNameList should be 260 octets long for fronting servers with wildcard support",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/54",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Because the longest name is 255 octets (see RFC 1035), and there is 5-octet overhead in the ServerNameList structure (defined in RFC 6066 as shown below).\r\n\r\n```\r\n      struct {\r\n          NameType name_type;\r\n          select (name_type) {\r\n              case host_name: HostName;\r\n          } name;\r\n      } ServerName;\r\n\r\n      enum {\r\n          host_name(0), (255)\r\n      } NameType;\r\n\r\n      opaque HostName<1..2^16-1>;\r\n\r\n      struct {\r\n          ServerName server_name_list<1..2^16-1>\r\n      } ServerNameList;\r\n```\r\n\r\namends #48 ",
      "createdAt": "2018-07-01T14:12:23Z",
      "updatedAt": "2018-07-02T14:15:27Z",
      "closedAt": "2018-07-02T14:15:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why not just pad the name ? Then the field can be 1 octet. ",
          "createdAt": "2018-07-01T23:50:55Z",
          "updatedAt": "2018-07-01T23:50:55Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson \r\n> Why not just pad the name ? Then the field can be 1 octet.\r\n\r\nThat's definitely possible, but I am not sure if we want to do that.\r\n\r\nUntil now, we have tried to consider ServerNameList  (the server_name extension) as an abstract structure. Current draft allows us to use the ESNIKeys to encrypt a server_name extension of any name_type.\r\n\r\nDefining padded_length to designate the length of the HostName field that exists only when server_name.name_type == host_name destroys that abstraction.\r\n\r\nNote also that specifying the amount of padding appended to ServerNameList based on the value of `ServerNameList[0].name.HostName` makes implementations complex. This is because you would be required to parse the struct before validating the length of the padding.\r\n\r\nGenerally speaking, I am not opposed to dealing directly with \"hostname\"s stored in the server_name extension. However, if that is the case, I think we should consider adding a `encrypted_host_name` type to the NameType so that we do not need to deal with the complex structure of ServerNameList.",
          "createdAt": "2018-07-02T01:47:30Z",
          "updatedAt": "2018-07-02T01:47:58Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to think we should leave it as-is rather than breaking the\nencapsulation barrier.\n\nOn Sun, Jul 1, 2018 at 6:47 PM, Kazuho Oku <notifications@github.com> wrote:\n\n> @martinthomson <https://github.com/martinthomson>\n>\n> Why not just pad the name ? Then the field can be 1 octet.\n>\n> That's definitely possible, but I am not sure if we want to do that.\n>\n> Until now, we have tried to consider ServerNameList (the server_name\n> extension) as an abstract structure. Current draft allows us to use the\n> ESNIKeys to encrypt a server_name extension of any name_type.\n>\n> Defining padded_length to designate the length of the HostName field that\n> exists only when server_name.name_type == host_name destroys that\n> abstraction.\n>\n> Note also that specifying the amount of padding appended to ServerNameList\n> based on the value of ServerNameList[0].name.HostName makes\n> implementations complex. This is because you would be required to parse the\n> struct before validating the length of the padding.\n>\n> Generally speaking, I am not opposed removing the restriction to directly\n> deal with \"hostname\"s stored in the server_name extension. However, if that\n> is the case, I think we should consider adding a encrypted_host_name type\n> to the NameType so that we do not need to deal with the complex structure\n> of ServerNameList.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/pull/54#issuecomment-401650517>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oYVLU7B1rR_BJVCq4dYXulz-mKLJks5uCXuygaJpZM4U-VrF>\n> .\n>\n",
          "createdAt": "2018-07-02T02:33:45Z",
          "updatedAt": "2018-07-02T02:33:45Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/fix-max-length",
      "headRefOid": "c153340a60062c6698015e805ca9690d5782a721",
      "mergeCommit": null
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NjU0NDEx",
      "title": "Make server send empty encrypted_server_name in EE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/55",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Since encrypted_server_name mirrors server_name, I think it makes sense\r\nfor the server to send this back.\r\n\r\n---\r\n\r\nI don't quite understand the objection regarding \"stock servers\", @ekr ?",
      "createdAt": "2018-07-02T11:46:59Z",
      "updatedAt": "2018-07-09T14:01:34Z",
      "closedAt": "2018-07-03T08:53:07Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This will make it impossible to run in split mode without modifying your server, which I think is bad.",
          "createdAt": "2018-07-02T12:47:55Z",
          "updatedAt": "2018-07-02T12:47:55Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Not putting this in -00",
          "createdAt": "2018-07-02T14:10:04Z",
          "updatedAt": "2018-07-02T14:10:04Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh, I see what you mean now. FWIW, we could just make the Shared Mode server echo the extension. RFC6066 says:\r\n```\r\n   A server that receives a client hello containing the \"server_name\"\r\n   extension MAY use the information contained in the extension to guide\r\n   its selection of an appropriate certificate to return to the client,\r\n   and/or other aspects of security policy.  In this event, the server\r\n   SHALL include an extension of type \"server_name\" in the (extended)\r\n   server hello.\r\n```\r\n\r\nSo if we adopt a similar text, the split mode hidden server technically doesn't use ESNI to select the certificate, so it wouldn't need to echo the extension.",
          "createdAt": "2018-07-02T19:57:46Z",
          "updatedAt": "2018-07-02T19:57:46Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Though now I'm questioning how useful this is at all... even with plain \"server_name\", do clients care if they get back the empty extension?",
          "createdAt": "2018-07-02T20:02:52Z",
          "updatedAt": "2018-07-02T20:02:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Clients just ignore SNI from a server: there is no point in a server ever sending it.  It's just another bit of cruftiness in RFC 6066.  (Oh, how I wish that I could enumerate the ways in which that RFC is bad...)",
          "createdAt": "2018-07-03T01:07:43Z",
          "updatedAt": "2018-07-03T01:07:43Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, so, I guess we don't really want this at all then. I'll make a PR to remove the OPEN ISSUE.",
          "createdAt": "2018-07-03T08:53:07Z",
          "updatedAt": "2018-07-03T08:53:07Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Concur.",
          "createdAt": "2018-07-09T14:01:33Z",
          "updatedAt": "2018-07-09T14:01:33Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": null,
      "headRefName": "server_echo",
      "headRefOid": "106d313f0a7c37833b0ebb2e77a22fe12592cb8f",
      "mergeCommit": null
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NjU1Mzky",
      "title": "Add IANA considerations and pick a codepoint from the reserved range",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/56",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "**NOTE**, this depends on https://github.com/ekr/draft-rescorla-tls-esni/pull/55 and if we decide that we don't want to send the empty extension in EE, then it needs to be removed from this PR too.",
      "createdAt": "2018-07-02T11:51:37Z",
      "updatedAt": "2018-07-02T14:14:14Z",
      "closedAt": "2018-07-02T14:14:14Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": null,
      "headRefName": "iana",
      "headRefOid": "bb30359063a7189be2e7440b3f9f676ae1544ac8",
      "mergeCommit": null
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4Nzc3ODIy",
      "title": "clock skew is about not_after, record TTL will not be affected by that",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/57",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-02T20:12:11Z",
      "updatedAt": "2018-07-02T20:46:08Z",
      "closedAt": "2018-07-02T20:14:19Z",
      "mergedAt": "2018-07-02T20:14:19Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure this is much better. I would changes the \"Note that servers...\" sentence to something like:\r\n\r\n> Note that servers MAY need to retain the decryption key for some time after \"not_after\", and will need to consider clock skew, internal caches and the like, when selecting the \"not_before\" and \"not_after\" values.",
          "createdAt": "2018-07-02T20:43:35Z",
          "updatedAt": "2018-07-02T20:43:35Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See https://github.com/ekr/draft-rescorla-tls-esni/pull/59",
          "createdAt": "2018-07-02T20:46:08Z",
          "updatedAt": "2018-07-02T20:46:08Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "0cd1d37cfd9d8cd7eadb3f0f7204853969f5f14c",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/reorg-not-after-vs-ttl-discussion",
      "headRefOid": "d75151312c15814691390e2c53833a99598cd037",
      "mergeCommit": {
        "oid": "3f4ec98e02e5a0478e08041ac93cfdc8300938ee"
      }
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4Nzc4MDI0",
      "title": "Remove the use of 'hidden'",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/58",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I decided \"hidden\" was bad.\r\n\r\n@mcmanus",
      "createdAt": "2018-07-02T20:13:07Z",
      "updatedAt": "2018-07-02T20:31:05Z",
      "closedAt": "2018-07-02T20:31:05Z",
      "mergedAt": "2018-07-02T20:31:05Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNzYyODYw",
          "commit": {
            "abbreviatedOid": "9d83bc9"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "+1 to the change. I think that this is the right direction.",
          "createdAt": "2018-07-02T20:18:19Z",
          "updatedAt": "2018-07-02T20:27:32Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "\"private private\" => \"private domains\"",
              "createdAt": "2018-07-02T20:18:19Z",
              "updatedAt": "2018-07-02T20:30:48Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "0cd1d37cfd9d8cd7eadb3f0f7204853969f5f14c",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "terminology",
      "headRefOid": "b6c54c7c0a657c91f6e506b8852e7fa16d9e7eac",
      "mergeCommit": {
        "oid": "6611fb65fa444721fa22ebc3e2303e1d12dab219"
      }
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4Nzg1MDg3",
      "title": "Try to clarify clock skew sentence some more",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/59",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-02T20:45:42Z",
      "updatedAt": "2018-07-02T21:12:08Z",
      "closedAt": "2018-07-02T21:12:07Z",
      "mergedAt": "2018-07-02T21:12:07Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6611fb65fa444721fa22ebc3e2303e1d12dab219",
      "headRepository": null,
      "headRefName": "more_nitpick_language",
      "headRefOid": "ce7622476cd7b0ecc172c5cb405cd200a11e7f82",
      "mergeCommit": {
        "oid": "91ea306749c85e77f7e749469cc2e3aa40362211"
      }
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4ODkzNjY4",
      "title": "Remove OPEN ISSUE about sending empty ESNI in EE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/60",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As per discussion in https://github.com/ekr/draft-rescorla-tls-esni/pull/55\r\nthis would require changes to Split Mode backend servers, and it turns out\r\nthat even for plain \"server_name\" this behaviour is pretty much useless.",
      "createdAt": "2018-07-03T08:56:39Z",
      "updatedAt": "2018-07-09T14:19:17Z",
      "closedAt": "2018-07-09T14:19:16Z",
      "mergedAt": "2018-07-09T14:19:16Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "91ea306749c85e77f7e749469cc2e3aa40362211",
      "headRepository": null,
      "headRefName": "remove_open_issue",
      "headRefOid": "54d7151f1a706036e6d3320d1eede151ec4ed39c",
      "mergeCommit": {
        "oid": "e72b0512cc779f2273f72a794af18a36598d19a2"
      }
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5NjA5NzYz",
      "title": "allow use of different Key Share for ESNI and handshake",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/70",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As pointed out in #69, current draft allows a client-facing server to downgrade the TLS handshake under Split mode.\r\n\r\nFor example, if the hidden server supports X25519 and X448 but the ESNIKeys published by the client-facing server only includes X25519, client only sends X25519.\r\n\r\nThis PR fixes the issue in the least intrusive way, by allowing the parties to use different key shares for ESNI and TLS key schedule.\r\n\r\nIn short, KE for ESNI is selected by the server offering the list of supported groups in ESNIKeys and client choosing one; KE for key schedule is selected exactly the same way as is defined in TLS 1.3.\r\n\r\nfixes #67",
      "createdAt": "2018-07-05T23:17:42Z",
      "updatedAt": "2018-07-11T01:36:55Z",
      "closedAt": "2018-07-11T01:36:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: I haven't gone through this in detail, but doesn't this create the possibility of a cut-and-paste attack if the client uses a less-preferred group.\r\n\r\nConsider the case where the server's preferences are [X448, X25519] and the client's preferences are [X25519, X448]. The client sends one key share: X25519. The attacker then adds his own X448 share. The server decrypts SNI but sends an X448 share, thus allowing the attacker to decrypt the certificate. Is there a reason why this won't work?",
          "createdAt": "2018-07-05T23:33:49Z",
          "updatedAt": "2018-07-05T23:33:49Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr I think you are correct. Thank you for pointing that out. I now understand that the approach used in this PR does not work.\r\n\r\nI also notice that under Split mode, KEs and cipher-suites that can be offered in ESNIKeys will be the intersection of those supported by the various hidden servers. That would mean that the operator of the client-facing server will need to instruct the operators of hidden servers which KE and cipher-suites that they must support; otherwise only secp256r1 / aes128gcm-sha256 will be usable in practice.",
          "createdAt": "2018-07-06T00:18:57Z",
          "updatedAt": "2018-07-06T00:18:57Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "91ea306749c85e77f7e749469cc2e3aa40362211",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/different-ke-for-esni-and-handshake",
      "headRefOid": "6bd78b7a76b1ec9f66c652e28928a4a4d01ccc95",
      "mergeCommit": null
    },
    {
      "number": 71,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwMTQ0MTE0",
      "title": "Clarifications",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/71",
      "state": "CLOSED",
      "author": "tmshort",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Use active tense in some places to clarify meaning.\r\nConsolidate shared and split mode common description.\r\nAdd anonymity set size Security Consideration",
      "createdAt": "2018-07-09T15:51:41Z",
      "updatedAt": "2019-10-25T17:57:49Z",
      "closedAt": "2019-10-25T17:57:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing due to staleness. @tmshort, please re-open and update if you still think we need this.",
          "createdAt": "2019-10-25T17:57:49Z",
          "updatedAt": "2019-10-25T17:57:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NDk1OTAx",
          "commit": {
            "abbreviatedOid": "1c26075"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-07-09T16:29:34Z",
          "updatedAt": "2018-07-09T16:31:08Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I think this creates confusion. From the TLS perspective, the Client-Facing server is the origin server.",
              "createdAt": "2018-07-09T16:29:34Z",
              "updatedAt": "2018-07-10T13:07:52Z"
            },
            {
              "originalPosition": 76,
              "body": "I think you need to soften this point. It's true in principle, but plenty of monitoring entities will not have access to this information.",
              "createdAt": "2018-07-09T16:30:51Z",
              "updatedAt": "2018-07-10T13:07:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NTE3MTky",
          "commit": {
            "abbreviatedOid": "1c26075"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T17:27:49Z",
          "updatedAt": "2018-07-09T17:27:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Understood. Proxy-mode (as I described) is a hybrid of Shared and Split mode. Any CDN that caches content will operate in this proxy mode. Few operate in split mode; which seems to be more like a firewall in PNAT mode.\r\nSo, proxy-mode be considered a special case of shared mode? \r\n\r\n",
              "createdAt": "2018-07-09T17:27:49Z",
              "updatedAt": "2018-07-10T13:07:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NTIyNTg5",
          "commit": {
            "abbreviatedOid": "1c26075"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T17:42:38Z",
          "updatedAt": "2018-07-09T17:42:38Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Thinking about it some more, the difference between these two modes is termination of the TLS connection, rather than where the origin server (and data) actually are. I will try to come up with something.",
              "createdAt": "2018-07-09T17:42:38Z",
              "updatedAt": "2018-07-10T13:07:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1ODczODk2",
          "commit": {
            "abbreviatedOid": "aa1bd7a"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-10T15:13:38Z",
          "updatedAt": "2018-07-10T15:13:38Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "softened.",
              "createdAt": "2018-07-10T15:13:38Z",
              "updatedAt": "2018-07-10T15:13:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2MDY2Njc5",
          "commit": {
            "abbreviatedOid": "aa1bd7a"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-11T01:43:37Z",
          "updatedAt": "2018-07-11T01:43:37Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Use of words like \"origin\" and \"retrieves content\" (below) might sound like that the use of HTTP is implied. It might make sense avoid using such words, and rather talk about things like \"server that terminates TLS\" or \"application data\".",
              "createdAt": "2018-07-11T01:43:37Z",
              "updatedAt": "2018-07-11T01:44:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2Mjg5MDYw",
          "commit": {
            "abbreviatedOid": "aa1bd7a"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-11T15:15:03Z",
          "updatedAt": "2018-07-11T15:15:04Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This is the text for the common case between shared and split mode. The origin server has different behavior in each case. \r\n\r\nIn shared mode the client-facing-server terminates TLS; the origin may be elsewhere. In split mode, the origin behind the client-facing-server is the server that terminates TLS. That distinction is made below, not here.\r\n\r\nThis text was moved, with minor modifications, from it's original location. The term \"origin\" is frequently used within the CDN community, and has a well-understood meaning. I purposely used \"retrieves content\", because the origin server may very well only use HTTP, if it's a private server protected by this client-facing server.  But I can change it to \"application data\"; I'm not sure it really maters.\r\n\r\n",
              "createdAt": "2018-07-11T15:15:03Z",
              "updatedAt": "2018-07-11T15:15:50Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e72b0512cc779f2273f72a794af18a36598d19a2",
      "headRepository": "tmshort/draft-rescorla-tls-esni",
      "headRefName": "master-tmshort",
      "headRefOid": "aa1bd7ae6eff44e7e2112e6673f09ac3ad9e1af5",
      "mergeCommit": null
    },
    {
      "number": 72,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwNzU0OTcy",
      "title": "Support both specific RR type and TXT",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/72",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The idea here is to have a new RR type which makes DNS people happier, but also be able to fallback to the plain TXT lookup to address @kazuho's concerns.\r\n\r\nThis should also fix #35 since the ESNI lookup will follow the CNAME, I _think_.\r\n\r\nThe ESNI RRData format is kind of dumb, so we probably need to make it better.",
      "createdAt": "2018-07-11T16:16:58Z",
      "updatedAt": "2018-07-11T17:35:15Z",
      "closedAt": "2018-07-11T17:35:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is general opposition to doing both ESNI and TXT records, so I made https://github.com/ekr/draft-rescorla-tls-esni/pull/73 to just add a new ESNI RR type.",
          "createdAt": "2018-07-11T17:35:15Z",
          "updatedAt": "2018-07-11T17:35:15Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e72b0512cc779f2273f72a794af18a36598d19a2",
      "headRepository": null,
      "headRefName": "rrtype",
      "headRefOid": "7d69391b239f21f8cf6c3fae18f1fb51558ec9ca",
      "mergeCommit": null
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwNzc0MTIw",
      "title": "Replace TXT record with dedicated RRType",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/73",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #35.\r\n\r\n---\r\n\r\nThe problem this introduces is that the domain owner won't be able to delegate just the ESNI record of the apex name, to a different DNS provider (like they would be able to do if we used a separate \"_esni.\" prefix), which might prevent adoption from CDNs that do not handle DNS (or that allow customers to use an external DNS provider), since they would need to update the ESNI record frequently for key rotation.\r\n\r\nOn the other hand it solves the CNAME problem outlined in #35.",
      "createdAt": "2018-07-11T17:31:54Z",
      "updatedAt": "2019-03-06T00:55:10Z",
      "closedAt": "2019-03-06T00:55:10Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> The problem this introduces is that the domain owner won't be able to delegate just the ESNI record of the apex name, to a different DNS provider (like they would be able to do if we used a separate \"_esni.\" prefix), which might prevent adoption from CDNs that do not handle DNS (or that allow customers to use an external DNS provider), since they would need to update the ESNI record frequently for key rotation.\r\n\r\nThis is true, and I would like to avoid the problem. May I ask why you need to remove the prefix? I do not see a reason why we cannot use a prefix _and_ a dedicated type at the same time.\r\n\r\nI prefer discussing whether the `_esni.example.com` record should use TXT or a dedicated type, and if we decide to go with a dedicated type, then we might consider if having a prefix is OK.\r\n\r\n> On the other hand it solves the CNAME problem outlined in #35.\r\n\r\nI do not see how it solves the problem.\r\n\r\nConsider the case where the load of `foo.example.com` uses `cdnA.example` and `cdnB.example`. In such case, `foo.example.com` will sometimes be a CNAME to `cdnA.example` and sometimes to `cdnB.example`.\r\n\r\nWe want both the query for A and ESNI to use the same CNAME.\r\n\r\nBut there is no guarantee that the two queries will reach the recursive resolver at the same time. If they arrive at different time, the recursive resolver might return an A using CNAME `cdnA.example`, then query for `foo.example.com` for ESNI that might return `cdnB.example`.\r\n\r\nAm I missing something?",
          "createdAt": "2018-07-11T18:01:32Z",
          "updatedAt": "2018-07-11T18:16:01Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> May I ask why you need to remove the prefix? I do not see a reason why we cannot use a prefix and a dedicated type at the same time.\r\n\r\nBecause then a single CNAME can cover both the A/AAAA records and ESNI. I don't think keeping the prefix with a dedicated RR type makes a whole lot of sense, since they are both meant to signal that this is an ESNI query (that is, they are redundant).\r\n\r\nFWIW, #35 is not the main motivator for this. Simplifying DNS automatic processing server-side is (e.g. automatically handling ESNI for multiple domains at a time, rather than configuring single ones on their own). The need to handle a prefix in a query makes processing kind of awkward.\r\n\r\n> But there is no guarantee that the two queries will reach the recursive resolver at the same time\r\n\r\nThat is true of the status quo as well (which would require you to e.g. CNAME the _esni record as well, and keep it in sync with the CNAME of the main domain).\r\n\r\nThe only possible way an atomic query could work that I can think of is if the DNS server returned the ESNI answer as \"additional data\" of the A/AAAA response (which would also need some way to negotiate e.g. an EDNS(0)/OPT flag or something), though I don't know if this would work with resolvers.",
          "createdAt": "2018-07-11T20:38:19Z",
          "updatedAt": "2018-07-11T20:38:19Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Because then a single CNAME can cover both the A/AAAA records and ESNI. I don't think keeping the prefix with a dedicated RR type makes a whole lot of sense, since they are both meant to signal that this is an ESNI query (that is, they are redundant).\r\n> \r\n> FWIW, #35 is not the main motivator for this. Simplifying DNS automatic processing server-side is (e.g. automatically handling ESNI for multiple domains at a time, rather than configuring single ones on their own). The need to handle a prefix in a query makes processing kind of awkward.\r\n\r\nAs we agree, having no prefix is a no-go for certain deployments.\r\n\r\nI would also argue that providing customers of CDN the ability to opt-in to ESNI is important, especially during the early stages. Otherwise, CDNs cannot starting ESNI for _any_ domains until _all_ their customers permit the use ESNI.\r\n\r\nI can understand your argument about simplicity, but seeing wider adoption seems more important to me. And all this discussion is _not_ about the record type about having prefix; hence the suggestion to limit the scope of the PR to changing the type only.",
          "createdAt": "2018-07-11T21:59:46Z",
          "updatedAt": "2018-07-11T21:59:46Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho ok I restored the prefix for now and removed the reference to #35, though the page is not updating with the new commits for some reason.",
          "createdAt": "2018-07-12T12:11:45Z",
          "updatedAt": "2018-07-12T12:11:45Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased and updated after https://github.com/ekr/draft-rescorla-tls-esni/pull/76 got merged.",
          "createdAt": "2018-07-19T19:36:55Z",
          "updatedAt": "2018-07-19T19:36:55Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased on master.",
          "createdAt": "2018-09-24T12:39:47Z",
          "updatedAt": "2018-09-24T12:39:47Z"
        },
        {
          "author": "mhofman",
          "authorAssociation": "NONE",
          "body": ">> Because then a single CNAME can cover both the A/AAAA records and ESNI. I don't think keeping the prefix with a dedicated RR type makes a whole lot of sense, since they are both meant to signal that this is an ESNI query (that is, they are redundant).\r\n>\r\n> As we agree, having no prefix is a no-go for certain deployments.\r\n\r\nI'm wondering, couldn't both non-prefixed and prefixed records be allowed to cover all cases?\r\n\r\nThe client would start simultaneous queries on the non-prefixed name for A/AAAA records, non-prefixed ESNI records, and for the _esni prefixed TXT (or ESNI?) record.\r\nIf an ESNI record is present on the non-prefixed name, the client uses it immediately, discarding whatever answer may be provided for the _esni prefix.\r\n\r\nIt would solve the wildcard use case (#79), while keeping the option of the _esni prefix for cases where delegation is needed (e.g. APEX or when the DNS and CDN providers are separate).\r\n\r\nWhile in itself it doesn't solve the case of a domain balanced over multiple CDNs like mentioned in #35, it does open the door to improvements when/if [multiple QTYPEs in queries](https://tools.ietf.org/html/draft-bellis-dnsext-multi-qtypes-06) ever get supported.\r\nI have a hunch it also makes it more likely for the A/AAAA and ESNI records to be in sync for DNS providers that offer ALIAS \"virtual\" records.\r\n\r\n> I would also argue that providing customers of CDN the ability to opt-in to ESNI is important, especially during the early stages. Otherwise, CDNs cannot starting ESNI for any domains until all their customers permit the use ESNI.\r\n\r\nI think this should be possible with either approach.\r\nIn the non-prefixed case, the CDN can offer a dedicated CNAME target that has both the A/AAAA records of the ESNI enabled TLS servers and the ESNI records to use with them. If the customer doesn't want ESNI enabled, they can use the non-ESNI CNAME target. Or for CDN providers that offer a CNAME target personalized to the customer, this could be handled by a configuration at the CDN provider level.\r\nIn the prefixed case, it's of course a matter of the customer adding an _esni CNAME record pointing to the CDN's ESNI record.",
          "createdAt": "2018-09-25T18:21:44Z",
          "updatedAt": "2018-09-25T18:21:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T00:55:10Z",
          "updatedAt": "2019-03-06T00:55:10Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7b2c2f8b8ff9656a713b1449a50efb9ee8ca60bc",
      "headRepository": null,
      "headRefName": "rrtype-bis",
      "headRefOid": "e9f39739d5c24e739c777842b01c880b698dc31c",
      "mergeCommit": null
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNTAwODMy",
      "title": "add a iana instruction for _esni",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/76",
      "state": "MERGED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #75 ",
      "createdAt": "2018-07-15T14:28:55Z",
      "updatedAt": "2018-07-15T14:36:02Z",
      "closedAt": "2018-07-15T14:36:02Z",
      "mergedAt": "2018-07-15T14:36:02Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e72b0512cc779f2273f72a794af18a36598d19a2",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "attrleaf",
      "headRefOid": "d13c5c843b00248df342308beb897b3e8f494a3c",
      "mergeCommit": {
        "oid": "9b8f4362a7f7bed7507a5c6932fbb1be7b4989cf"
      }
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNTA3NTMy",
      "title": "Clarify that ServerNameList does not include extension wrapper.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/77",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-15T17:38:43Z",
      "updatedAt": "2018-07-16T20:32:47Z",
      "closedAt": "2018-07-16T20:32:47Z",
      "mergedAt": "2018-07-16T20:32:47Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3NTg1MDc3",
          "commit": {
            "abbreviatedOid": "5312695"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM.",
          "createdAt": "2018-07-16T20:31:59Z",
          "updatedAt": "2018-07-16T20:31:59Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9b8f4362a7f7bed7507a5c6932fbb1be7b4989cf",
      "headRepository": null,
      "headRefName": "caw/clarify-encoding",
      "headRefOid": "53126950df6185be5c37a63da80172188ae2f446",
      "mergeCommit": {
        "oid": "49af7eb82f46c3fcc58f485d5abd7bcdbb65b5b2"
      }
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNzEyMDk5",
      "title": "Add versioning",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/78",
      "state": "CLOSED",
      "author": "tmshort",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Add versioning to the ESNI domain entry and the extension.\r\nAs this ID evolves, it will permit interoperability.\r\n\r\nAlso fix a minor type",
      "createdAt": "2018-07-16T18:01:16Z",
      "updatedAt": "2018-09-17T18:23:12Z",
      "closedAt": "2018-09-17T18:23:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW #63 discusses this.",
          "createdAt": "2018-07-17T05:27:42Z",
          "updatedAt": "2018-07-17T05:27:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was addressed in #90. Please re-open if that's not the case.",
          "createdAt": "2018-09-17T18:23:12Z",
          "updatedAt": "2018-09-17T18:23:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3ODUwOTE4",
          "commit": {
            "abbreviatedOid": "96c94d5"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T14:18:24Z",
          "updatedAt": "2018-07-17T14:18:24Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "~~I am not sure if we need to explicitly include the version of ESNIKeys in the TLS extension.\r\n\r\nCurrent approach assumes that the server looks for the corresponding ESNIKeys by checking the value of `record_digests`. That will lead you to the ESNIKeys that contains a version. Having another version seems unnecessary complication to me.~~\r\n\r\nSorry for the noise, I now notice that the proposal is to offer a list of versions using ESNIKeys and let the client select one in the TLS extension. Please let me retract my comment.",
              "createdAt": "2018-07-17T14:18:24Z",
              "updatedAt": "2018-07-17T14:21:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3ODUzMjI1",
          "commit": {
            "abbreviatedOid": "96c94d5"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T14:23:05Z",
          "updatedAt": "2018-07-17T14:23:06Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "A server can support multiple versions of the draft; it is a list in the DNS record, and the record digest would be the same for all versions in that list.\r\n\r\nYou are correct that the record_digest would be updated when a server adds support for a new version of ESNI, but that doesn't indicate *which* version of ESNI the client is trying to use.",
              "createdAt": "2018-07-17T14:23:05Z",
              "updatedAt": "2018-07-17T14:23:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3ODU1NjY4",
          "commit": {
            "abbreviatedOid": "96c94d5"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T14:27:55Z",
          "updatedAt": "2018-07-17T14:27:55Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Example:\r\n```\r\nRecord digest for version list [0xFF01] = 0x01234567\r\nRecord digest for version list [0xFF01, 0xFF02] = 0x89ABCDEF\r\n```\r\nUsing record digest 0x89ABCDEF won't indicate which version is in use; 0xFF02 can't be assumed since 0xFF01 is still listed as being supported",
              "createdAt": "2018-07-17T14:27:55Z",
              "updatedAt": "2018-07-17T14:27:56Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9b8f4362a7f7bed7507a5c6932fbb1be7b4989cf",
      "headRepository": "tmshort/draft-rescorla-tls-esni",
      "headRefName": "master-tmshort-rev",
      "headRefOid": "96c94d5ef23e68c7a7c89a2089429a3da1349a59",
      "mergeCommit": null
    },
    {
      "number": 85,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2MjYxNzg0",
      "title": "Mix the server record (digest), client key share, and client random into the ESNI key derivation.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/85",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #81.",
      "createdAt": "2018-08-05T22:40:32Z",
      "updatedAt": "2018-08-20T15:04:24Z",
      "closedAt": "2018-08-20T15:04:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This is an improvement, but I thought we had agreed to move towards the separate keys/AAD approach?",
          "createdAt": "2018-08-07T13:14:03Z",
          "updatedAt": "2018-08-07T13:14:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We did, but that\u2019s slightly orthogonal. I\u2019ll do that in a separate PR. ",
          "createdAt": "2018-08-07T13:44:44Z",
          "updatedAt": "2018-08-07T13:44:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzOTc3OTI4",
          "commit": {
            "abbreviatedOid": "134b15c"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM :+1:",
          "createdAt": "2018-08-07T12:50:59Z",
          "updatedAt": "2018-08-07T12:50:59Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "49af7eb82f46c3fcc58f485d5abd7bcdbb65b5b2",
      "headRepository": null,
      "headRefName": "caw/contributive",
      "headRefOid": "134b15c87b5c4cde7f52500138662f64757e2e9c",
      "mergeCommit": null
    },
    {
      "number": 86,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2Mjg2NzA2",
      "title": "Add advice about query strategy.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/86",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-06T04:33:00Z",
      "updatedAt": "2018-08-14T15:38:27Z",
      "closedAt": "2018-08-14T15:38:27Z",
      "mergedAt": "2018-08-14T15:38:27Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus please have a look!",
          "createdAt": "2018-08-07T16:02:29Z",
          "updatedAt": "2018-08-07T16:02:29Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "49af7eb82f46c3fcc58f485d5abd7bcdbb65b5b2",
      "headRepository": null,
      "headRefName": "caw/query",
      "headRefOid": "3152be598fbfcef510b89589963389c1cedbe0a3",
      "mergeCommit": {
        "oid": "3d52a23db2ddda6279c1915b5224789ccf5d951a"
      }
    },
    {
      "number": 87,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2NzU4OTYw",
      "title": "Separate the key shares used by the TLS handshake and ESNI to avoid downgrade",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/87",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-07T16:37:46Z",
      "updatedAt": "2018-08-20T15:13:09Z",
      "closedAt": "2018-08-20T15:13:09Z",
      "mergedAt": "2018-08-20T15:13:09Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ2MTI2MDk4",
          "commit": {
            "abbreviatedOid": "3a96c00"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-08-14T15:39:55Z",
          "updatedAt": "2018-08-14T15:43:40Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I would call this |key_share|",
              "createdAt": "2018-08-14T15:39:55Z",
              "updatedAt": "2018-08-20T15:12:23Z"
            },
            {
              "originalPosition": 65,
              "body": "I think this is not quite what we want.\r\n\r\nI think rather the hash should be:\r\n\r\n```Hash(record_digest || EncryptedSNI.entry || ClientHello.Random)```\r\n\r\nAnd then you want to have the AAD include ClientHello.key_shares.\r\n",
              "createdAt": "2018-08-14T15:43:17Z",
              "updatedAt": "2018-08-20T15:12:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ2MTMyMDYy",
          "commit": {
            "abbreviatedOid": "3a96c00"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-14T15:52:20Z",
          "updatedAt": "2018-08-14T15:52:20Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "That works for me.",
              "createdAt": "2018-08-14T15:52:20Z",
              "updatedAt": "2018-08-20T15:12:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ2MTM0Mzg1",
          "commit": {
            "abbreviatedOid": "3a96c00"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-14T15:57:33Z",
          "updatedAt": "2018-08-14T15:57:33Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "EncryptedSNI.entry is already mixed in by virtue of being used to derive the KDF input secret. Putting ClientHello.KeyShareClientHello here or in the AAD has the same affect on malleability.",
              "createdAt": "2018-08-14T15:57:33Z",
              "updatedAt": "2018-08-20T15:12:23Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "49af7eb82f46c3fcc58f485d5abd7bcdbb65b5b2",
      "headRepository": null,
      "headRefName": "caw/separate-keyshares",
      "headRefOid": "0a47e5b16eecb49678ec83fcbf3e3dd3e321f32f",
      "mergeCommit": {
        "oid": "6995fd93a9a69363581b531318115543c9afb6bf"
      }
    },
    {
      "number": 89,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEzMDMxNDY3",
      "title": "Caw/echo nonce",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/89",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a proposal to address the misrouting and key share replacement attacks identified by Ekr, Karthik, and Benjamin. Please help me improve it!",
      "createdAt": "2018-09-04T16:15:15Z",
      "updatedAt": "2018-09-10T17:03:44Z",
      "closedAt": "2018-09-10T17:03:44Z",
      "mergedAt": "2018-09-10T17:03:44Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjUwMDAx",
          "commit": {
            "abbreviatedOid": "b5e60f8"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Some minor nits.",
          "createdAt": "2018-09-04T20:55:53Z",
          "updatedAt": "2018-09-04T21:04:08Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This should be `encrypted_server_name(0xffce)` to match IANA considerations.",
              "createdAt": "2018-09-04T20:55:53Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 23,
              "body": "Should update the \"TLS 1.3\" column in IANA considerations for the extension to be \"CH, EE\".",
              "createdAt": "2018-09-04T20:58:01Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 86,
              "body": "s/if/it/",
              "createdAt": "2018-09-04T21:01:55Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjc2Mjcx",
          "commit": {
            "abbreviatedOid": "b5e60f8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-04T22:23:11Z",
          "updatedAt": "2018-09-04T22:23:12Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Fixed!",
              "createdAt": "2018-09-04T22:23:12Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjc2MzEz",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-04T22:23:22Z",
          "updatedAt": "2018-09-04T22:23:22Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Fixed!\r\n",
              "createdAt": "2018-09-04T22:23:22Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjc2MzMx",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-04T22:23:25Z",
          "updatedAt": "2018-09-04T22:23:26Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Fixed!\r\n",
              "createdAt": "2018-09-04T22:23:26Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzI5MTU4",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-10T11:24:03Z",
          "updatedAt": "2018-09-10T11:26:05Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Because the nonce is constant-length, I wouldn't include it in the padding calculation",
              "createdAt": "2018-09-10T11:24:03Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 68,
              "body": "I think either of these is correct.",
              "createdAt": "2018-09-10T11:24:14Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 90,
              "body": "This could be read as saying that the client must abort if it doesn't check. Maybe \"provided by the server, and otherwise abort the connection ....\"",
              "createdAt": "2018-09-10T11:24:41Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 118,
              "body": "This text seems OBE. This mechanism won't work unless the backend has nonce, so you might as well give it SNI too.",
              "createdAt": "2018-09-10T11:25:48Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 180,
              "body": "This text also seems OBE.",
              "createdAt": "2018-09-10T11:25:59Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzQ2MTM1",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:20:32Z",
          "updatedAt": "2018-09-10T12:20:32Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Works for me. ",
              "createdAt": "2018-09-10T12:20:32Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzQ2NjY0",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:21:59Z",
          "updatedAt": "2018-09-10T12:40:40Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Yep, good suggestion. Fixed.",
              "createdAt": "2018-09-10T12:21:59Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 118,
              "body": "Good catch. I'll make this point to the preceding section.",
              "createdAt": "2018-09-10T12:29:58Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzUzMzU1",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:41:46Z",
          "updatedAt": "2018-09-10T12:41:46Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "The article seems necessary. Or at least it reads odd without it.",
              "createdAt": "2018-09-10T12:41:46Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzUzNDQy",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:42:00Z",
          "updatedAt": "2018-09-10T12:42:00Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "Yep, addressed, and also removed the hand-wavy bit.",
              "createdAt": "2018-09-10T12:42:00Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6995fd93a9a69363581b531318115543c9afb6bf",
      "headRepository": null,
      "headRefName": "caw/echo-nonce",
      "headRefOid": "6eb942287b53da31eece48bab25d1a3ac945e284",
      "mergeCommit": {
        "oid": "e3cd3f544b0018a4b42621a9a12b62ff92d81cdf"
      }
    },
    {
      "number": 90,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE1NzcwMTU5",
      "title": "Version number",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/90",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-15T13:50:23Z",
      "updatedAt": "2018-09-16T20:03:23Z",
      "closedAt": "2018-09-16T20:03:23Z",
      "mergedAt": "2018-09-16T20:03:23Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NzE1ODEw",
          "commit": {
            "abbreviatedOid": "f83f937"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good \u2014 two minor comments.",
          "createdAt": "2018-09-15T14:54:47Z",
          "updatedAt": "2018-09-15T14:56:32Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I\u2019d replace \u201cmultiple TXT records\u201d with \u201cmultiple ESNIKeys structures.\u201d",
              "createdAt": "2018-09-15T14:54:47Z",
              "updatedAt": "2018-09-16T19:39:43Z"
            },
            {
              "originalPosition": 29,
              "body": "This should be fine, as clients tell servers which one via the digest. If a client-facing server can\u2019t handle any ESNI for a version it has published then that seems to be a configuration error, no? ",
              "createdAt": "2018-09-15T14:56:11Z",
              "updatedAt": "2018-09-16T19:39:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NzU2MDQ3",
          "commit": {
            "abbreviatedOid": "792ec78"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-16T19:46:38Z",
          "updatedAt": "2018-09-16T19:46:38Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1e7bf63593a342fd15ee065450686ed9b99a8d7f",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "version_number",
      "headRefOid": "792ec78c70cb3f8d8c26d6c07b3f507f14ead029",
      "mergeCommit": {
        "oid": "a5c6ac1843f5cc251c32723f2686b3d8066aa0fa"
      }
    },
    {
      "number": 91,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE1ODQxMTc1",
      "title": "Reorder the extension in a more logical way to make padding easier.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/91",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-16T19:37:54Z",
      "updatedAt": "2018-09-16T22:10:06Z",
      "closedAt": "2018-09-16T22:10:06Z",
      "mergedAt": "2018-09-16T22:10:06Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NzU2NTIx",
          "commit": {
            "abbreviatedOid": "e844c86"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-16T20:05:23Z",
          "updatedAt": "2018-09-16T20:07:55Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "This should be ClientESNIInner.",
              "createdAt": "2018-09-16T20:05:23Z",
              "updatedAt": "2018-09-16T22:03:17Z"
            },
            {
              "originalPosition": 23,
              "body": "If you're renaming this, I'd rename the client one, too. (ClientEncryptedSNI)",
              "createdAt": "2018-09-16T20:07:19Z",
              "updatedAt": "2018-09-16T22:03:17Z"
            },
            {
              "originalPosition": 28,
              "body": "Missing ClientESNIInner prefix to .nonce.",
              "createdAt": "2018-09-16T20:07:48Z",
              "updatedAt": "2018-09-16T22:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NzU2ODA1",
          "commit": {
            "abbreviatedOid": "1ee113b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-16T20:15:26Z",
          "updatedAt": "2018-09-16T20:17:01Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Capital Client",
              "createdAt": "2018-09-16T20:15:26Z",
              "updatedAt": "2018-09-16T22:03:17Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a5c6ac1843f5cc251c32723f2686b3d8066aa0fa",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "reorder_psnl",
      "headRefOid": "a35fbb358e8a13fe9097a3b6f284c0c11625b14e",
      "mergeCommit": {
        "oid": "71105a168d81a7bb11e37d18fe147f27ab395f72"
      }
    },
    {
      "number": 92,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2MDM4NTQ1",
      "title": "Clarify",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/92",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-17T16:17:48Z",
      "updatedAt": "2018-09-17T16:37:24Z",
      "closedAt": "2018-09-17T16:37:24Z",
      "mergedAt": "2018-09-17T16:37:24Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2MDE0NTcz",
          "commit": {
            "abbreviatedOid": "4f9b8f0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-17T16:37:13Z",
          "updatedAt": "2018-09-17T16:37:13Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d1caee56da2f49ea38f9c064d26049aaf8d2418e",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "clarify_key_share",
      "headRefOid": "4f9b8f06329aba4952ddab94a58146f24cafab30",
      "mergeCommit": {
        "oid": "1dd0d218b8a12dcbf695338b4880bd677e440b76"
      }
    },
    {
      "number": 93,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2MzMwMjY3",
      "title": "Clarify what encrypted_sni is",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/93",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-18T14:32:14Z",
      "updatedAt": "2018-09-18T14:33:17Z",
      "closedAt": "2018-09-18T14:33:17Z",
      "mergedAt": "2018-09-18T14:33:17Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1dd0d218b8a12dcbf695338b4880bd677e440b76",
      "headRepository": null,
      "headRefName": "encrypted_sni",
      "headRefOid": "34522b7c617dd80873818f49cf506bd93aa69447",
      "mergeCommit": {
        "oid": "682928e63c897ff5fba83693625a70073b0978c1"
      }
    },
    {
      "number": 94,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2MzMzNTMz",
      "title": "Calculate checksum over the whole structure",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/94",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-18T14:41:02Z",
      "updatedAt": "2018-09-18T15:38:01Z",
      "closedAt": "2018-09-18T15:38:00Z",
      "mergedAt": "2018-09-18T15:38:00Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr @kazuho what do you think?",
          "createdAt": "2018-09-18T14:42:35Z",
          "updatedAt": "2018-09-18T14:42:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2NDA0Njgz",
          "commit": {
            "abbreviatedOid": "dfe0948"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-18T14:42:17Z",
          "updatedAt": "2018-09-18T14:42:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2NDExMTc1",
          "commit": {
            "abbreviatedOid": "dfe0948"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": ":+1:",
          "createdAt": "2018-09-18T14:54:21Z",
          "updatedAt": "2018-09-18T14:54:21Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "682928e63c897ff5fba83693625a70073b0978c1",
      "headRepository": null,
      "headRefName": "checksum",
      "headRefOid": "dfe09481d3eead6825da3e7a79e8640a1693ef1f",
      "mergeCommit": {
        "oid": "67fb40a4bee107293a3f835673a76015f9acd79f"
      }
    },
    {
      "number": 95,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2MzM0OTM2",
      "title": "Clarify clarification",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/95",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-18T14:44:55Z",
      "updatedAt": "2018-09-18T15:38:44Z",
      "closedAt": "2018-09-18T15:38:44Z",
      "mergedAt": "2018-09-18T15:38:44Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2NDA4MzE5",
          "commit": {
            "abbreviatedOid": "6e2e80c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-18T14:49:04Z",
          "updatedAt": "2018-09-18T14:49:04Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "682928e63c897ff5fba83693625a70073b0978c1",
      "headRepository": null,
      "headRefName": "clarify_clarify",
      "headRefOid": "6e2e80c32f0e2bdec5db3649ac0e7a7474f1583a",
      "mergeCommit": {
        "oid": "bff4cee30cec7e8a4ba0397dbc58dc93201fa8cd"
      }
    },
    {
      "number": 96,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2Mzg0MjMx",
      "title": "Update version to 0xff01 for draft",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/96",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-18T17:23:14Z",
      "updatedAt": "2018-09-18T17:24:22Z",
      "closedAt": "2018-09-18T17:24:22Z",
      "mergedAt": "2018-09-18T17:24:21Z",
      "mergedBy": "kazuho",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bff4cee30cec7e8a4ba0397dbc58dc93201fa8cd",
      "headRepository": null,
      "headRefName": "version",
      "headRefOid": "5442864faab95a1bc79922f25748886d3b4adfff",
      "mergeCommit": {
        "oid": "7b2c2f8b8ff9656a713b1449a50efb9ee8ca60bc"
      }
    },
    {
      "number": 98,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE3NjY4MDAx",
      "title": "Clarify what the server must do with server_name",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/98",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-24T14:04:24Z",
      "updatedAt": "2018-09-24T14:32:05Z",
      "closedAt": "2018-09-24T14:32:05Z",
      "mergedAt": "2018-09-24T14:32:05Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed offline.",
          "createdAt": "2018-09-24T14:31:57Z",
          "updatedAt": "2018-09-24T14:31:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTE5OTUw",
          "commit": {
            "abbreviatedOid": "a5cfc3a"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-24T14:07:06Z",
          "updatedAt": "2018-09-24T14:07:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Maybe instead MUST NOT send the \"server_name\" extension to the client.",
              "createdAt": "2018-09-24T14:07:06Z",
              "updatedAt": "2018-09-24T14:16:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTIwNDUx",
          "commit": {
            "abbreviatedOid": "a5cfc3a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-24T14:08:06Z",
          "updatedAt": "2018-09-24T14:08:13Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I'm not sure this is consistent with the text above, which reads: \"The client MAY either omit the \"server_name\" extension or provide  an innocuous dummy one (this is required for technical conformance with {{!RFC7540}}; Section 9.2.).\" It seems we can only prohibit servers from echoing server_name iff the client is also prohibited from sending it in conjunction with ESNI.",
              "createdAt": "2018-09-24T14:08:07Z",
              "updatedAt": "2018-09-24T14:16:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTI0MDA1",
          "commit": {
            "abbreviatedOid": "a5cfc3a"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-24T14:15:33Z",
          "updatedAt": "2018-09-24T14:15:33Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The server doesn't have to send server_name even if the client does. That is, irrespective of ESNI, the server can decide to ignore the server_name from the client and not send server_name at all. So, the client can send a dummy server_name, but the server is not going to use it (if nothing else, because it's \"dummy\"), so it shouldn't send server_name.",
              "createdAt": "2018-09-24T14:15:33Z",
              "updatedAt": "2018-09-24T14:16:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTI0NzYy",
          "commit": {
            "abbreviatedOid": "3655e4c"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-24T14:17:02Z",
          "updatedAt": "2018-09-24T14:17:02Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Ok, fixed.",
              "createdAt": "2018-09-24T14:17:02Z",
              "updatedAt": "2018-09-24T14:17:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTI3NTMz",
          "commit": {
            "abbreviatedOid": "3655e4c"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-24T14:22:41Z",
          "updatedAt": "2018-09-24T14:22:41Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I don't think that's true. There's no hard requirement that the server echo SNI. It only must echo it if it used \"the information contained in the extension to guide  its selection of an appropriate certificate to return to the client, and/or other aspects of security policy\".  But a server that ignores SNI doesn't have to do anything. Concretely, NSS only echoes SNI if there is an SNI callback installed.\r\n\r\n",
              "createdAt": "2018-09-24T14:22:41Z",
              "updatedAt": "2018-09-24T14:22:41Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7b2c2f8b8ff9656a713b1449a50efb9ee8ca60bc",
      "headRepository": null,
      "headRefName": "sni_ack",
      "headRefOid": "3655e4c9d64c470790fb7dc432fe304a126e9a1c",
      "mergeCommit": {
        "oid": "b74e843a0e6db2553e216df6508296e5a3cc5292"
      }
    },
    {
      "number": 100,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIzNzc3Njcz",
      "title": "clarify for alt-svc that we lookup txt/esni from origin name. closes #61",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/100",
      "state": "MERGED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-17T22:54:58Z",
      "updatedAt": "2018-10-21T20:52:40Z",
      "closedAt": "2018-10-21T20:52:40Z",
      "mergedAt": "2018-10-21T20:52:40Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1OTE1MDk2",
          "commit": {
            "abbreviatedOid": "88cc4bb"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-18T03:41:53Z",
          "updatedAt": "2018-10-18T03:41:53Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b74e843a0e6db2553e216df6508296e5a3cc5292",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-61",
      "headRefOid": "88cc4bb5ef44c88d878d76bc33e87d169ac01563",
      "mergeCommit": {
        "oid": "35ab3043ffb8e4a266407e1750c9aa8c932cb440"
      }
    },
    {
      "number": 101,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NTY1NzU2",
      "title": "Abort the handshake if the server does not negotiate TLS 1.3.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/101",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-21T20:10:13Z",
      "updatedAt": "2018-10-21T20:22:00Z",
      "closedAt": "2018-10-21T20:17:50Z",
      "mergedAt": "2018-10-21T20:17:50Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5MTAz",
          "commit": {
            "abbreviatedOid": "342e1eb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-21T20:17:46Z",
          "updatedAt": "2018-10-21T20:17:46Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b74e843a0e6db2553e216df6508296e5a3cc5292",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "reject_tls12",
      "headRefOid": "342e1ebc6e9675741d96d6c532047c24645e6188",
      "mergeCommit": {
        "oid": "3fcacbeb8f4feb5f80ea89460a4252c3bea12b72"
      }
    },
    {
      "number": 102,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NTY2NDY2",
      "title": "Clarify that if you can't negotiate ESNI, you should act as if none o\u2026",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/102",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026f the ESNI Keys values were present",
      "createdAt": "2018-10-21T20:22:16Z",
      "updatedAt": "2018-10-21T22:29:24Z",
      "closedAt": "2018-10-21T22:29:24Z",
      "mergedAt": "2018-10-21T22:29:24Z",
      "mergedBy": "kazuho",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5Mjgy",
          "commit": {
            "abbreviatedOid": "4b7f49a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-21T20:23:03Z",
          "updatedAt": "2018-10-21T20:24:41Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "s/non/no",
              "createdAt": "2018-10-21T20:23:03Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            },
            {
              "originalPosition": 33,
              "body": "By \"another value\" I assume you mean a ESNIKeys structure obtained through some other means?",
              "createdAt": "2018-10-21T20:23:50Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            },
            {
              "originalPosition": 5,
              "body": "Should we make this a MUST? This is different from the group/ciphersuite mismatch issue. ",
              "createdAt": "2018-10-21T20:24:39Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5Mzg3",
          "commit": {
            "abbreviatedOid": "4b7f49a"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-21T20:26:15Z",
          "updatedAt": "2018-10-21T20:26:15Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "No I mean say you give me two ESNIKeys structures, one of which advertises only 25519 and one of which advertises only P-256, and for some reason I only like P-256, but I try the 25519 one first\r\n",
              "createdAt": "2018-10-21T20:26:15Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5NDI5",
          "commit": {
            "abbreviatedOid": "5a90f15"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-21T20:27:06Z",
          "updatedAt": "2018-10-21T20:27:06Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Gotcha -- we should clarify that, I think. How about: \"If the client is unable to select an appropriate group or suite it SHOULD ignore that ESNIKeys value and MAY attempt to use another value provided by the server. (Recall that servers may provide multiple ESNIKeys in response to a ESNI TXT query.)\"?",
              "createdAt": "2018-10-21T20:27:06Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5NTI2",
          "commit": {
            "abbreviatedOid": "376b34f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-21T20:29:56Z",
          "updatedAt": "2018-10-21T20:29:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2ODAzMDA0",
          "commit": {
            "abbreviatedOid": "376b34f"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-21T22:08:40Z",
          "updatedAt": "2018-10-21T22:09:42Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\"should\" should be in upper case?",
              "createdAt": "2018-10-21T22:08:40Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            },
            {
              "originalPosition": 31,
              "body": "\"servers may provide\": lower-case \"may\". Change it to \"might\"?",
              "createdAt": "2018-10-21T22:09:24Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2ODAzMDk2",
          "commit": {
            "abbreviatedOid": "376b34f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-21T22:11:36Z",
          "updatedAt": "2018-10-21T22:11:36Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-10-21T22:11:36Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3fcacbeb8f4feb5f80ea89460a4252c3bea12b72",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "clarify_soft_fail",
      "headRefOid": "c114216ff895005b361cce73c6b37d89b805216c",
      "mergeCommit": {
        "oid": "bf4f394215d04aafefaf8870285d27866abad217"
      }
    },
    {
      "number": 104,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI1NTQ4OTI0",
      "title": "Restrict keys to address records in the same canonical name.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/104",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #35 \r\n\r\nthis would be a bit cleaner if we got rid of the prefix.. which I think we ought to do as well but is separable.",
      "createdAt": "2018-10-24T20:59:49Z",
      "updatedAt": "2019-06-27T20:23:36Z",
      "closedAt": "2019-06-27T20:23:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "mostly obe #136 and #137",
          "createdAt": "2019-06-27T20:23:36Z",
          "updatedAt": "2019-06-27T20:23:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY4MTI0ODky",
          "commit": {
            "abbreviatedOid": "ca03799"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This has the effect of creating a different resolution method for _esni, which I'm a little concerned about.",
          "createdAt": "2018-10-24T21:19:36Z",
          "updatedAt": "2018-10-24T21:28:03Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\ninformation to implement ESNI. The server is identified through DNS\r\n```",
              "createdAt": "2018-10-24T21:19:36Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 19,
              "body": "does \"address records\" mean A or AAAA?",
              "createdAt": "2018-10-24T21:20:05Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 60,
              "body": "How does it know that the TXT record is the one that needs updating?  It is presented with a mismatch, with TTLs.  Should we instead recommend requesting both, or does that invite problems?\r\n\r\nDoes it start over from _esni.example.com, or does this allow for an end-run on the CNAME resolution process from the prefixed domain.  That is, if www.example.com is CNAMEd through various intermediaries to providerA.example, does the client just construct _esni.providerA.example, or does it have to go back to _esni.example.com?  I get the problem - if this is load balanced, how do we ensure that this ends up routing the same way?  So why would you not just start with _esni.providerA.example then?",
              "createdAt": "2018-10-24T21:26:46Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nthe client MUST confirm that the unprefixed (i.e., lacking the\r\n```",
              "createdAt": "2018-10-24T21:26:53Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n     -> \"... KEY FOR B ...\"\r\n```",
              "createdAt": "2018-10-24T21:27:16Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n        -> \"... KEY FOR A ...\"\r\n```",
              "createdAt": "2018-10-24T21:27:24Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY4MTMzNzE5",
          "commit": {
            "abbreviatedOid": "5804df7"
          },
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T21:44:39Z",
          "updatedAt": "2018-10-24T21:44:39Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "yes.. I don't mind saying a/aaaa I was trying to leave room for other ways of specifying the address. srv? new A* type?",
              "createdAt": "2018-10-24T21:44:39Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY4MTM1MDQ4",
          "commit": {
            "abbreviatedOid": "5804df7"
          },
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T21:48:32Z",
          "updatedAt": "2018-10-24T21:48:32Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "My thought here is that the TXT record is the new kid on the block, so deference ought to be given to the A for backwards compatibility.\r\n\r\nif you're trying to loadbalance, you may well be doing so to add/delete traffic from certain regions (and people have been known to choose providers due to their strengths in particular regions) so capturing the traffic in service of using a valid key seems sub-optimal.. \r\n\r\nI wouldn't be surprised to see keys with bigger TTLs than the A's - creating an easy scenario for the mismatch to occur.. and we wouldn't want the routing of traffic impacted by that imo.",
              "createdAt": "2018-10-24T21:48:32Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bf4f394215d04aafefaf8870285d27866abad217",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-35",
      "headRefOid": "ec9f09c84750d1c03bb3ed4cbae44e3f63553f6d",
      "mergeCommit": null
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI2MDExNDcx",
      "title": "Fix two typos in text",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/106",
      "state": "MERGED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There were two minor typos. This PR fixes them.\n\nWhile I was at it, I ran `aspell` over it, most seemed fine.",
      "createdAt": "2018-10-26T08:12:35Z",
      "updatedAt": "2018-10-27T04:53:30Z",
      "closedAt": "2018-10-27T04:53:30Z",
      "mergedAt": "2018-10-27T04:53:30Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5MDQzNzI0",
          "commit": {
            "abbreviatedOid": "c37cfa3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-27T04:53:24Z",
          "updatedAt": "2018-10-27T04:53:24Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bf4f394215d04aafefaf8870285d27866abad217",
      "headRepository": "thomwiggers/draft-ietf-tls-esni",
      "headRefName": "typos",
      "headRefOid": "c37cfa3ffbfe908d7b7b9f70ab601e77e66ebf6c",
      "mergeCommit": {
        "oid": "7bd60fcc09c1569b0f87cdebd6534fbaad922161"
      }
    },
    {
      "number": 108,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI2MTQyMjE3",
      "title": "remove the _esni prefix ",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/108",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "allow synchronization of both Key-Info and A/AAAA via the traditional single CNAME.\r\n\r\nfixes #105 amd #79\r\nessentially requires #73 otherwise there is namespace conflict\r\n\r\ntext conflicts a bit with #104 so if both were landed the slower one would need an update",
      "createdAt": "2018-10-26T15:40:14Z",
      "updatedAt": "2019-03-06T00:55:12Z",
      "closedAt": "2019-03-06T00:55:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this is premised on #109",
          "createdAt": "2018-10-27T19:39:38Z",
          "updatedAt": "2018-10-27T19:39:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T00:55:12Z",
          "updatedAt": "2019-03-06T00:55:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5MDYzMDQ3",
          "commit": {
            "abbreviatedOid": "283701c"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-27T17:12:53Z",
          "updatedAt": "2018-10-27T17:12:53Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It seems like you would need to have some prefix or something here to distinguish from other TXT records (this is of course what the _esni prefix was supposed to do). Do we need a published convention",
              "createdAt": "2018-10-27T17:12:53Z",
              "updatedAt": "2018-10-27T17:12:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1Nzg4NzMx",
          "commit": {
            "abbreviatedOid": "283701c"
          },
          "author": "paulehoffman",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-23T23:07:09Z",
          "updatedAt": "2019-01-23T23:07:09Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "1) It is a terrible idea to have non-prefixed TXT records\r\n2) This has been overtaken by events with the likely proposal of a new RRtype",
              "createdAt": "2019-01-23T23:07:09Z",
              "updatedAt": "2019-01-23T23:07:09Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bf4f394215d04aafefaf8870285d27866abad217",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-105",
      "headRefOid": "283701cf86728c5c6550f9f459a2b1af9dd62ec4",
      "mergeCommit": null
    },
    {
      "number": 111,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI2MTU1MDkw",
      "title": "break RRData into ESNIKeys and ESNIInclude",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/111",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #110",
      "createdAt": "2018-10-26T16:24:46Z",
      "updatedAt": "2020-02-23T13:49:21Z",
      "closedAt": "2020-02-23T13:49:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as this is OBE.",
          "createdAt": "2020-02-23T13:49:21Z",
          "updatedAt": "2020-02-23T13:49:21Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bf4f394215d04aafefaf8870285d27866abad217",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-esniptr",
      "headRefOid": "22614a4eb459b6634081ee82f54dad7acf07d17e",
      "mergeCommit": null
    },
    {
      "number": 112,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI2MzE4NDE4",
      "title": "Convenient integration branch for DNS issues",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/112",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "includes multicdn #35 \r\nesni rrtype #109 #74\r\nremove _esni prefix #105 #79 \r\nesniinclude #110 ",
      "createdAt": "2018-10-27T19:38:08Z",
      "updatedAt": "2019-06-27T20:21:29Z",
      "closedAt": "2019-06-27T20:21:28Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "obe. but #110 should live on.",
          "createdAt": "2019-06-27T20:21:28Z",
          "updatedAt": "2019-06-27T20:21:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5MDkwMzIy",
          "commit": {
            "abbreviatedOid": "a189ef2"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-28T12:31:41Z",
          "updatedAt": "2018-10-28T12:40:32Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "This is kind of unclear, but I think the point is that the server operator provides the domain operator with the A record which the domain operator then installs in the DNS, but this works badly for ESNI Keys because then the server operator cannot frequently rotate the ENSI Keys.",
              "createdAt": "2018-10-28T12:31:42Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            },
            {
              "originalPosition": 114,
              "body": "I would say A/AAAA.",
              "createdAt": "2018-10-28T12:34:31Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            },
            {
              "originalPosition": 149,
              "body": "You should indicate that this is a failure example.",
              "createdAt": "2018-10-28T12:35:37Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            },
            {
              "originalPosition": 137,
              "body": "This text is unclear at least to me.",
              "createdAt": "2018-10-28T12:37:11Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            },
            {
              "originalPosition": 159,
              "body": "This algorithm seems over-complicated. I.e., there's no reason to query for the ESNI at a different CNAME than A/AAAA. Also, it seems like there is an open case here.\r\n\r\n````\r\nQuery for ESNI and A/AAAA records.\r\nIf A/AAAA is CNAME=X {\r\n   Query for ESNI at X\r\n} else {\r\n   if ESNI is not CNAME {\r\n     success\r\n} else {\r\n     ???\r\n}\r\n```\r\n\r\n",
              "createdAt": "2018-10-28T12:40:25Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7bd60fcc09c1569b0f87cdebd6534fbaad922161",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-cnamefriendly",
      "headRefOid": "a189ef2cd5ee26595154a08b4db389e440385e3d",
      "mergeCommit": null
    },
    {
      "number": 114,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4MTAwMTk1",
      "title": "Uniform capitalization of \"Split Mode\" and \"Shared Mode\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/114",
      "state": "MERGED",
      "author": "Eudi4H",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-11-03T05:10:27Z",
      "updatedAt": "2018-11-03T06:47:39Z",
      "closedAt": "2018-11-03T06:47:39Z",
      "mergedAt": "2018-11-03T06:47:39Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7bd60fcc09c1569b0f87cdebd6534fbaad922161",
      "headRepository": "Eudi4H/draft-ietf-tls-esni",
      "headRefName": "caps",
      "headRefOid": "935470acc000c03b6fb8f66e534cf3b45db5fe15",
      "mergeCommit": {
        "oid": "752c4ff43cc1aaf163a5955539e74029c46b3522"
      }
    },
    {
      "number": 115,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4MTE3Nzc0",
      "title": "Update README.md",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/115",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-11-03T13:13:34Z",
      "updatedAt": "2018-11-03T21:57:32Z",
      "closedAt": "2018-11-03T21:57:31Z",
      "mergedAt": "2018-11-03T21:57:31Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "752c4ff43cc1aaf163a5955539e74029c46b3522",
      "headRepository": "martinthomson/draft-ietf-tls-esni",
      "headRefName": "README",
      "headRefOid": "ce6c4c93e15eb632d274df06590c2a508b3a65db",
      "mergeCommit": {
        "oid": "65e0cc3b795cfd87aedbc347901fd97083177bca"
      }
    },
    {
      "number": 120,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM2MDE5MzEz",
      "title": "Fix typo.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/120",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-12-05T01:42:45Z",
      "updatedAt": "2018-12-05T15:30:23Z",
      "closedAt": "2018-12-05T15:30:16Z",
      "mergedAt": "2018-12-05T15:30:16Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2018-12-05T15:30:22Z",
          "updatedAt": "2018-12-05T15:30:22Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1ed8d7d02c3b0884ac20c93f891d2745ab0f9d49",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "fix-typo",
      "headRefOid": "39f17a269fef9807a01ee48aef3ce1748218453f",
      "mergeCommit": {
        "oid": "3013b3c0c7bd93202cd4ca847380de64352ec79f"
      }
    },
    {
      "number": 122,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM4NDk2NzYw",
      "title": "Add CertificateVerify to padding recommendation",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/122",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "FIRST_TIME_CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Also takes out the \"longest length\" part of the SHOULD since (as Viktor pointed out) a server might not always know that and it can change due to CA or other PKI changes that might lead to errors in some scenarios. (E.g. CA adds new extension thereby causing a cert to be longer than what the TLS server thinks is longest.)",
      "createdAt": "2018-12-13T19:00:33Z",
      "updatedAt": "2020-04-27T21:59:32Z",
      "closedAt": "2020-04-27T21:59:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't agree with the longest length removal.\r\n\r\nPlease two separate PRs, one of which contains the non-controversial piece (CertificateVerify) and one with the longest length change.",
          "createdAt": "2018-12-13T19:05:26Z",
          "updatedAt": "2018-12-13T19:05:26Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "Not sure I know how to split a PR into two:-) Can take a look at it tomorrow but given one of 'em adds two words it'll likely be as easy to just treat this like an issue and make that change before a new rev and treat this one as arguing that longest-length is perhaps better not being a SHOULD.",
          "createdAt": "2018-12-13T19:15:21Z",
          "updatedAt": "2018-12-13T19:16:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd what\u2019s the plan here?",
          "createdAt": "2019-06-19T16:52:59Z",
          "updatedAt": "2019-06-19T16:52:59Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "I guess the non-controversial change ought be made. That's just s/SHOULD pad the Certificate message/SHOULD pad the Certificate and CertificateVerify messages/. I can make a PR for that or you can just do it and kill this one. \r\nFor the non non-controversial change, I can send mail the WG list I guess:-)",
          "createdAt": "2019-06-19T20:47:22Z",
          "updatedAt": "2019-06-19T20:47:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd this is likely overcome by events in #207. Would you mind updating based on that text, or closing this PR?",
          "createdAt": "2020-03-08T00:34:44Z",
          "updatedAt": "2020-03-08T00:34:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as overcome by #209!",
          "createdAt": "2020-04-27T21:59:31Z",
          "updatedAt": "2020-04-27T21:59:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4NTE3NDEy",
          "commit": {
            "abbreviatedOid": "db1ee1b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-12-31T17:02:46Z",
          "updatedAt": "2018-12-31T17:05:43Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "typo \"ahnshake\"",
              "createdAt": "2018-12-31T17:02:46Z",
              "updatedAt": "2019-01-01T14:30:00Z"
            },
            {
              "originalPosition": 12,
              "body": "s/on the network/on the wire?",
              "createdAt": "2018-12-31T17:02:56Z",
              "updatedAt": "2019-01-01T14:30:00Z"
            },
            {
              "originalPosition": 12,
              "body": "Perhaps add a sentence that says the padded length equals the size of the largest possible Certificate and CertificateVerify messages covered by the same ESNI key?",
              "createdAt": "2018-12-31T17:05:37Z",
              "updatedAt": "2019-01-01T14:30:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4NTU4NzIz",
          "commit": {
            "abbreviatedOid": "db1ee1b"
          },
          "author": "sftcd",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-01T14:27:21Z",
          "updatedAt": "2019-01-01T14:27:22Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'm not sure that's a good plan TBH. It seems there are openssl deployments where there's a bunch of certs in a database somewhere so a) it could be slow to find that information afresh and b) that max size is liable to change as CAs renew certs, e.g. if the PKI renewal results in more/bigger extensions being put in certs. So while the max size could work in many places perhaps a simpler approach is better as the example to give.\r\n\r\nFWIW, my current code just pads the Certificate to a multiple of 2000 bytes and the CertificateVerify to a multiple of 500 bytes, those could maybe be smaller, but it seems to work ok.",
              "createdAt": "2019-01-01T14:27:22Z",
              "updatedAt": "2019-01-01T14:30:00Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3013b3c0c7bd93202cd4ca847380de64352ec79f",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "c57591570967befd4bcaebc05833694048618179",
      "mergeCommit": null
    },
    {
      "number": 124,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM5MzE1MjU3",
      "title": "Improve ESNI robustness",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/124",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(WG email coming shortly.)\r\n\r\nCloses #82.\r\n\r\nESNI has different compatibility characteristics than most TLS\r\nextensions. It involves client state, and encrypting the SNI makes the\r\nClientHello unusable for servers that do not have the key or do not\r\nimplement ESNI. This breaks common rollout and rollback strategies and\r\nplaces strong requirements on DNS/server consistency. This makes\r\ndeploying ESNI risky for servers.\r\n\r\nThis change aims to reduce these deployment risks. ESNI is much more\r\nuseful if widely deployed. Moreover, if ESNI is unreliable due to\r\ncomplex requirements on the server, clients will be disincentivized to\r\nimplement it. The DNS/server consistency requirements also\r\ndisincentivize rotating keys (section 7.2.5).\r\n\r\nThis change introduces the notion of a \"public name\" which allows the\r\nclient to receive authenticated signals from the server that the\r\nESNIKeys are out of sync, so clients can safely repair key mismatches.\r\nIt also aligns with existing server behavior before ESNI, so partial\r\nrollouts and rollbacks can also be handled.\r\n\r\nThe fix for the latter also handles MITM scenarios, replacing the\r\nexisting client recommendation:\r\n\r\n>   A Web client client can securely detect case (2) because it will\r\n>   result in a connection which has an invalid identity (most likely)\r\n>   but which is signed by a certificate which does not chain to a\r\n>   publicly known trust anchor.  The client can detect this case and\r\n>   disable ESNI while in that network configuration.\r\n>\r\n>   https://tools.ietf.org/html/draft-ietf-tls-esni-02#section-6.2\r\n\r\nThe public name notion fixes a bug in that text: an attacker could\r\ndisable ESNI on all servers, given the existence of *any* such server.",
      "createdAt": "2018-12-17T23:16:08Z",
      "updatedAt": "2019-02-26T21:14:13Z",
      "closedAt": "2019-02-26T21:14:13Z",
      "mergedAt": "2019-02-26T21:14:12Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Hopefully I didn't miss anything.\r\n\r\nAnd, as I write this, I realize I forgot to deal with Stephen's comment on the thread about the middlebox stuff! It's quite late here, so I will reword that tomorrow morning.",
          "createdAt": "2019-02-15T01:25:39Z",
          "updatedAt": "2019-02-15T01:25:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2NzIzOTEy",
          "commit": {
            "abbreviatedOid": "641ded1"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-19T19:59:52Z",
          "updatedAt": "2018-12-19T19:59:53Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "I had real trouble with this text because it doesn't say which direction the resumption applies to.  In general, when talking about resumption, you need to be very clear about whether you are talking about accepting a PSK for *this* session, or whether you are talking about maybe later establishing a resumed connection.  In this case, it's possible that both apply, so I had trouble with this.",
              "createdAt": "2018-12-19T19:59:52Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4NTE4MTA3",
          "commit": {
            "abbreviatedOid": "641ded1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall, this looks good to me. Thanks for the PR! @ekr, @kazuho, can you please give it a review?",
          "createdAt": "2018-12-31T17:10:25Z",
          "updatedAt": "2018-12-31T17:33:21Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "s/public key/public key and metadata?",
              "createdAt": "2018-12-31T17:10:25Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 165,
              "body": "s/encrypted SNI/ENSI",
              "createdAt": "2018-12-31T17:17:21Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 240,
              "body": "My take is that the text refers to the former, not the latter, though it is a little unclear. ",
              "createdAt": "2018-12-31T17:27:45Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 263,
              "body": "s/by servers/by (other) servers?",
              "createdAt": "2018-12-31T17:28:54Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MzE5ODMw",
          "commit": {
            "abbreviatedOid": "641ded1"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T23:56:28Z",
          "updatedAt": "2019-01-29T23:35:20Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Done.",
              "createdAt": "2019-01-28T23:56:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 165,
              "body": "Done.",
              "createdAt": "2019-01-28T23:56:56Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 240,
              "body": "It's just the former, yeah.\r\n\r\nThe intent of the text is to prevent resumption/SNI mismatches. With ESNI and, in particular, this ESNI to SNI fallback, a client offering {(non-GREASE) ESNI, SNI, PSK} now needs to consider all four possible responses:\r\n\r\n1. Server ACK'd ESNI and did full handshake\r\n2. Server ACK'd ESNI and resumed PSK\r\n3. Server ignored ESNI (thus used SNI) and did full handshake\r\n4. Server ignored ESNI (thus used SNI) and resumed PSK\r\n\r\nIn particular, whether the server ACKs or ignores ESNI determines which name the server believes it is acting on behalf of. So we want that to be consistent with the identity the client has associated with the PSK, if any. (1) and (3) are vacuously self-consistent, so that's easy.\r\n\r\nAs for (2) and (4), presumably the client would not be offering a session good for the public name because it's actually trying to connect to the ESNI name. Thus we want to reject (4) and allow (2). (If we allow (4), then the verify-public-name section needs to decide whether this weird scenario counts as authenticating the replacement ESNI keys and that's weird.) That means the server needs to know not the produce (4).\r\n\r\nNow, we could that, if a server ignores the ESNI extension due to key mismatch, it should also ignore the PSK extension. That works, except:\r\n* We want to be robust to server rollbacks and partial deployments. Such a server won't know to ignore the PSK extension.\r\n* Being able to send GREASE extensions is nice and a GREASE client wants to accept (4) since all the names are actually identical all around.\r\n\r\nOur thinking was to instead take leaf out of EMS's (and new TLS versions in general) book and partitions the connection/resumption space by whether ESNI was used. We remember a bit in the session state for whether ESNI was used when establishing it. We then say that a client offering ESNI [for real, not GREASE] can only offer ESNI-ful sessions, and a server can only accept ESNI-ful sessions in ESNI-ful handshakes.\r\n\r\nThis gives all the properties we want:\r\n* Clients offering ESNI will only offer an ESNI-ful session, which is invalid for the server to accept if it declined ESNI. Thus it can reject (4) above.\r\n* This can work with ESNI-oblivious servers on rollback. The server makes the ESNI bit in the session state unparseable by older versions of itself. This is the same sort of thing the server would already have had to do for EMS, or TLS 1.3.\r\n* Clients offering GREASE ESNI will almost always offer ESNI-less sessions (last time I talked to the server, it presumably didn't have ESNI either). The server will decline ESNI (since it's random noise), which means it's allowed to resume ESNI-less sessions.\r\n\r\nThere isn't an immediate need to constrain ESNI-less sessions, so I didn't in this version of the text. Though maybe a full partition is cleaner? It also occurs to me I have no idea what to do about external PSKs. We could say that if you really want ESNI + external PSK (strange considering that ESNI is usually about picking a certificate anyway...), you have to associate an ESNI bit with the EPSK?? EPSKs are a really underspecified use case that I don't know how to evaluate it.\r\n\r\nAnyway, I've tweaked the text slightly and left the above questions as-is for now. Is the new text clearer? / Thoughts on the above?",
              "createdAt": "2019-01-29T23:14:36Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 263,
              "body": "Rephrased. (See longer comment on resumption above.)",
              "createdAt": "2019-01-29T23:34:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDU4NjUy",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-13T21:33:35Z",
          "updatedAt": "2019-02-13T21:33:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDU4NzIy",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-13T21:33:45Z",
          "updatedAt": "2019-02-13T21:33:46Z",
          "comments": [
            {
              "originalPosition": 263,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-02-13T21:33:45Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDU4OTYy",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-13T21:34:17Z",
          "updatedAt": "2019-02-13T21:34:18Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "I think the proposed text clears things up. @martinthomson @ekr I'll take this PR to the list to see if there are any objections. ",
              "createdAt": "2019-02-13T21:34:18Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDYyNjIz",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-13T21:42:49Z",
          "updatedAt": "2019-02-13T21:42:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDk1MjE5",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think that this still needs a little work.\r\n\r\nI've not been following closely, so consider this a review from fresh eyes.",
          "createdAt": "2019-02-13T23:03:42Z",
          "updatedAt": "2019-02-13T23:35:02Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Maybe avoid making untestable claims:\r\n```suggestion\r\n```\r\n\r\nMore so this set of changes makes the design the very opposite of straightforward.",
              "createdAt": "2019-02-13T23:03:42Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 78,
              "body": "We will evolve the format over time.  That means that this field is going to contain a specific version.  If that version is not supported, this design offers no means of recovery.  The client knows for certain that ESNI is supported, but there is no remedy.\r\n\r\nCan this include a list of key structures?  That would be consistent with the DNS, which can have multiple alternative records with different versions.",
              "createdAt": "2019-02-13T23:07:37Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 104,
              "body": "I'm confused.  This is the first mention of a PSK.  This needs more context.\r\n\r\nThe point here is that if you get a PSK from a previous connection (presumably an external PSK can have its own rules), then you need to ensure that you mark that PSK as being ESNI or not.  If it is ESNI, then you never resume from an ESNI PSK without ESNI and you never resume from a non-ESNI PSK if you are adding ESNI.\r\n\r\nWithout context, this is impossible to decipher.  I'm not even sure if I agree with the latter part of the requirement, so explaining why is probably necessary.\r\n\r\nAlso, this sentence is a run-on, so I can't really parse it.",
              "createdAt": "2019-02-13T23:10:13Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 146,
              "body": "Can public_name be empty?  If it is, can I omit SNI?",
              "createdAt": "2019-02-13T23:14:16Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 186,
              "body": "The SHOULD here is either out of scope, or under-specified.\r\n\r\nI think that the intent here is to say that if ESNI is not negotiated for any reason, but the connection is completed successfully with \"public_name\", then you aren't being attacked, but ESNI has simply been disabled.  A necessary condition for the \"SHOULD retry\" here is that the connection is successfully established with \"public_name\", but that connection is not explicit here.\r\n\r\nYou also want to add a condition here that if the server provides retry keys that the client cannot use, then it can regard ESNI as securely disabled.\r\n\r\nIf that is not the intent, then this stipulates policy: it's OK to fall back when you have a clear signal that ESNI is enabled, but the server doesn't do ESNI.  That's not a policy I would support.",
              "createdAt": "2019-02-13T23:20:40Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 209,
              "body": "This is right, but in the degenerate case it leads to three connections: one to fail resumption, one to get ESNI keys (because presumably you don't want the server that resumes to be able to supply retry keys - something that needs to be said more clearly in previous sections), and finally one to connect with the updated keys to the real host.  That isn't ideal, but I don't see how that could be shortened at all.",
              "createdAt": "2019-02-13T23:23:34Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 258,
              "body": "Why not prohibit resumption and PSK entirely for the case where the keys need replacing?  This only works for certificate-based server authentication anyway.  Are you really trying to salvage this for servers that authenticate with a PSK?",
              "createdAt": "2019-02-13T23:27:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 273,
              "body": "```suggestion\r\nfield set to the decrypted PaddedServerNameList.nonce value from the client\r\n\"encrypted_server_name\" extension.\r\n```",
              "createdAt": "2019-02-13T23:29:12Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 304,
              "body": "Remove \"in DNS\"",
              "createdAt": "2019-02-13T23:30:21Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 309,
              "body": "s/DNS/systems that advertise ESNI keys/",
              "createdAt": "2019-02-13T23:30:51Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 315,
              "body": "s/DNS/advertisements/",
              "createdAt": "2019-02-13T23:31:07Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 317,
              "body": "```suggestion\r\ndeployment. This may also occur if a server loses its ESNI keys, or if a deployment\r\n```",
              "createdAt": "2019-02-13T23:31:37Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 330,
              "body": "s/DNS/advertised",
              "createdAt": "2019-02-13T23:31:59Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 336,
              "body": "Again, you need to separate retries that provide usable keys and ones that don't.",
              "createdAt": "2019-02-13T23:32:36Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 374,
              "body": "As much as I like and agree with this sentiment, the last sentence can go.",
              "createdAt": "2019-02-13T23:33:22Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 383,
              "body": "Editorial: avoid possessive for inanimate objects or abstract concepts.",
              "createdAt": "2019-02-13T23:34:29Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDAzMDUz",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-14T22:25:20Z",
          "updatedAt": "2019-02-14T22:25:20Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Should probably be clear about who can do this tracking (a network observer), since the server has other ways to track specific clients.",
              "createdAt": "2019-02-14T22:25:20Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDIyNTM2",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-14T23:25:35Z",
          "updatedAt": "2019-02-14T23:34:23Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "\"parameters not based on certificates\" should probably be worded differently.  I assume the intent is that you can't negotiate a PSK-only mode and need to pick something where the server authenticates with a certificate?",
              "createdAt": "2019-02-14T23:25:35Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 220,
              "body": "I'm not sure that this usage of \"origin\" is consistent with the other usages in this document; do we want to be talking about the \"private domain\" instead?",
              "createdAt": "2019-02-14T23:26:15Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzODg1MzEx",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for the thorough review! I've uploaded a new revision. Hopefully I didn't miss anything.",
          "createdAt": "2019-02-14T17:55:27Z",
          "updatedAt": "2019-02-15T01:24:35Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "It is a list of key structures. See retry\\_key*s* and the `<1..2^16-1>`.  Also below where it says:\r\n\r\n> *If one of the values used a version known*\r\n>  *to the client*, the client SHOULD retry the handshake with a new transport\r\n>  connection, using that value to encrypt the SNI.",
              "createdAt": "2019-02-14T17:55:27Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 209,
              "body": "Only two. It is not intended for the `illegal_parameter` to be a retry signal. The rules around resumption mean this scenario will never occur for a well-behaved client and server. (Client only offers ESNI sessions, which the server will not accept.)\r\n\r\nThis is precisely why there's the business about resumption that you commented on here:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/124#discussion_r243055936",
              "createdAt": "2019-02-14T18:03:24Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 258,
              "body": "See here:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/124#discussion_r243055936\r\n\r\nIf we simply prohibit resumption, non-ESNI clients can't send GREASE. It also doesn't fully solve the problem because an ESNI-ignorant server won't know to do this, hence the text below about issuing tickets. Since we're doing that anyway, this is free and buys us GREASE.",
              "createdAt": "2019-02-14T18:05:10Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 146,
              "body": "In the current text, no it cannot be empty. See `<1..2^16-1>` above.",
              "createdAt": "2019-02-14T21:50:43Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 13,
              "body": "The untestable claim is existing text. I merely downgraded it a notch from \"quite straightforward\" to \"straightforward\". Happy to downgrade it further and remove that line altogether. Done.",
              "createdAt": "2019-02-14T22:00:12Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 104,
              "body": "By \"the latter part of the requirement\", do you mean \"you never resume from a non-ESNI PSK if you are adding ESNI\"? The document does not prescribe that. See my response to your thread here:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/124#discussion_r243055936\r\n\r\nI've reworded this a bit.",
              "createdAt": "2019-02-14T22:07:51Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 186,
              "body": "> I think that the intent here is to say that if ESNI is not negotiated for any reason, but the connection is completed successfully with \"public_name\", then you aren't being attacked, but ESNI has simply been disabled. A necessary condition for the \"SHOULD retry\" here is that the connection is successfully established with \"public_name\", but that connection is not explicit here.\r\n\r\nIt says to follow the steps in {{verify-public-name}}, which includes abort rules, but I guess it's not obvious which aborts are caught and which aren't. Rephrased a bit.\r\n\r\n> You also want to add a condition here that if the server provides retry keys that the client cannot use, then it can regard ESNI as securely disabled.\r\n\r\nAlready there:\r\n\r\n>  The client then processes the \"retry_keys\" field from the server's\r\n>  \"encrypted_server_name\" extension. If one of the values used a version known\r\n>  to the client, the client SHOULD retry the handshake with a new transport\r\n>  connection, using that value to encrypt the SNI. If no value is applicable,\r\n>  the client SHOULD retry with ESNI disabled.\r\n\r\nBut I like the framing of \"securely disabled\". It's not normative but explains what's going on. What do you think of the new text.\r\n\r\n> If that is not the intent, then this stipulates policy: it's OK to fall back when you have a clear signal that ESNI is enabled, but the server doesn't do ESNI. That's not a policy I would support.\r\n\r\nTo clarify, when you say \"clear\", do you mean \"cleartext and not secured\" or do you mean \"unambiguous, including verifying the public name\"? I agree with you if the former, but the latter is kind of the point. :-)",
              "createdAt": "2019-02-15T00:24:40Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 304,
              "body": "Done.",
              "createdAt": "2019-02-15T00:58:47Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 309,
              "body": "Done.",
              "createdAt": "2019-02-15T00:59:16Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 315,
              "body": "Done",
              "createdAt": "2019-02-15T01:01:08Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 330,
              "body": "Done.",
              "createdAt": "2019-02-15T01:01:21Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 336,
              "body": "I don't quite follow. What's the concern here? This one says \"If the public name does not verify\". Note this is also existing text, but slightly adapted. From before this PR:\r\n\r\n> If the servers does not\r\n> require SNI, it will complete the handshake with its default\r\n> certificate. Most likely, this will cause a certificate name\t\r\n> mismatch and thus handshake failure. Clients SHOULD NOT fall\t\r\n> back to cleartext SNI, because that allows a network attacker\t\r\n> to disclose the SNI. They MAY attempt to use another server\t\r\n> from the DNS results, if one is provided.",
              "createdAt": "2019-02-15T01:02:54Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 374,
              "body": "This too is an existing sentence from before this PR. :-P Happy to remove it though. Removed.",
              "createdAt": "2019-02-15T01:03:43Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 383,
              "body": "Done.",
              "createdAt": "2019-02-15T01:04:17Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 173,
              "body": "Well, it's a little fussy. If we were worried about a malicious server colluding with a network observer, that malicious server could already just broadcast whatever tracking information it has to the clear somewhere else. :-P\r\n\r\nBut if the client is already not bothering with session resumption or scoping it for tracking reasons, a single-use retry means they don't *also* need to scope this. Honestly, saying that you must scope this at least as tightly as session resumption probably is sufficient? Though there's also thinking through accidental pinning if retry keys manage to change the public name.\r\n\r\nI added \"pinning concerns\" to the text but I dunno what other text is needed given the above. Thoughts?\r\n\r\n(Neither of these are obviously fatal. There is a corner of the design space around in-band provisioning of ESNI keys, if we're okay caching these and can stomach the complexity of an in-band retry. I know some folks on the list were interested in that. But I think it makes sense to focus on the simplest version of the idea first.)",
              "createdAt": "2019-02-15T01:11:40Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 208,
              "body": "Yeah. Otherwise we don't have a public name to check. :-) How about \"did not negotiate certificate-based authentication\"?",
              "createdAt": "2019-02-15T01:12:37Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 220,
              "body": "The word \"origin\" shows up elsewhere in the doc a bunch, but I only see \"private domain\" once. Though \"origin\" usually says \"origin server\" or \"private origin\" and not plain \"origin\". I think \"private origin\" fits better here than \"origin server\". What do you think?",
              "createdAt": "2019-02-15T01:15:12Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDUyMzg4",
          "commit": {
            "abbreviatedOid": "7ce9b5c"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T01:45:42Z",
          "updatedAt": "2019-02-15T01:45:42Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "I agree that \"private origin\" is better than \"origin server\"",
              "createdAt": "2019-02-15T01:45:42Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDUyNjYx",
          "commit": {
            "abbreviatedOid": "7ce9b5c"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T01:47:04Z",
          "updatedAt": "2019-02-15T01:47:05Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "I think we need to stay positive, \"negotiated a session that did not use a certificate for authentication\" -- otherwise we get confused if we have any sort of PSK+cert or other joint authentication scheme.",
              "createdAt": "2019-02-15T01:47:05Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDU5MjQz",
          "commit": {
            "abbreviatedOid": "7ce9b5c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I see that I missed something about disabling.  I think that this could be a lot more explicit about the three primary cases that I talk about in the comments below.",
          "createdAt": "2019-02-15T02:24:06Z",
          "updatedAt": "2019-02-15T02:37:02Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Prose in support of this would be useful.",
              "createdAt": "2019-02-15T02:24:07Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 336,
              "body": "This is a matter of not leaning on other text properly.  There are three cases and this says two:\r\n\r\nThe public name can not verify, which is clearly a terminal error condition.  \r\nThe server can indicate that ESNI is disabled, which triggers a retry without ESNI.\r\nThe server can provide (usable) alternative keys, which triggers a retry with those keys.  If those keys are no good, that's a terminal condition.\r\n\r\nI think that you can simplify this to say that unless ESNI is disabled as a result of successfully establishing a connection to the public name, then a client MUST NOT attempt to connect without ESNI.  (not SHOULD NOT)\r\n\r\nYes, this is probably not your fault.  I'll let others sort that bit out.",
              "createdAt": "2019-02-15T02:25:13Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 78,
              "body": "I see.  It's not very clear.  I'll make some suggestions.",
              "createdAt": "2019-02-15T02:27:22Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\n: One or more ESNIKeys structures containing the keys that the client should use on\r\n```",
              "createdAt": "2019-02-15T02:27:38Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 147,
              "body": "\"If none of the values provided in \"retry_keys\" contains a version supported by the client, the client MUST consider the server to have disabled ESNI.\"\r\n\r\nWhat the client does in response to an authenticated signal that disables ESNI is a matter for client policy, so the SHOULD is inappropriate.\r\n\r\nBTW, this would argue for having a third option: esni_disabled.\r\n\r\n",
              "createdAt": "2019-02-15T02:30:01Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MzE2Mzg4",
          "commit": {
            "abbreviatedOid": "7ce9b5c"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks mostly good, but added some nits and clarification questions.",
          "createdAt": "2019-02-15T16:09:35Z",
          "updatedAt": "2019-02-15T16:44:30Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "This is used by the _client_?",
              "createdAt": "2019-02-15T16:09:35Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 105,
              "body": "I think this sentence is missing something...",
              "createdAt": "2019-02-15T16:12:20Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 167,
              "body": "Nit: ...to _the_ calling application.",
              "createdAt": "2019-02-15T16:14:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 180,
              "body": "Does \"previously cached keys\" refer to the keys fetched from DNS?",
              "createdAt": "2019-02-15T16:28:18Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 203,
              "body": "I'm not sure I understand this. Where would the toggle go, in DNS? And having the toggle turned on would signal to the client that it must not retry the connection with ESNI disabled?",
              "createdAt": "2019-02-15T16:39:40Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDA1NjE3",
          "commit": {
            "abbreviatedOid": "21f8eab"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T19:35:27Z",
          "updatedAt": "2019-02-15T19:51:52Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Er, I was thinking it's used by the server in that it's the identity the server assumes, but yeah conversely the client verifies it. I've reworded this to not reference either side.",
              "createdAt": "2019-02-15T19:35:27Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 105,
              "body": "Oops! The mistake was s/which/negotiated/.",
              "createdAt": "2019-02-15T19:36:25Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 146,
              "body": "Added the word non-empty to the public_name description.",
              "createdAt": "2019-02-15T19:36:51Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 167,
              "body": "Done. Also removed \"as described below\". That could be read as \"as described below, here's how you avoid using the retry keys\", which is weird.",
              "createdAt": "2019-02-15T19:37:10Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 180,
              "body": "@martinthomson left a bunch of comments that suggested he didn't want the specification text to talk about DNS keys. Thus, to answer your question, yes but not necessarily so we can't say that. :-P\r\n\r\nOn the list, someone thought a version of this text implied that you're supposed to keep track of all the retry keys and make sure they never repeat. (Honestly, I think that reading was tenuous to say the least.) So I've tried to avoid it saying MUST NOT use the old keys.\r\n\r\nI've now switched it to \"previously-advertised\" which matches the verb used elsewhere. If you all still don't like it, please give me an alternative! :-)",
              "createdAt": "2019-02-15T19:45:15Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 203,
              "body": "Some extension on the ESNIKeys yeah. This is a TODO, not spec text.",
              "createdAt": "2019-02-15T19:46:15Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 336,
              "body": "Adopted your text with the MUST NOT.",
              "createdAt": "2019-02-15T19:48:17Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDkxNzQx",
          "commit": {
            "abbreviatedOid": "0ec053c"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T00:42:46Z",
          "updatedAt": "2019-02-16T00:42:46Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "Oops. Missed this one somehow. (GitHub's UI is... not the best).\r\n\r\n> \"If none of the values provided in \"retry_keys\" contains a version supported by the client, the client MUST consider the server to have disabled ESNI.\"\r\n\r\nI tweaked the wording a bit based on the first part. It seemed better to adjust the surrounding text too. Re the second part, I'm not sure what \"[MUST consider](https://tools.ietf.org/html/rfc6919#section-2)\" would mean as a normative requirement...\r\n\r\n> What the client does in response to an authenticated signal that disables ESNI is a matter for client policy, so the SHOULD is inappropriate.\r\n\r\nThe text around unechoed extensions also uses SHOULD. It's true that there isn't a single \"hook point\" for client policy around the disabling bit. It sounds like you might prefer a more \"abstracted\" text where something first outputs \"secure disable\", or \"secure replace\" and then there's policy on that.\r\n\r\nI haven't done that yet, in part because it's late on a Friday, but also I think we're well into wordsmithing weeds now. :-) I don't know what the right document organization would be for that. Also it's getting pretty long. Thoughts?\r\n\r\n> BTW, this would argue for having a third option: esni_disabled.\r\n\r\nIt's already there by way of not echoing the extension. I think a separate explicit version would only make sense if there are clients who:\r\n* are happy with `esni_retry_requested`\r\n* would be happy with `esni_disabled`\r\n* are *not* happy with the unechoed signal.\r\n\r\nThat preference is not entirely implausible because not echoing the extension is an implicit signal repurposing existing server behavior. However, that's also kind of the point, since it allows safe rollback. If server deployments cannot rely on that, the cost of deploying ESNI goes up dramatically.\r\n\r\nESNI, even more so than most TLS improvements, really wants a wide deployment, so I think it's good for the document to have a strong opinion here.\r\n\r\n(Specialized clients and specialized servers, of course, would probably ignore disable signals, but they would ignore `esni_disabled` too, so that's more about the SHOULD. But it seems to me that's covered by \"there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course\".)",
              "createdAt": "2019-02-16T00:42:46Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDkxNzg0",
          "commit": {
            "abbreviatedOid": "0ec053c"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T00:43:01Z",
          "updatedAt": "2019-02-16T00:43:01Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "Er, hit comment too soon. Will upload the corresponding git commit shortly.",
              "createdAt": "2019-02-16T00:43:01Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDkyMDcw",
          "commit": {
            "abbreviatedOid": "aaccb84"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T00:45:12Z",
          "updatedAt": "2019-02-16T00:45:13Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "(Uploaded.)",
              "createdAt": "2019-02-16T00:45:13Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDk1NjM2",
          "commit": {
            "abbreviatedOid": "aaccb84"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T01:16:27Z",
          "updatedAt": "2019-02-16T01:16:28Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-02-16T01:16:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDk2MjQ3",
          "commit": {
            "abbreviatedOid": "aaccb84"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T01:22:51Z",
          "updatedAt": "2019-02-16T01:22:51Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "(Also missed this. I clearly don't know how to use GitHub...)\r\n\r\nDone.",
              "createdAt": "2019-02-16T01:22:51Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5e08e1439e3bbfd8ed022252679e76d0c90b4c88",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "robustness",
      "headRefOid": "7e67cd82ec8b0c9f2ef2455222031e23c3f2060f",
      "mergeCommit": {
        "oid": "f07d3806d52add7920a0f4087f93c85bede08581"
      }
    },
    {
      "number": 125,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM5MzE1NDA4",
      "title": "Allow clients to send GREASE ESNI extensions.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/125",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(WG email coming shortly.)\r\n\r\n~~NB: When reviewing, ignore the first commit. This PR and https://github.com/tlswg/draft-ietf-tls-esni/pull/124 were originally formulated together. I split them into two based on some feedback, but since they touch the same text, it was simplest to include https://github.com/tlswg/draft-ietf-tls-esni/pull/124 in this PR. If the WG wishes to go with one but not the other, the text and details can be adjusted accordingly.~~\r\n\r\n*Update: This has been rebased to master, now that #124 is merged.*\r\n\r\nThe new server behavior (\"Improve ESNI robustness\") means clients can send\r\nGREASE ESNI extensions without interop issues. Write some text recommending\r\nthis, better meeting the \"Do not stick out\" criteria.",
      "createdAt": "2018-12-17T23:16:54Z",
      "updatedAt": "2019-04-22T21:00:26Z",
      "closedAt": "2019-04-22T21:00:26Z",
      "mergedAt": "2019-04-22T21:00:26Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The GREASE section seems fine to me. (@davidben is there other new material in this PR?) @ekr, @kazuho, please have a look when possible.",
          "createdAt": "2018-12-31T17:36:25Z",
          "updatedAt": "2018-12-31T17:36:25Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @davidben is there other new material in this PR?\r\n\r\nIt's whatever's in the second commit, so mostly that section but also a bit elsewhere:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/125/commits/7401f55013f68ec47dad36b99977ad6aa881d9f1",
          "createdAt": "2019-01-28T23:55:34Z",
          "updatedAt": "2019-01-28T23:55:34Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I share the view that the GREASE section looks fine.",
          "createdAt": "2019-02-13T21:48:53Z",
          "updatedAt": "2019-02-13T21:48:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr Did you mean to leave the comments on https://github.com/tlswg/draft-ietf-tls-esni/pull/124? (Notably the text already has seen a number of revisions here. I haven't gone back to update this PR yet. This PR was meant to just be the second commit.)",
          "createdAt": "2019-02-25T23:00:32Z",
          "updatedAt": "2019-02-25T23:00:32Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Ugh. Having something which claims to be a merged PR is kind of an\nattractive nusiance, then, no? Perhaps you can apply the changes here?\n\nOn Mon, Feb 25, 2019 at 3:00 PM David Benjamin <notifications@github.com>\nwrote:\n\n> @ekr <https://github.com/ekr> Did you mean to leave the comments on #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124>? (Notably the\n> text already has seen a number of revisions here. I haven't gone back to\n> update this PR yet. This PR was meant to just be the second commit.)\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/125#issuecomment-467219457>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oTg3ZYafmOt5ubYAqvmNV9qDX1GUks5vRGsRgaJpZM4ZXTha>\n> .\n>\n",
          "createdAt": "2019-02-25T23:04:10Z",
          "updatedAt": "2019-02-25T23:04:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In my defense, I split them at your request and did include the following. ;-)\r\n\r\n> NB: When reviewing, ignore the first commit. This PR and #124 were originally formulated together. I split them into two based on some feedback, but since they touch the same text, it was simplest to include #124 in this PR. If the WG wishes to go with one but not the other, the text and details can be adjusted accordingly.\r\n\r\nBut, sure, I can rebase this one. I figured #124 was the bulk of the interesting bits (7401f55013f68ec47dad36b99977ad6aa881d9f1 is much smaller) so I figured we'd resolve #124 first and then I'd update this one at the end.",
          "createdAt": "2019-02-25T23:06:34Z",
          "updatedAt": "2019-02-25T23:06:34Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "On Mon, Feb 25, 2019 at 3:06 PM David Benjamin <notifications@github.com>\nwrote:\n\n> In my defense, I split them at your request and did include the following.\n> ;-)\n>\n> NB: When reviewing, ignore the first commit. This PR and #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124> were originally\n> formulated together. I split them into two based on some feedback, but\n> since they touch the same text, it was simplest to include #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124> in this PR. If\n> the WG wishes to go with one but not the other, the text and details can be\n> adjusted accordingly.\n>\n>\nSure, and I read that as \"this is an accurate reflection of my put for both\nof these\".\n\nBut, sure, I can rebase this one. I figured #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124> was the bulk of\n> the interesting bits (7401f55\n> <https://github.com/tlswg/draft-ietf-tls-esni/commit/7401f55013f68ec47dad36b99977ad6aa881d9f1>\n> is much smaller) so I figured we'd resolve #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124> first and then\n> I'd update this one at the end.\n>\n\nThanks.\n\n-Ekr\n\n\u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/125#issuecomment-467221253>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oYi28jBhWjeNTZw4DxJZNo2VxMC_ks5vRGx6gaJpZM4ZXTha>\n> .\n>\n",
          "createdAt": "2019-02-25T23:10:08Z",
          "updatedAt": "2019-02-25T23:10:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Sure, and I read that as \"this is an accurate reflection of my put for both of these\".\r\n\r\nWell, it was when I wrote that sentence. :-) Anyway, it's now been rebased and I've incorporated your comments as well.",
          "createdAt": "2019-03-02T05:17:02Z",
          "updatedAt": "2019-03-02T05:17:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDc1NzQ0",
          "commit": {
            "abbreviatedOid": "7401f55"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-13T22:13:06Z",
          "updatedAt": "2019-02-13T22:13:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDc2OTY1",
          "commit": {
            "abbreviatedOid": "7401f55"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-13T22:16:05Z",
          "updatedAt": "2019-02-13T22:16:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3Njc1OTQ5",
          "commit": {
            "abbreviatedOid": "7401f55"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-25T22:46:52Z",
          "updatedAt": "2019-02-25T22:57:21Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "What's the function of this alert as opposed to just closing the connection?",
              "createdAt": "2019-02-25T22:46:52Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 167,
              "body": "It's worth noting that this is only relevant for the earlier version case.",
              "createdAt": "2019-02-25T22:49:42Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 195,
              "body": "This seems like it ought to be in the client section.",
              "createdAt": "2019-02-25T22:51:59Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 201,
              "body": "IMPORTANT: It seems like with TLS 1.3 you could just abort the connection as soon as you get SFIN.",
              "createdAt": "2019-02-25T22:52:23Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 225,
              "body": "Should we instead use consistent hashing so that you had the same record_digest for each server.",
              "createdAt": "2019-02-25T22:53:16Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 240,
              "body": "\"offer to resume\"?",
              "createdAt": "2019-02-25T22:54:53Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 306,
              "body": "I'm not sure how iluminating this hint about how to implement is. I would remove it.",
              "createdAt": "2019-02-25T22:56:10Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 354,
              "body": "I'm not sure if it's \"most\". We expect CDN conflictst o be common.",
              "createdAt": "2019-02-25T22:56:50Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NjgzNjM4",
          "commit": {
            "abbreviatedOid": "7401f55"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-25T23:08:42Z",
          "updatedAt": "2019-03-02T05:15:05Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "Using a `close_notify` felt slightly off because the client is not cleanly closing the connection. It's rejecting it altogether. A more generic alert would work too, but this way a deployment can monitor that alert for whether it's getting out of sync a lot. (Merely being unable to decrypt ESNI isn't sufficient given GREASE.)\r\n\r\nI've adjusted the \"Note that an unrecognized ClientEncryptedSNI.record_digest [...]\" paragraph in the server behavior section to talk about this.",
              "createdAt": "2019-02-25T23:08:42Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 225,
              "body": "That's a tracking vector, no?",
              "createdAt": "2019-02-26T00:08:27Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 240,
              "body": "Done.",
              "createdAt": "2019-03-02T04:48:00Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 306,
              "body": "Removed.",
              "createdAt": "2019-03-02T04:48:16Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 354,
              "body": "Well, hopefully the CDN issue will be resolved by the current discussion. But fair enough. I've replaced the sentence with \"The retry mechanism repairs inconsistencies, provided the server is authoritative for the public name.\" which is more descriptive and avoids the subjective \"most\".",
              "createdAt": "2019-03-02T04:50:55Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 167,
              "body": "Done.",
              "createdAt": "2019-03-02T04:52:04Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 195,
              "body": "Well, this is a subsection of the client section. :-) Do you mean that it belongs in {{handle-server-response}}?\r\n\r\nThe nuisance is it's common to both the key mismatch and rollback cases. The purpose of this section was so the text didn't have to write it twice. (A subroutine if you will.) Though, now that you mention it, it is weird that the subroutine call is labelled \"verifying the certificate against ESNIKeys.public_name as described in {{verify-public-name}}\" which kinda presupposes a certificate story.\r\n\r\nWDYT about this: I've changed the description from \"verifying [the certificate] against the public name\" to \"authenticating for the public name\", which puts it at a bit larger scope than certificate verification.",
              "createdAt": "2019-03-02T05:07:50Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5MTg3MTY4",
          "commit": {
            "abbreviatedOid": "a06d119"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-22T18:38:43Z",
          "updatedAt": "2019-04-22T18:38:43Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8679dc49caa2131d9b660d9d30e4343aa7e994f9",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "grease",
      "headRefOid": "361feec6e4ad6dff2b40c27ba3cd09b491d667a6",
      "mergeCommit": {
        "oid": "4f3ce56fdb4caea12c6480ca3a9a5ec6bfd074c1"
      }
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2MDExNDky",
      "title": "Clarify that ESNI clients MUST NOT send cached_info cert extensions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/127",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-19T00:47:26Z",
      "updatedAt": "2019-02-13T21:32:03Z",
      "closedAt": "2019-02-13T21:32:03Z",
      "mergedAt": "2019-02-13T21:32:03Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addresses #126.",
          "createdAt": "2019-01-19T00:47:48Z",
          "updatedAt": "2019-01-19T00:47:48Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3013b3c0c7bd93202cd4ca847380de64352ec79f",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/cached_info",
      "headRefOid": "105aa9a14d351afbcca44961facc9dd302cad73a",
      "mergeCommit": {
        "oid": "5e08e1439e3bbfd8ed022252679e76d0c90b4c88"
      }
    },
    {
      "number": 128,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2MDEzMzYw",
      "title": "Specify HRR behavior.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/128",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-19T01:06:50Z",
      "updatedAt": "2019-03-08T01:07:59Z",
      "closedAt": "2019-03-08T00:53:16Z",
      "mergedAt": "2019-03-08T00:53:16Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho @ekr please have a look.",
          "createdAt": "2019-01-27T21:46:58Z",
          "updatedAt": "2019-01-27T21:46:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We also need to specify server-side HRR behavior, right? Specifically, the server MUST recheck the second ClientHello's ESNI extension before sending the server certificate, otherwise putting the key share into the AD field doesn't really mean anything. The attacker would be able to do a cut-and-paste thing.\r\n\r\n(We could also incorporate the nonce into key schedule, but that upsets the document's split mode use case.)",
          "createdAt": "2019-03-08T01:03:23Z",
          "updatedAt": "2019-03-08T01:03:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep! Thanks for bringing that up. I'll prepare text.",
          "createdAt": "2019-03-08T01:07:58Z",
          "updatedAt": "2019-03-08T01:07:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEwNDc1MTEx",
          "commit": {
            "abbreviatedOid": "a656687"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for the text. LGTM.",
          "createdAt": "2019-03-05T03:11:49Z",
          "updatedAt": "2019-03-05T03:11:49Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d9437fd5a4ed04dff1b5e48f97c586f242e80fb4",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hrr",
      "headRefOid": "39295c9b7b3a50ab39416021154f520f0374ed90",
      "mergeCommit": {
        "oid": "1b339186ec98274e93132de121e76ca55cce849d"
      }
    },
    {
      "number": 129,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2MDEzODA1",
      "title": "Swap version[4] and checksum, so the latter covers the entire struct.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/129",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #119, and we want the checksum to cover the entire struct by definition. ",
      "createdAt": "2019-01-19T01:12:21Z",
      "updatedAt": "2019-07-02T23:53:35Z",
      "closedAt": "2019-07-02T23:53:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks fine, though the downside of this seems to be that the checksum becomes part of the \"invariants\" and can't be changed/removed in future versions.",
          "createdAt": "2019-01-19T13:18:48Z",
          "updatedAt": "2019-01-19T13:18:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I assumed that was @kazuho\u2019s intent with the checksum. That is, if we see value in it for v1, it likely has value for all versions. ",
          "createdAt": "2019-01-19T15:01:29Z",
          "updatedAt": "2019-01-19T15:01:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho can you please comment?",
          "createdAt": "2019-01-27T21:46:41Z",
          "updatedAt": "2019-01-27T21:46:41Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I am fine with making it an invariant, considering the fact that it exists for detecting transmission errors (or human errors during copy-and-paste).\r\n\r\nWe do not need to worry about this becoming \"insecure,\" unlike cryptographic hash functions.",
          "createdAt": "2019-02-15T02:03:12Z",
          "updatedAt": "2019-02-15T02:03:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDU1NzEx",
          "commit": {
            "abbreviatedOid": "8842702"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-15T02:03:40Z",
          "updatedAt": "2019-02-15T02:03:40Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3013b3c0c7bd93202cd4ca847380de64352ec79f",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/version-swap",
      "headRefOid": "8842702305794a3c100a47e598605fb66691796c",
      "mergeCommit": null
    },
    {
      "number": 136,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU2NzQwNjQ0",
      "title": "Add support for \"combined records\" via an ESNIKeys extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/136",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change does the following:\r\n\r\n1. Add support for mandatory extensions, which are those that clients must process else reject the ESNIKeys record.\r\n2. Add a mandatory extension carrying a set of v4/v6 addresses, which is effectively the combined record mode. \r\n3. Add text describing how clients ought to resolve ESNI and A/AAAA records, and use the results to initiate TLS connections.",
      "createdAt": "2019-02-27T16:05:14Z",
      "updatedAt": "2019-03-10T02:04:22Z",
      "closedAt": "2019-03-10T02:04:22Z",
      "mergedAt": "2019-03-10T02:04:22Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is a substantial step in the right direction, but the fact that A/AAAA records are basically ignored makes me uneasy. \r\n\r\nThat's fair. However, it seems to be the price to get this sort of simplicity. Moreover, as an extension, it's not pressed upon all clients for all providers.\r\n\r\n> The fact that A/AAAA results are essentially fully embedded would imply that all logic involved in selectively returning those responses has to be duplicated for ESNIKeys, which is also sub-optimal.\r\n\r\nAlso true! I'm hoping that folks who are in the position and capable of vending these records can comment on this design's cost. ",
          "createdAt": "2019-02-28T00:39:09Z",
          "updatedAt": "2019-02-28T00:39:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that there was no serious objection to this change and that it works for at least one operator, I'm merging this PR. We can continue to iterate on #137 as needed in parallel.",
          "createdAt": "2019-03-10T02:04:19Z",
          "updatedAt": "2019-03-10T02:04:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODMwODE1",
          "commit": {
            "abbreviatedOid": "293f61c"
          },
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "This is a substantial step in the right direction, but the fact that A/AAAA records are basically ignored makes me uneasy.  The fact that A/AAAA results are essentially fully embedded would imply that all logic involved in selectively returning those responses has to be duplicated for ESNIKeys, which is also sub-optimal.",
          "createdAt": "2019-02-27T23:57:27Z",
          "updatedAt": "2019-02-28T00:27:52Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Other than being lower-case (\"must\" vs. \"MUST\"), this seems duplicative with the following paragraph.",
              "createdAt": "2019-02-27T23:57:27Z",
              "updatedAt": "2019-03-10T02:02:03Z"
            },
            {
              "originalPosition": 153,
              "body": "So in this design, ESNIKeys containing address(es) causes the A/AAAA results to be entirely ignored?",
              "createdAt": "2019-02-28T00:02:46Z",
              "updatedAt": "2019-03-10T02:02:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQwNTk5",
          "commit": {
            "abbreviatedOid": "293f61c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:36:37Z",
          "updatedAt": "2019-02-28T00:36:37Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "Yep!",
              "createdAt": "2019-02-28T00:36:37Z",
              "updatedAt": "2019-03-10T02:02:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQwNzU5",
          "commit": {
            "abbreviatedOid": "293f61c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:37:18Z",
          "updatedAt": "2019-02-28T00:37:19Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I opted for redundancy here. Happy to remove the subsequent text if people feel that's best.",
              "createdAt": "2019-02-28T00:37:18Z",
              "updatedAt": "2019-03-10T02:02:03Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a73367b8c58ba0a7f726743ad72ca4fd2b22574d",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/multi-cdn-simple",
      "headRefOid": "e9140ecba6c2fa17231c0d040e96e78f4cb44219",
      "mergeCommit": {
        "oid": "ba52fe66fb3a9a8d98dfd3d59b7322c454405f03"
      }
    },
    {
      "number": 137,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU2NzQyNTUx",
      "title": "Add support for \"host pointers\" via an ESNIKeys extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/137",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change does the following:\r\n\r\n1. Add support for mandatory extensions, which are those that clients must process else reject the ESNIKeys record.\r\n2. Add a mandatory extension carrying a \"host pointer,\" which is a (probably poorly named) struct containing a \"terminal CNAME\" for the domain, along with address masks, which may be partial or complete. Clients may use complete addresses if present, else they may use masks to resolve ESNI+A/AAAA mismatches. When these fail, the terminal CNAME may be used to get an address of some host that has the corresponding ESNI key.\r\n3. Add text describing how clients ought to resolve ESNI and A/AAAA records, and use the results to initiate TLS connections.\r\n\r\nThis is certainly more complex than #136.",
      "createdAt": "2019-02-27T16:10:00Z",
      "updatedAt": "2019-07-02T23:53:59Z",
      "closedAt": "2019-07-02T23:53:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@MikeBishop Thanks for the feedback! I'll comment that, as an extension, this is compatible with #136, assuming of course that both extensions are not present. We could move forward with both.",
          "createdAt": "2019-02-28T00:44:01Z",
          "updatedAt": "2019-02-28T00:44:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing with #136.",
          "createdAt": "2019-07-02T23:53:59Z",
          "updatedAt": "2019-07-02T23:53:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODM1MDAw",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Despite the additional complexity, I think this takes us to a better place than #136.  In particular, it enables the generation of ESNIKeys to be simpler (outlining a block of addresses and a recovery path) and leaves the complexity in the A/AAAA where it already exists.\r\n\r\nThere's some wording issues, but technically I like this direction.",
          "createdAt": "2019-02-28T00:13:16Z",
          "updatedAt": "2019-02-28T00:30:02Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "So the idea here is that, even if there's no overlap between the A/AAAA results and the ESNI record addresses, if the host_pointer chain includes (terminal might be too strong a statement) the indicated name, then you try it?  This is a bit of a leap of faith on two fronts:  First, that they have the appropriate keys without being in the list of addresses, but second that the caller will get the CNAME chain back rather than just the addresses.\r\n\r\nPerhaps a reasonable optimization for those clients that can do it, though.",
              "createdAt": "2019-02-28T00:13:16Z",
              "updatedAt": "2019-02-28T00:30:02Z"
            },
            {
              "originalPosition": 168,
              "body": "\"the address netmask\" isn't defined, here or elsewhere.  I presume that this should read something like \"...and if the intersection of the A or AAAA responses and the set of address ranges in address_set is not empty, then clients SHOULD initiate TLS with ESNI to addresses in that intersection.\"",
              "createdAt": "2019-02-28T00:17:47Z",
              "updatedAt": "2019-02-28T00:30:02Z"
            },
            {
              "originalPosition": 175,
              "body": "Likewise, \"If the intersection (...) is empty but the A/AAAA resolution included a CNAME which matches....\"",
              "createdAt": "2019-02-28T00:19:02Z",
              "updatedAt": "2019-02-28T00:30:02Z"
            },
            {
              "originalPosition": 186,
              "body": "Isn't this just a subcase of the previous points?  If the address_set is empty, then by definition there's no overlap with the A/AAAA results.  So either the name occurs in the CNAME chain (4) or you resolve the name (5).",
              "createdAt": "2019-02-28T00:21:21Z",
              "updatedAt": "2019-02-28T00:30:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQxNTc5",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:40:41Z",
          "updatedAt": "2019-02-28T00:40:41Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Oh, hah, yes! Will fix.",
              "createdAt": "2019-02-28T00:40:41Z",
              "updatedAt": "2019-02-28T00:40:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQxNjI1",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:40:52Z",
          "updatedAt": "2019-02-28T00:40:52Z",
          "comments": [
            {
              "originalPosition": 175,
              "body": "\ud83d\udc4d \r\n",
              "createdAt": "2019-02-28T00:40:52Z",
              "updatedAt": "2019-02-28T00:40:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQxODc0",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:41:56Z",
          "updatedAt": "2019-02-28T00:41:56Z",
          "comments": [
            {
              "originalPosition": 186,
              "body": "Yes, technically. I left it as is to be explicit. I can remove it if we think it's excessive.",
              "createdAt": "2019-02-28T00:41:56Z",
              "updatedAt": "2019-02-28T00:41:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA5ODA4MDM3",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-01T22:15:55Z",
          "updatedAt": "2019-03-01T22:15:56Z",
          "comments": [
            {
              "originalPosition": 186,
              "body": "Maybe instead of listing it as a separate step, just turn it into an unnumbered comment that an empty address set will always land in (4) or (5).",
              "createdAt": "2019-03-01T22:15:56Z",
              "updatedAt": "2019-03-01T22:15:56Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f07d3806d52add7920a0f4087f93c85bede08581",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/multi-cdn",
      "headRefOid": "7adfa01707ef34bca44891084f386d2c587e1e04",
      "mergeCommit": null
    },
    {
      "number": 144,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU4MTYwNDU5",
      "title": "Use new RRType instead of TXT with a custom prefix",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/144",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Subsumes #73 and #108.",
      "createdAt": "2019-03-05T02:31:59Z",
      "updatedAt": "2019-09-24T10:55:09Z",
      "closedAt": "2019-03-06T00:54:53Z",
      "mergedAt": "2019-03-06T00:54:52Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "lgtm",
          "createdAt": "2019-03-05T02:48:38Z",
          "updatedAt": "2019-03-05T02:48:38Z"
        },
        {
          "author": "ValZapod",
          "authorAssociation": "NONE",
          "body": "@chris-wood @kazuho @mcmanus \r\nWhat the... So all already working eSNI in Cloudflare is already outdated? Do you understand how difficult it will be to get new IN ESNI in Bind and Knot and even in dig utility? Do you understand that while IN txt is working in all OS, IN ESNI will not work in any of them (system resolver, I mean)? Do you understand that you use for ESNI RR 0xff9f (which is 65439), so it is reserved for private use in IANA?\r\nSolution for this. Can you please use both of them?",
          "createdAt": "2019-04-16T19:07:10Z",
          "updatedAt": "2019-04-16T19:07:10Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">   Internet-Drafts are draft documents valid for a maximum of six months\r\n >  and may be updated, replaced, or obsoleted by other documents at any\r\n  > time.  It is inappropriate to use Internet-Drafts as reference\r\n  > material or to cite them other than as \"work in progress.\"\r\n",
          "createdAt": "2019-04-19T20:20:48Z",
          "updatedAt": "2019-04-19T20:20:48Z"
        },
        {
          "author": "Viktor45",
          "authorAssociation": "NONE",
          "body": "this is good for wiretapping for easy to drop all ESNI with DPI for SNI downgrade",
          "createdAt": "2019-09-24T10:55:09Z",
          "updatedAt": "2019-09-24T10:55:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEwNDcyMjQ1",
          "commit": {
            "abbreviatedOid": "5f191fd"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": ":+1:",
          "createdAt": "2019-03-05T02:57:05Z",
          "updatedAt": "2019-03-05T02:57:05Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f07d3806d52add7920a0f4087f93c85bede08581",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/remove-prefix-with-new-rrtype",
      "headRefOid": "5f191fdb2c5826a7be33de59a2128ac6d7ee6060",
      "mergeCommit": {
        "oid": "5fda4a09bcde55a2256053c79d5fc432d58b2f8d"
      }
    },
    {
      "number": 147,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5MzA1ODEy",
      "title": "Encrypt nonce for secure sharing of the true SNI with a third party",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/147",
      "state": "CLOSED",
      "author": "roelfdutoit",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Third party secret sharing solutions might be developed in future.  This PR enables sharing of the true SNI  while at the same time preventing the third party from impersonating the server.  The client encrypts the nonce with a key derived from Z, and only a server with access to Z will be able to acknowledge the decrypted nonce.",
      "createdAt": "2019-03-07T23:15:49Z",
      "updatedAt": "2019-07-04T15:52:58Z",
      "closedAt": "2019-07-04T15:52:58Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@roelfdutoit what's the plan for this PR?",
          "createdAt": "2019-07-04T14:24:24Z",
          "updatedAt": "2019-07-04T14:24:24Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d9437fd5a4ed04dff1b5e48f97c586f242e80fb4",
      "headRepository": "roelfdutoit/draft-ietf-tls-esni",
      "headRefName": "encrypted_nonce",
      "headRefOid": "9346ce43c15b9ccbb2d3369c362bed1acbc64e11",
      "mergeCommit": null
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5NjEwNTQ2",
      "title": "specify 7838 reference applies to section 2.3",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/148",
      "state": "MERGED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #132",
      "createdAt": "2019-03-08T21:19:31Z",
      "updatedAt": "2019-03-08T21:24:29Z",
      "closedAt": "2019-03-08T21:24:29Z",
      "mergedAt": "2019-03-08T21:24:28Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNDg1OTI0",
          "commit": {
            "abbreviatedOid": "89e83e5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-08T21:24:25Z",
          "updatedAt": "2019-03-08T21:24:25Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b339186ec98274e93132de121e76ca55cce849d",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-altsvc-clarification",
      "headRefOid": "89e83e54809f169c36679cba6b92bccf89fa2978",
      "mergeCommit": {
        "oid": "a73367b8c58ba0a7f726743ad72ca4fd2b22574d"
      }
    },
    {
      "number": 151,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY4OTQyMjEw",
      "title": "Exclude extensions from record digest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/151",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #150.",
      "createdAt": "2019-04-09T22:08:37Z",
      "updatedAt": "2019-04-14T23:22:12Z",
      "closedAt": "2019-04-14T23:22:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Superseded by #153.",
          "createdAt": "2019-04-14T23:22:11Z",
          "updatedAt": "2019-04-14T23:22:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI0NjgxNTAz",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-09T22:14:36Z",
          "updatedAt": "2019-04-09T22:14:37Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "It seems weird to exclude other extensions. Also I assume you mean the first byte of \"version\"?",
              "createdAt": "2019-04-09T22:14:36Z",
              "updatedAt": "2019-04-09T22:14:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI0NzAyODgw",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-09T23:36:08Z",
          "updatedAt": "2019-04-09T23:36:08Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I agree. I'm not sure this is the right approach. It seems we should either (a) have individual extensions included in the digest or not via some mandatory-like bit, or (b) have a separate extensions field that's omitted from the digest, in which the address information can go. Both are... not great.",
              "createdAt": "2019-04-09T23:36:08Z",
              "updatedAt": "2019-04-09T23:36:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI0NzAzMTI3",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for taking this issue! As the comment suggest, I'm not sure this is the best approach. I'm curious to hear counterarguments. ",
          "createdAt": "2019-04-09T23:37:11Z",
          "updatedAt": "2019-04-09T23:37:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI0ODI2OTU2",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-10T08:30:30Z",
          "updatedAt": "2019-04-10T08:30:30Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "To me the point of `record_digest` is to identify a specific key so that the TLS server doesn't have to do trial decryption, that is, its point is not the digest itself, but the fact that it identifies a key, is this correct?\r\n\r\nIf so, it seems fine (but not great) that it would only really cover the specific key and the metadata directly associated with the key, while extensions can potentially be associated with multiple keys.\r\n\r\nBut a potentially better alternative is to just get rid of `record_digest` (if my assumption that it only provides an \"identity\" for the key), and replace with an explicit `key_identity` field that is generated by the server and would get added to `ESNIKeys` as well as replace `record_digest` in the ClientHello extension.\r\n\r\nThoughts?",
              "createdAt": "2019-04-10T08:30:30Z",
              "updatedAt": "2019-04-10T08:30:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1Mjk4MjY2",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-11T02:00:24Z",
          "updatedAt": "2019-04-11T02:00:25Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "@ghedo \r\n> But a potentially better alternative is to just get rid of `record_digest` (if my assumption that it only provides an \"identity\" for the key), and replace with an explicit `key_identity` field that is generated by the server and would get added to `ESNIKeys` as well as replace `record_digest` in the ClientHello extension.\r\n\r\nI am not sure if that is the correct thing to do. I'd be concerned that omission of a digest might lead to availability concerns.\r\n\r\nThe reason we have had `record_digest` is because the TLS handshake used to always hard-fail when client uses a corrupt ESNI record. With #124 being merged, we have a fallback mechanism that would work in _some_ failure modes without the need for the digest. However, I believe that there are still certain cases of hard failure (like the server sending an `illegal_parameter` alert) when the ESNI record is corrupt.\r\n\r\nPS. Therefore I think I might favor the approach proposed by @davidben in #150: place the IP address list outside of the ESNIKeys.",
              "createdAt": "2019-04-11T02:00:25Z",
              "updatedAt": "2019-04-11T02:02:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1NTEwMDQy",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-11T12:45:31Z",
          "updatedAt": "2019-04-11T12:45:32Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I'm not sure I follow @kazuho, isn't the `checksum` value intended to detect record corruption? If so, why do we have two?",
              "createdAt": "2019-04-11T12:45:32Z",
              "updatedAt": "2019-04-11T12:45:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1NzE4ODI2",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-11T18:41:38Z",
          "updatedAt": "2019-04-11T18:41:38Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "@ghedo `record_digest` was originally added to prevent downgrades, so we want it to cover as much of the necessary bits in the record as possible. It just so happens to also serve as a key identifier for the server.",
              "createdAt": "2019-04-11T18:41:38Z",
              "updatedAt": "2019-04-11T18:41:38Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ba52fe66fb3a9a8d98dfd3d59b7322c454405f03",
      "headRepository": null,
      "headRefName": "record-digest-no-extensions",
      "headRefOid": "0d5c6905c8fc5ec2d9d9574bc958c8179af643ba",
      "mergeCommit": null
    },
    {
      "number": 152,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcwMTMzMjY5",
      "title": "There's no ESNI TXT record anymore",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/152",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-04-12T19:52:40Z",
      "updatedAt": "2019-04-12T23:18:38Z",
      "closedAt": "2019-04-12T23:18:38Z",
      "mergedAt": "2019-04-12T23:18:38Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2MzIwMTE0",
          "commit": {
            "abbreviatedOid": "70b9b6b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-12T23:18:32Z",
          "updatedAt": "2019-04-12T23:18:32Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ba52fe66fb3a9a8d98dfd3d59b7322c454405f03",
      "headRepository": null,
      "headRefName": "not-txt",
      "headRefOid": "70b9b6b66a02866626699d0ad11981cf55309e32",
      "mergeCommit": {
        "oid": "51bc4ed89ae61585bd800d55785b5abd7c457a30"
      }
    },
    {
      "number": 153,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcwMzM1NjU5",
      "title": "Introduce ESNIRecord wrapper and move AddressSet into it",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/153",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #150.\r\n\r\n---\r\n\r\nTry 2. This turned out to be somewhat tricky due to existing text using \"ESNI record\" and \"ESNIKeys record\" (and similar) interchangeably, so I might have missed some instances.\r\n\r\nAn alternative design would have been to have a single ESNIRecord value per ESNI record, and then have multiple ESNIKeys values for each ESNIRecord (instead of multiple ESNIRecord values per ESNI and single ESNIKeys per ESNIRecord), though that will require more changes.",
      "createdAt": "2019-04-14T23:20:56Z",
      "updatedAt": "2019-04-18T16:40:57Z",
      "closedAt": "2019-04-18T16:40:57Z",
      "mergedAt": "2019-04-18T16:40:57Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @ghedo!",
          "createdAt": "2019-04-18T16:40:44Z",
          "updatedAt": "2019-04-18T16:40:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4MDAwMDM2",
          "commit": {
            "abbreviatedOid": "2432376"
          },
          "author": "dvorak42",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-17T21:09:23Z",
          "updatedAt": "2019-04-17T21:11:29Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Might be useful to call out that these extensions aren't verified as part of the record_digest?",
              "createdAt": "2019-04-17T21:09:23Z",
              "updatedAt": "2019-04-17T21:11:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4MzkwNTYy",
          "commit": {
            "abbreviatedOid": "2432376"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-18T16:40:33Z",
          "updatedAt": "2019-04-18T16:40:33Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Agreed. I'll merge this and then make that change directly. ",
              "createdAt": "2019-04-18T16:40:33Z",
              "updatedAt": "2019-04-18T16:40:33Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "51bc4ed89ae61585bd800d55785b5abd7c457a30",
      "headRepository": null,
      "headRefName": "extensions-all-the-way-down",
      "headRefOid": "2432376197825756c171842e06fbcfc981f13a74",
      "mergeCommit": {
        "oid": "8679dc49caa2131d9b660d9d30e4343aa7e994f9"
      }
    },
    {
      "number": 154,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcyODcxMDIy",
      "title": "Switch to record_digest_mac to prevent GREASE detection.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/154",
      "state": "CLOSED",
      "author": "dvorak42",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently an attacker can distinguish a real ESNI extension and\r\nGREASE extension based on the error returned by replaying the\r\nclient's ClientHello with swapped out keyshares.",
      "createdAt": "2019-04-23T19:57:59Z",
      "updatedAt": "2020-05-20T15:59:48Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4f3ce56fdb4caea12c6480ca3a9a5ec6bfd074c1",
      "headRepository": "dvorak42/draft-ietf-tls-esni",
      "headRefName": "grease_mac",
      "headRefOid": "bf4dee02a17f8afbb2828b50c320527be1e2d455",
      "closedAt": "2020-05-20T15:59:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #235!",
          "createdAt": "2020-05-20T15:59:47Z",
          "updatedAt": "2020-05-20T15:59:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYwNzc3",
          "commit": {
            "abbreviatedOid": "eadc232"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T17:43:32Z",
          "updatedAt": "2019-04-24T17:43:33Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "s/, however/. However,",
              "createdAt": "2019-04-24T17:43:32Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYxMTQx",
          "commit": {
            "abbreviatedOid": "eadc232"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T17:44:19Z",
          "updatedAt": "2019-04-24T17:44:20Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "nit: s/the IP it is connecting to./the destination IP address./",
              "createdAt": "2019-04-24T17:44:19Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYzMDQz",
          "commit": {
            "abbreviatedOid": "eadc232"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T17:47:56Z",
          "updatedAt": "2019-04-24T17:47:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "nit: I'd replace \"the attacker Adv\" with \"an attacker\", and \"they'd\" with \"Adv\"",
              "createdAt": "2019-04-24T17:47:56Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYzMzI3",
          "commit": {
            "abbreviatedOid": "eadc232"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T17:48:27Z",
          "updatedAt": "2019-04-24T17:48:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "nit: Perhaps say that this *may* disincentive deployment?",
              "createdAt": "2019-04-24T17:48:27Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYzODE1",
          "commit": {
            "abbreviatedOid": "1bcb80f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm OK with this change given the perceived risk. @ekr, @kazuho @grittygrease: please have a look and comment. ",
          "createdAt": "2019-04-24T17:49:24Z",
          "updatedAt": "2019-04-24T17:52:45Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Perhaps drop a forward pointer to the security considerations blurb here?",
              "createdAt": "2019-04-24T17:49:24Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            },
            {
              "originalPosition": 20,
              "body": "Perhaps point to the section where it's defined?",
              "createdAt": "2019-04-24T17:52:02Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMzI4Mzk4",
          "commit": {
            "abbreviatedOid": "bf4dee0"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T20:06:40Z",
          "updatedAt": "2019-04-24T20:06:40Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "I'm not sure how persuasive I find this. It seems like it's quite likely that the attacker can determine which IP addresses support ESNI, simply by doing reverse resolution and then forward resolution. Why does this help?",
              "createdAt": "2019-04-24T20:06:40Z",
              "updatedAt": "2019-04-24T20:06:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxODczNTM1",
          "commit": {
            "abbreviatedOid": "bf4dee0"
          },
          "author": "dvorak42",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-29T20:02:21Z",
          "updatedAt": "2019-04-29T20:02:22Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "A way of avoiding that, though which might be problematic to deploy, is that the reverse resolution name and the public name don't have ESNI records, since you don't necessarily need ESNI when hitting those names, since they're already visible to an attacker.",
              "createdAt": "2019-04-29T20:02:22Z",
              "updatedAt": "2019-04-29T20:02:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 157,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0MzI5MzI4",
      "title": "Allow different records while keeping the same anonymity set",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/157",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current text about anonymity sets for records is too restrictive. If I have 100000 names and 100 IPs and for all queries I randomly return four out of my 100 IPs chosen randomly, I still provide the same anonymity set but I violate the SHOULD. The proposed text fixes #133 ",
      "createdAt": "2019-06-02T09:35:45Z",
      "updatedAt": "2019-06-03T08:26:37Z",
      "closedAt": "2019-06-02T15:13:39Z",
      "mergedAt": "2019-06-02T15:13:38Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjMwNzcz",
          "commit": {
            "abbreviatedOid": "0248ca7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM -- thanks!",
          "createdAt": "2019-06-02T15:12:46Z",
          "updatedAt": "2019-06-02T15:12:58Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4f3ce56fdb4caea12c6480ca3a9a5ec6bfd074c1",
      "headRepository": "DavidSchinazi/draft-ietf-tls-esni",
      "headRefName": "allow_different_records",
      "headRefOid": "0248ca74b80bcf2c9174753c2599232d555964c4",
      "mergeCommit": {
        "oid": "8c9626ea59a087ab006da8b37bb251b28df68403"
      }
    },
    {
      "number": 158,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0MzYwNDk3",
      "title": "Clarify AAD for encrypted_sni and HKDF-Extract salt",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/158",
      "state": "MERGED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While at it, remove the redundant \"ClientHello.\" prefix, the name\r\nKeyShareClientHello implies this. Fixes #155\r\n___\r\n@sftcd I did not explicitly mention that \"extension_data\" is a list of key shares, but hope that the suggested phrase is strong enough to imply that. Do you think that is sufficient or should it become something like:\r\n\r\n> Where ClientHello.KeyShareClientHello is the \"extension_data\" field of the\r\n> \"key_share\" extension in a Client Hello (Section 4.2.8 of {{!RFC8446}})),\r\n> namely a list of key shares.\r\n\r\n(By the way, the list of client key shares could contain one or more entries, but it could also be empty if the client would like to trigger a HRR. That should still be OK since the key/nonce is derived from the client hello random.)",
      "createdAt": "2019-06-02T18:16:04Z",
      "updatedAt": "2019-06-02T23:03:59Z",
      "closedAt": "2019-06-02T19:57:43Z",
      "mergedAt": "2019-06-02T19:57:43Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "Those changes seem okish though could maybe be better. My issue was that OpenSSL (afaics) previously ignored all the key shares except the one used, so handling two of 'em as the AAD meant adding some new state. No idea if other implementations are like that though. I guess it might help someone else if it explicitly said that there can be >1 key share to include in the AAD.\r\n\r\n(BTW, on your BTW, I need to think more about ESNI and HRR handling, haven't tested that yet so not sure if there's a case where the encoding of 0 key shares would be used as ESNI AAD.)\r\n",
          "createdAt": "2019-06-02T18:30:34Z",
          "updatedAt": "2019-06-02T18:30:34Z"
        },
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If this adds so much complication, why not drop the KeyShareClientHello completely? If the purpose is to bind this to the original Client Hello, then the Client Random should be sufficient.\r\n\r\nAn implementation that creates the encrypted_sni field is also responsible for generating a random client hello and a new ESNI key share. Assuming that these are always unique between Client Hellos, then removing the KeyShareClientHello extension should still preserve the binding property.\r\n\r\nAnd even if for some reason the ESNI key share is reused (e.g. shared between different client hello, or reusing one from KeyShareClientHello), the derived key/nonce would still be different if Client Hello Random is unique.\r\n\r\n@chris-wood what was the reason for mixing the client key shares list in addition to the existing client random (commit 134b15c87b5c4cde7f52500138662f64757e2e9c)?",
          "createdAt": "2019-06-02T19:14:13Z",
          "updatedAt": "2019-06-02T19:14:13Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "If you don't bind in the client key share, there is a trivial attack in which the attacker replaces the key share with their own, causing the server's certificate to be encrypted to them.",
          "createdAt": "2019-06-02T19:22:17Z",
          "updatedAt": "2019-06-02T19:22:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood what was the reason for mixing the client key shares list in addition to the existing client random (commit 134b15c)?\r\n\r\nWhat @ekr said above. :-)",
          "createdAt": "2019-06-02T19:56:05Z",
          "updatedAt": "2019-06-02T19:56:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the clarifying text!",
          "createdAt": "2019-06-02T19:57:39Z",
          "updatedAt": "2019-06-02T19:57:39Z"
        },
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If you don't bind in the client key share, there is a trivial attack in which the attacker replaces the key share with their own, causing the server's certificate to be encrypted to them.\r\n\r\nOh I see, the sender of the ESNI extension does not have to prove its knowledge about the ESNI private key, so an attacker could trivially copy the victim's ESNI extension and client random into the attacker's handshake, and recover the certificate if the client key shares were not included. Even if the attacker cannot decrypt SNI, they can still observe the side-effects. Thanks!\r\n\r\nI think the text could be clarified to highlight this, I'll prepare a proposal for this.",
          "createdAt": "2019-06-02T23:03:59Z",
          "updatedAt": "2019-06-02T23:03:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQwMTU1",
          "commit": {
            "abbreviatedOid": "6c43eb7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-02T19:57:31Z",
          "updatedAt": "2019-06-02T19:57:31Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8c9626ea59a087ab006da8b37bb251b28df68403",
      "headRepository": "Lekensteyn/draft-ietf-tls-esni",
      "headRefName": "clarify-aad",
      "headRefOid": "6c43eb7a76fb16cc18746bae665dd54a767f9b6f",
      "mergeCommit": {
        "oid": "6c78c495e19f4977d3b030a36433dd982f544b18"
      }
    },
    {
      "number": 159,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0Mzg2MjY0",
      "title": "Clarify how anti-replay protection is achieved",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/159",
      "state": "CLOSED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The SNI encryption key is not bound to the Client Hello, one could for\r\nexample \"cut and paste\" the ESNI value in a different Client Hello with\r\nthe same Random field, key_share extension and ESNI extension, but with\r\na different, say, supported_groups extension.\r\n\r\nRemove the (EC)DH argument since it only ensures that an attacker cannot\r\ncompute the SNI encryption key, but actual anti-replay protection is\r\nprovided by binding to the key_share extension.",
      "createdAt": "2019-06-03T01:00:58Z",
      "updatedAt": "2020-03-09T21:58:20Z",
      "closedAt": "2020-03-09T21:58:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is likely overcome by events in #207. @Lekensteyn, can you please update this PR based on that text, or close it?",
          "createdAt": "2020-03-08T00:36:50Z",
          "updatedAt": "2020-03-08T00:36:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by #207.",
          "createdAt": "2020-03-09T21:58:20Z",
          "updatedAt": "2020-03-09T21:58:20Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6c78c495e19f4977d3b030a36433dd982f544b18",
      "headRepository": "Lekensteyn/draft-ietf-tls-esni",
      "headRefName": "clarify-anti-replay",
      "headRefOid": "429e5a8da0bd3e09effbc7075eb62a94597aedd5",
      "mergeCommit": null
    },
    {
      "number": 161,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg4NzQyMDY1",
      "title": "Remove not_before and not_after",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/161",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We now have a proper retry mechanism, so we don't need to prevent\r\nclients to connect using expired keys anymore.",
      "createdAt": "2019-06-17T08:24:11Z",
      "updatedAt": "2019-06-17T18:17:17Z",
      "closedAt": "2019-06-17T18:17:17Z",
      "mergedAt": "2019-06-17T18:17:17Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMzc1OTEw",
          "commit": {
            "abbreviatedOid": "9b267c2"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for the PR. LGTM",
          "createdAt": "2019-06-17T09:10:38Z",
          "updatedAt": "2019-06-17T09:10:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNjY2NDM3",
          "commit": {
            "abbreviatedOid": "9b267c2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-17T18:17:10Z",
          "updatedAt": "2019-06-17T18:17:10Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6c78c495e19f4977d3b030a36433dd982f544b18",
      "headRepository": null,
      "headRefName": "remove-not-before-after",
      "headRefOid": "9b267c20662db55ba54afa715a06be5990fe6930",
      "mergeCommit": {
        "oid": "46490d1ad41cf67b2ae4ad4aac9785a351acd8fd"
      }
    },
    {
      "number": 162,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5ODM2NTQ1",
      "title": "Restrict padded_length values",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/162",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion at https://github.com/tlswg/draft-ietf-tls-esni/issues/134",
      "createdAt": "2019-06-19T18:53:21Z",
      "updatedAt": "2019-06-27T18:09:36Z",
      "closedAt": "2019-06-27T18:09:36Z",
      "mergedAt": "2019-06-27T18:09:36Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not a fan of this change. I don't like encoding this kind of restrictive choice in the protocol.",
          "createdAt": "2019-06-19T19:01:16Z",
          "updatedAt": "2019-06-19T19:01:16Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, I've removed the protocol change and made the restriction purely advisory.",
          "createdAt": "2019-06-19T19:15:01Z",
          "updatedAt": "2019-06-19T19:15:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MjUxNTcx",
          "commit": {
            "abbreviatedOid": "7d453b2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The recommended text LGTM. @kazuho @ekr @grittygrease please have a look.",
          "createdAt": "2019-06-25T20:29:55Z",
          "updatedAt": "2019-06-25T20:29:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MzIwNjgw",
          "commit": {
            "abbreviatedOid": "7d453b2"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM. Thank you for the text!",
          "createdAt": "2019-06-25T23:33:29Z",
          "updatedAt": "2019-06-25T23:33:29Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "46490d1ad41cf67b2ae4ad4aac9785a351acd8fd",
      "headRepository": "bemasc/draft-ietf-tls-esni",
      "headRefName": "bemasc-padded-length",
      "headRefOid": "7d453b23db56f59e9a72895f953ca789a8b00060",
      "mergeCommit": {
        "oid": "dfad9d1f770133375535808f12ccc6376faabeb7"
      }
    },
    {
      "number": 163,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTY0NzAy",
      "title": "Remove checksum in favor of record_digest and retry mechanism.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/163",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The checksum seems to add little value with the retry mechanism and record_digest. I think we should remove it. See #64 for some context.",
      "createdAt": "2019-07-03T00:56:28Z",
      "updatedAt": "2019-07-03T01:20:19Z",
      "closedAt": "2019-07-03T01:20:19Z",
      "mergedAt": "2019-07-03T01:20:19Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjIwNjYz",
          "commit": {
            "abbreviatedOid": "f087cd1"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I agree that we can now and should make this simplification. The PR looks good to me.",
          "createdAt": "2019-07-03T01:19:48Z",
          "updatedAt": "2019-07-03T01:19:48Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "dfad9d1f770133375535808f12ccc6376faabeb7",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/remove-checksum",
      "headRefOid": "f087cd10d2586ebf61341f32aa80c474ad1ea89b",
      "mergeCommit": {
        "oid": "a25f407349622080025d737536b09ba421cd6bbb"
      }
    },
    {
      "number": 164,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTY1NjE2",
      "title": "Add reference to RFC8446 for TLS notation.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/164",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #160.",
      "createdAt": "2019-07-03T01:02:37Z",
      "updatedAt": "2019-07-03T01:09:00Z",
      "closedAt": "2019-07-03T01:09:00Z",
      "mergedAt": "2019-07-03T01:08:59Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "dfad9d1f770133375535808f12ccc6376faabeb7",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/presentation-language",
      "headRefOid": "fad362f9809d24b96ed029e36a60f616792135da",
      "mergeCommit": {
        "oid": "5f41edfaa689fe899148bb640a3886ce7c7e3fef"
      }
    },
    {
      "number": 165,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTY3NDA5",
      "title": "SNI extensibility failed. See [1].",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/165",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[1] https://mailarchive.ietf.org/arch/msg/tls/1t79gzNItZd71DwwoaqcQQ_4Yxc\r\n\r\nFixes #68.",
      "createdAt": "2019-07-03T01:15:09Z",
      "updatedAt": "2019-07-03T20:30:29Z",
      "closedAt": "2019-07-03T20:30:29Z",
      "mergedAt": "2019-07-03T20:30:29Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjIxNjYy",
          "commit": {
            "abbreviatedOid": "6a37e61"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-03T01:25:16Z",
          "updatedAt": "2019-07-03T01:25:20Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I don't know if this is the best place to signal this, but I approve anyway.",
              "createdAt": "2019-07-03T01:25:17Z",
              "updatedAt": "2019-07-03T01:25:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjIyMjcy",
          "commit": {
            "abbreviatedOid": "6a37e61"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T01:28:17Z",
          "updatedAt": "2019-07-03T01:28:17Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I figured it's best to be honest and up front. :-)",
              "createdAt": "2019-07-03T01:28:17Z",
              "updatedAt": "2019-07-03T01:28:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjI5MDUx",
          "commit": {
            "abbreviatedOid": "6a37e61"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-03T02:02:50Z",
          "updatedAt": "2019-07-03T02:02:50Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5f41edfaa689fe899148bb640a3886ce7c7e3fef",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hostnames-only",
      "headRefOid": "6a37e61f86521654a9afe015347e9a8d9bd4a8b9",
      "mergeCommit": {
        "oid": "4ec4cb4ee196a4cec35fdce9640bf86cc559bc2a"
      }
    },
    {
      "number": 166,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTkxMjE1",
      "title": "Add note about optional record_digest and trial decryption alternative.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/166",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #138.",
      "createdAt": "2019-07-03T03:50:04Z",
      "updatedAt": "2019-07-08T17:25:21Z",
      "closedAt": "2019-07-08T17:25:21Z",
      "mergedAt": "2019-07-08T17:25:21Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema can you please take a look?",
          "createdAt": "2019-07-03T03:50:17Z",
          "updatedAt": "2019-07-03T03:50:17Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, adding a trial decryption is a good thing. Two suggestions:\r\n\r\n1) in security section describe privacy attack by tracking the crypto ID.\r\n\r\n2) also describe the attack by forcing trial decryption.\r\n\r\nMaybe add an option to publish ESNI record with NULL checksum as a way to signal acceptance of trial decryption ?\r\n\r\n",
          "createdAt": "2019-07-03T06:18:53Z",
          "updatedAt": "2019-07-03T06:18:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> 1. in security section describe privacy attack by tracking the crypto ID.\r\n\r\nI plan to address this in a PR for #146.\r\n\r\n> 2. also describe the attack by forcing trial decryption.\r\n\r\nGood suggestion! I'll add that here.\r\n",
          "createdAt": "2019-07-03T13:51:10Z",
          "updatedAt": "2019-07-03T13:51:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema please let me know if the latest text works for you!",
          "createdAt": "2019-07-03T13:57:00Z",
          "updatedAt": "2019-07-03T13:57:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho @ekr can you please take a look?",
          "createdAt": "2019-07-04T14:18:42Z",
          "updatedAt": "2019-07-04T14:18:42Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think you should say that it has to be somehow externally configured.\n\nOn Mon, Jul 8, 2019 at 9:27 AM Christopher Wood <notifications@github.com>\nwrote:\n\n> *@chris-wood* commented on this pull request.\n> ------------------------------\n>\n> In draft-ietf-tls-esni.md\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/166#discussion_r301187179>\n> :\n>\n> > @@ -743,10 +750,14 @@ for servers to proceed with the connection and rely on the client to abort if\n>  ESNI was required. In particular, the unrecognized value alone does not\n>  indicate a misconfigured ESNI advertisement ({{misconfiguration}}). Instead,\n>  servers can measure occurrences of the \"esni_required\" alert to detect this\n> -case.\n> +case. An empty ClientEncryptedSNI.record_digest value MAY be used in environments\n> +wherein trial decryption is a viable approach for matching ClientEncryptedSNI\n> +contents to a known ESNIKeys. (Some uses of ESNI, such as local discovery mode,\n>\n> It'd be application or deployment-specific. In DNS-SD, for example, they'd\n> likely configure the stack to omit the record digest.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/166?email_source=notifications&email_token=AAIPLINEK7B5LDKCKVQFIXLP6NTHJA5CNFSM4H5BUB4KYY3PNVWWK3TUL52HS4DFWFIHK3DMKJSXC5LFON2FEZLWNFSXPKTDN5WW2ZLOORPWSZGOB5YFAVQ#discussion_r301187179>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIMP7MKI63IRGSLCW3LP6NTHJANCNFSM4H5BUB4A>\n> .\n>\n",
          "createdAt": "2019-07-08T16:28:43Z",
          "updatedAt": "2019-07-08T16:28:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think you should say that it has to be somehow externally configured.\r\n\r\nGood suggestion! Will fix.",
          "createdAt": "2019-07-08T16:37:29Z",
          "updatedAt": "2019-07-08T16:37:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTQ5NjEw",
          "commit": {
            "abbreviatedOid": "87a98f0"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T14:59:36Z",
          "updatedAt": "2019-07-03T14:59:37Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "To clarify, is the intent here is that servers outside those environments are not required to implement trial decryption?\r\n\r\nThe text reads a little unclear to me. The paragraph above just says an empty one \"MAY be used in [some environments]\", but that could mean by either the client or the server. This paragraph also could read as if the server needs to check the trial decryption, otherwise it doesn't know whether to follow these steps.\r\n\r\n(Trial decryption would more fully solve the issue #154 is trying to address, but I worry about the performance cost of asymmetric trial decryption if you rotate keys decently often. Then again, the robustness fixes do mean it's okay to drop older keys sooner if only used by a tiny fraction of clients...)",
              "createdAt": "2019-07-03T14:59:36Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTU4NDEw",
          "commit": {
            "abbreviatedOid": "87a98f0"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T15:12:29Z",
          "updatedAt": "2019-07-03T15:12:29Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "The trial decryption should be opt-in. The typical use case is in local discovery, with DTLS or QUIC. Broadcast or multicast the first packet, and then all servers who are ready to be discovered do trial detection. Yes, this is trading off CPU for server privacy, which is only OK in some scenario. In a typical implementation, the server would have a \"discovery\" flag, which will enable trial decryption when \"waiting to be discovered\". ",
              "createdAt": "2019-07-03T15:12:29Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTgwMzQ4",
          "commit": {
            "abbreviatedOid": "87a98f0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T15:45:47Z",
          "updatedAt": "2019-07-03T15:45:47Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "> To clarify, is the intent here is that servers outside those environments are not required to implement trial decryption?\r\n\r\nPrecisely. I see what you mean about it implying trial decryption is necessary. Perhaps: \r\n\r\n```\r\nIf the ClientEncryptedSNI.record_digest value does match a known ESNIKeys, the server...\r\n```\r\n\r\nAnd then later on...\r\n\r\n```\r\nIf ClientEncryptedSNI.record_digest is non-empty, servers SHOULD compare it against cryptographic hashes of known ESNIKeys to find a match. If ClientEncryptedSNI.record_digest is empty, servers MAY use trial decryption to match to a known ESNIKeys.\r\n```\r\n",
              "createdAt": "2019-07-03T15:45:47Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTg0NDAz",
          "commit": {
            "abbreviatedOid": "249505b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T15:52:12Z",
          "updatedAt": "2019-07-03T15:52:13Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "@davidben @huitema: I made an attempt at clarifying the text. Suggestions for improvements are welcome!",
              "createdAt": "2019-07-03T15:52:13Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NjAwODcz",
          "commit": {
            "abbreviatedOid": "249505b"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T16:19:34Z",
          "updatedAt": "2019-07-03T16:20:22Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Looking at this, I wonder whether there are other mitigations than \"rate limiting\". Take for example the case of a server that has published only one key: trial decryption then is no more expensive that decryption directed by a specific checksum, which the adversary can learn from the DNS record. So an obvious mitigation in case of stress is to only trial one of the published keys, possibly the latest, or a randomly chosen one.\r\n\r\nMaybe we should point out the directed DOS attack -- for example, an adversary could bomb a forwarding server with repeated connection request. But then, that's not much more potent than repeated non-ESNI connection requests.",
              "createdAt": "2019-07-03T16:19:34Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NjExNDU0",
          "commit": {
            "abbreviatedOid": "249505b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T16:39:13Z",
          "updatedAt": "2019-07-03T16:39:13Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "> I wonder whether there are other mitigations than \"rate limiting\".\r\n\r\nThere probably are, which is why I list this as only one example :-) Would you prefer we just drop this sentence entirely?",
              "createdAt": "2019-07-03T16:39:13Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDExNzE2",
          "commit": {
            "abbreviatedOid": "cc89246"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:14:07Z",
          "updatedAt": "2019-07-08T16:16:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This \"otherwise\" seems to forbid random record_digests (as opposed to empty) or to fall back to trial decryption.. Is that intended?",
              "createdAt": "2019-07-08T16:14:07Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            },
            {
              "originalPosition": 29,
              "body": "How would you know that this is possible.",
              "createdAt": "2019-07-08T16:14:57Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDE4NTAz",
          "commit": {
            "abbreviatedOid": "cc89246"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:26:51Z",
          "updatedAt": "2019-07-08T16:26:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Hmm, good point. It's not intended. I'll remove \"Otherwise.\"",
              "createdAt": "2019-07-08T16:26:51Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDE4ODM4",
          "commit": {
            "abbreviatedOid": "cc89246"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:27:30Z",
          "updatedAt": "2019-07-08T16:27:31Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "It'd be application or deployment-specific. In DNS-SD, for example, they'd likely configure the stack to omit the record digest. ",
              "createdAt": "2019-07-08T16:27:31Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDQ2MzQw",
          "commit": {
            "abbreviatedOid": "bca2bb3"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T17:20:35Z",
          "updatedAt": "2019-07-08T17:20:43Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I would write this as:\r\n\"Unless specified by the application using DTLS or externally configured on both sides, implementations MUST use the first method.\"",
              "createdAt": "2019-07-08T17:20:35Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDQ4Nzky",
          "commit": {
            "abbreviatedOid": "4163aff"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T17:25:14Z",
          "updatedAt": "2019-07-08T17:25:14Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "That's much better -- thanks!",
              "createdAt": "2019-07-08T17:25:14Z",
              "updatedAt": "2019-07-08T17:25:14Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "342840b5430948ffe709f5d665d63859edee2f67",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/optional-digest",
      "headRefOid": "4163aff4ffdcf9f5cc7b61588128be0102d25714",
      "mergeCommit": {
        "oid": "b33c43a8b751643962e3d12c441f4baa0d7c1776"
      }
    },
    {
      "number": 167,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTkzNDAx",
      "title": "Add note about cleartext OCSP.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/167",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #156.",
      "createdAt": "2019-07-03T04:05:10Z",
      "updatedAt": "2019-07-04T01:12:54Z",
      "closedAt": "2019-07-04T01:12:54Z",
      "mergedAt": "2019-07-04T01:12:54Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjUyNzkz",
          "commit": {
            "abbreviatedOid": "33af345"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-03T04:15:27Z",
          "updatedAt": "2019-07-03T04:18:52Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "The PR looks good to me.\r\n\r\nThat said, it might be to a good idea to say something like \"prohibit generating OCSP traffic, especially in cleartext\", as using an encrypted channel to the OCSP responder could still be an issue in sense that it leaks the IP address of the responder (or because use of OCSP is an act of leaking information to the OCSP responder).",
              "createdAt": "2019-07-03T04:15:28Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjU0Mzcy",
          "commit": {
            "abbreviatedOid": "33af345"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T04:24:37Z",
          "updatedAt": "2019-07-03T04:24:40Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "OCSP or CRL.\r\n\r\nI think that this needs to be framed differently.  The point here is that OCSP (or CRL checks) can leak the name.  But the reaction I would encourage is OCSP stapling, not \"don't do OCSP\" as this would appear to advocate for.",
              "createdAt": "2019-07-03T04:24:37Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjU1NjYw",
          "commit": {
            "abbreviatedOid": "33af345"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T04:32:07Z",
          "updatedAt": "2019-07-03T04:32:07Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Perhaps requiring stapling with a SHOULD is fine? (It seems fine to me, at least.)",
              "createdAt": "2019-07-03T04:32:07Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjczNDg5",
          "commit": {
            "abbreviatedOid": "544ba89"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for the changes. LGTM.",
          "createdAt": "2019-07-03T06:00:10Z",
          "updatedAt": "2019-07-03T06:00:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTkzMTIw",
          "commit": {
            "abbreviatedOid": "544ba89"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T16:05:43Z",
          "updatedAt": "2019-07-03T16:05:44Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "For a security considerations, it's probably better to spell this out more generically, because there are other ways in the verification stack to leak information. The most obvious omission here is AIA fetching, but it also relates to other proposals, such as Gossip or SCT verification proposals related to Certificate Transparency, or bespoke vendor solutions such as custom revocation information sources or on-the-fly downloading of CA information.\r\n\r\n```\r\nESNI requires encrypted DNS to be an effective privacy protection mechanism.\r\nHowever, verifying the server's identity from the Certificate message, particularly\r\nwhen using the X509 CertificateType, may result in additional network traffic\r\nthat may reveal the server identity. Examples of this traffic may include requests\r\nfor revocation information, such as OCSP or CRL traffic, or requests for repository\r\ninformation, such as authorityInformationAccess. It may also include\r\nimplementation-specific traffic for additional information sources as part of\r\nverification.\r\n\r\nImplementations SHOULD avoid leaking information that may identify the\r\nserver. Even when sent over an encrypted transport, such requests may result\r\nin indirect exposure of the server's identity, such as indicating a specific CA\r\nor service being used. To mitigate this risk, servers SHOULD deliver such\r\ninformation in-band when possible, such as through the use of OCSP stapling,\r\nand clients SHOULD take steps to minimize or protect such requests during\r\ncertificate validation.\r\n```",
              "createdAt": "2019-07-03T16:05:44Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzIxMjIw",
          "commit": {
            "abbreviatedOid": "544ba89"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T20:32:29Z",
          "updatedAt": "2019-07-03T20:32:30Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Generalizing this is a great idea, and your suggested text looks good. I'll use it. ",
              "createdAt": "2019-07-03T20:32:30Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzI3MDI3",
          "commit": {
            "abbreviatedOid": "f09381d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T20:46:18Z",
          "updatedAt": "2019-07-03T20:46:19Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "@sleevi -- updated. Thanks!",
              "createdAt": "2019-07-03T20:46:19Z",
              "updatedAt": "2019-07-03T20:46:19Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "22e62139a983958708e4fb6f3cf0d5043b54375c",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/ocsp",
      "headRefOid": "f09381dd10831296a8f7a155eb0dc11d912664b0",
      "mergeCommit": {
        "oid": "cb1c91658944a23938b51d4cd420ddb5a33f186b"
      }
    },
    {
      "number": 168,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MzI0MzMy",
      "title": "Clarify server HRR behavior, and add label-based workaround for nonce-reuse",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/168",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Since the client's ESNI key share doesn't change across CHs in response to a HRR, the same AEAD IV would be used to encrypt/decrypt two different messages. This is an attempt to fix that, while also specifying the server-side HRR behavior. (Basically, check that the ESNI contents have not changed.)",
      "createdAt": "2019-07-03T20:47:58Z",
      "updatedAt": "2019-07-08T21:55:51Z",
      "closedAt": "2019-07-08T21:55:51Z",
      "mergedAt": "2019-07-08T21:55:51Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice catch, Would it make more sense to instead use the KeyShare as a salt in the HKDF?",
          "createdAt": "2019-07-04T16:12:39Z",
          "updatedAt": "2019-07-04T16:12:39Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or you could include the handshake transcript up to, but not including, the ClientHello.  That is the empty string before HRR< but something else after.",
          "createdAt": "2019-07-08T00:24:10Z",
          "updatedAt": "2019-07-08T00:24:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Nice catch, Would it make more sense to instead use the KeyShare as a salt in the HKDF?\r\n\r\nThat is a little iffy with cookie-only HelloRetryRequests. Those don't change the ClientHello key shares list, so the client would derive the same key + nonce pair. The client would also use the same plaintext so it's fine, but it seems an unnecessarily fragility.",
          "createdAt": "2019-07-08T16:08:01Z",
          "updatedAt": "2019-07-08T16:08:01Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. I think I prefer the \"new DH\" version.",
          "createdAt": "2019-07-08T16:09:58Z",
          "updatedAt": "2019-07-08T16:09:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3ODI4NzEx",
          "commit": {
            "abbreviatedOid": "21c2dbe"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T05:03:18Z",
          "updatedAt": "2019-07-04T05:03:18Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "I agree that servers MUST verify the value of the ESNI extension, but the fields being required to be validated seems to differ from the the fields that are required to be consistent. Is there a reason for the two to be different?\r\n\r\nFWIW, \"Handling the server response\" section states as follows:\r\n> If the server sends a HelloRetryRequest in response to the ClientHello and the client can send a second updated ClientHello per the rules in {{RFC8446}}, the \"encrypted_server_name\" extension values which do not depend on the (possibly updated) KeyShareClientHello, i.e,, ClientEncryptedSNI.suite, ClientEncryptedSNI.key_share, and ClientEncryptedSNI.record_digest, MUST NOT change across ClientHello messages. Moreover, ClientESNIInner.nonce and ClientESNIInner.realSNI MUST not change across ClientHello messages. Informally, the values of all unencrypted extension information, as well as the inner extension plaintext, must be consistent between the first and second ClientHello messages.",
              "createdAt": "2019-07-04T05:03:18Z",
              "updatedAt": "2019-07-08T20:58:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MDY5MTcy",
          "commit": {
            "abbreviatedOid": "7ae2f15"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T14:17:36Z",
          "updatedAt": "2019-07-04T14:17:36Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "No reason -- just an oversight on my part. It should be fixed now!",
              "createdAt": "2019-07-04T14:17:36Z",
              "updatedAt": "2019-07-08T20:58:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MDcxMzQx",
          "commit": {
            "abbreviatedOid": "7ae2f15"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for the changes! LGTM.",
          "createdAt": "2019-07-04T14:22:07Z",
          "updatedAt": "2019-07-04T14:22:07Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4ec4cb4ee196a4cec35fdce9640bf86cc559bc2a",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hrr",
      "headRefOid": "ccb5b563caea6f84aa4c27c71bacb13836d7a8b0",
      "mergeCommit": {
        "oid": "393aa3301cda28b0d27e486ad595434d4b39a946"
      }
    },
    {
      "number": 169,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NzI5NTA3",
      "title": "Add note about SNI-only encryption key design.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/169",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #41.",
      "createdAt": "2019-07-05T04:24:05Z",
      "updatedAt": "2019-07-08T13:45:26Z",
      "closedAt": "2019-07-08T13:45:25Z",
      "mergedAt": "2019-07-08T13:45:25Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "cb1c91658944a23938b51d4cd420ddb5a33f186b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/alpn-note",
      "headRefOid": "0e51ecd9e9634fafd6d16127f0a889addc8e6af5",
      "mergeCommit": {
        "oid": "342840b5430948ffe709f5d665d63859edee2f67"
      }
    },
    {
      "number": 170,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NzMxMDE2",
      "title": "Drop fixed key_share requirement to avoid nonce reuse and better align with HPKE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/170",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is an alternative to #168, wherein we use fresh DH keys each time and avoid changing the key/iv derivation labels across CH messages.",
      "createdAt": "2019-07-05T04:33:31Z",
      "updatedAt": "2019-10-11T17:43:30Z",
      "closedAt": "2019-10-11T17:43:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ping @ekr @kazuho ",
          "createdAt": "2019-07-06T22:02:48Z",
          "updatedAt": "2019-07-06T22:02:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "IIUC, this is a trade-off issue. Therefore I do not have a strong preference, though my weak prerefence goes to keeping the design as-is. The reasons are as follows.\r\n\r\nThe benefit of the proposed change is that it frees client from buffering the content of the ESNI extension (after encryption), when using a building block that does not support reusing the same public key pair. Though, we might argue that even with this change, clients might still want to buffer the extension for possible retransmission rather than doing another public key operation in case of receiving a HRR.\r\n\r\nThe downside of the proposed change is that it might require the server to do another public key operation when verifying the ESNI extension found in ClientHello being sent in response to HelloRetryRequest. Current design, by requiring the keys to be identical, allows a server to validate the indifference of the ESNI extension without actually deciphering the payload.\r\n\r\nOne of the role of HRR is to mitigate attacks. When under attack, I believe that servers would be reluctant to do an additional public key operation. Therefore, to me it seems that the proposed change would incentivize the server to skip the verification of the ESNI extension sent in response to HRR.\r\n\r\nComparing the benefit and the downside, my weak preference goes to retaining the design as-is, because as I stated, I think that clients would be (mostly) fine with the design, and under the assumption that it is beneficial to encourage servers to validate the ESNI extension sent in response to HRR.",
          "createdAt": "2019-07-07T06:04:36Z",
          "updatedAt": "2019-07-07T06:18:50Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I share @kazuho's concerns.  The use of a different label after HRR is annoying, but not that difficult to manage.  You could also include the session transcript up to (but not including) the ClientHello, but you need something.\r\n\r\nFlipping the shares is a costly exercise.  You might have to do it anyway, but if you don't, then you can save some computation.  I can definitely see the value in stuffing the decrypted SNI into the cookie so that you don't have to redo the ESNI piece.",
          "createdAt": "2019-07-07T23:35:23Z",
          "updatedAt": "2019-07-07T23:35:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The benefit of this approach is primarily simplicity for clients and HPKE alignment. (HPKE generates a fresh key each time, so we couldn\u2019t adopt it as is unless that draft changed.) I agree that the cost of yet another DH operation is not great, though I\u2019m not yet convinced it\u2019s enough to disqualify this change.",
          "createdAt": "2019-07-07T23:46:03Z",
          "updatedAt": "2019-07-07T23:46:03Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm... I'm not sure I follow all of this.\r\n\r\nYou can't store the decrypted SNI in the cookie because you need to re-verify the AEAD which is tied to the new key share. You can of course stuff Z in the cookie, though, so I'm not sure how much difference this makes. With that said, in the common case (one server) you are going to have a uniform config so you don't need to decrypt ESNI at all in order to send HRR, no?\r\n\r\nAs @chris-wood says  this is tied to using HPKE -- if we decide to do that, we are going to either have to adopt a \"fresh DH\" version or extend the HPKE API to have some sort of key reuse + salt.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-07-07T23:46:48Z",
          "updatedAt": "2019-07-07T23:47:10Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood \r\n> The benefit of this approach is primarily simplicity for clients and HPKE alignment. (HPKE generates a fresh key each time, so we couldn\u2019t adopt it as is unless that draft changed.)\r\n\r\nI think our disagreement is if current provision deters the adoption of HPKE.\r\n\r\nI'm not familiar with HPKE and I could be wrong, but it is my understanding that the current design can use a public key crypto engine that uses a fresh key for every operation.\r\n\r\nThat is because the ESNI extension sent in the 2nd ClientHello is a \"retransmission.\" Server's public key pair does not change, and ClientHello.random does not change. Therefore, when sending the first ClientHello, a client can just keep the encrypted payload of ESNI extension. Then, when it receives a HelloRetryRequest, it would retransmit the buffered payload of the ESNI extension.",
          "createdAt": "2019-07-07T23:57:56Z",
          "updatedAt": "2019-07-07T23:57:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: I don't believe that this will work because the client's KeyShare will likely change in HRR, and it is AAD to the ESNI Extension, thus the ciphertext will change. Or am I confused?",
          "createdAt": "2019-07-08T00:02:59Z",
          "updatedAt": "2019-07-08T00:02:59Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr Ah I missed that (and picotls has a bug!). Thank you for pointing that out.\r\n\r\nThat said, I think that the @martinthomson's argument (which was also the rest of my argument) still holds. If we want servers to verify the ESNI extension sent in the 2nd ClientHello, it is benefical to require the clients to use the same public key.\r\n\r\nBecause, then, a server can retain the key and iv (either in it's state or in Cookie), and just do the AEAD operation to validate the ESNI extension found in the 2nd ClientHello. If we think that such check can be avoided (even though we would not encourage that), I think I'd be fine with allowing the client to change the public key.",
          "createdAt": "2019-07-08T00:09:26Z",
          "updatedAt": "2019-07-08T00:09:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho nitpicking: you will need to retain Z, I think.\r\n\r\nWith that said, how do you think we would handle the transition to HPKE?",
          "createdAt": "2019-07-08T00:17:10Z",
          "updatedAt": "2019-07-08T00:17:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho @grittygrease how do you want to proceed here?",
          "createdAt": "2019-07-08T17:29:57Z",
          "updatedAt": "2019-07-08T17:29:57Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(This comment ended up long, so I'm splitting it into sections.)\r\n\r\n**Why check the second ClientHello**\r\n\r\n> If we think that such check can be avoided (even though we would not encourage that), I think I'd be fine with allowing the client to change the public key.\r\n\r\nIf the server does not check the second ClientHello, then cut-and-paste attacks are possible against client/server pairs which hit HelloRetryRequest because we lose the binding between ESNI and the key shares that were actually used. (It really would be cleaner if we just stuffed something into the key schedule, but then the client needs to trial-decrypt or we need a cleartext \"yes, I used ESNI\" signal.)\r\n\r\nFor completeness, deployments which allow different services to have different version, cipher, or group preferences need to process ESNI on the first ClientHello because resolving HRR requires those preferences. Of course, services with different preferences will partition the anonymity sets a little bit, but enough deployments expect to be able to vary TLS parameters this way that I think we need to allow for this. (BoringSSL, for instance, resolves SNI on the first ClientHello.)\r\n\r\n**Split mode**\r\n\r\nOn that note, split mode and HRR are a little messy. Possibilities I can see:\r\n\r\n1. Dispatch happens at second ClientHello. Frontend and backend must agree on HRR-sensitive parameters, and backend gets a handshake transcript from the frontend.\r\n2. Dispatch happens at first ClientHello, but frontend and backend agree on enough of TLS parameters that frontend can sniff HelloRetryRequest + second ClientHello (technically a [protocol invariant](https://tools.ietf.org/html/rfc8446#section-9.3) violation) to check the ESNI.\r\n3. Backend and frontend both have ESNI keys. This contradicts #169.\r\n\r\n**Near-attack**\r\n\r\nFinally, I think there's one more issue here with changing the key share which, while not fatal, is rather a headache. Suppose we went with this PR. Here is a near-attack:\r\n\r\n1. Attacker observes an ESNI-ful HRR-ful connection. Let CH1 and CH2 be the first and second ClientHellos.\r\n2. Attacker wants to determine if CH1/CH2's ESNI contained hostname H. (It can repeat this process with different guesses.)\r\n3. Attacker makes a connection to the server. It replays CH1 and gets an HRR.\r\n4. Attacker sends its own second ClientHello with its own key shares and an ESNI record containing H.\r\n5. If H matched CH1's ESNI, the server will accept the connection and continue. If it mismatched, the server will fail with an alert.\r\n\r\nThis is only a near-attack because ClientESNIInner contains a nonce the attacker cannot guess, so even if it matched the hostname, it cannot match the nonce. But this means the server must perform the comparison in constant-time (attacker can repeat steps 3-5 all it wants) and the nonce is even more load-bearing in a subtle way.\r\n\r\nExample of subtlety: In both \"server must check CH2\" PRs, it is easy for the server to ignore it and no one notices. One could imagine saying the ESNI nonce must change in CH2, so the server *at least* doesn't ignore it. But that would turn this near-attack into an actual attack. Whereas I believe the same-key version avoids all of this.\r\n\r\n**Changing the key schedule**\r\n\r\nIt seems we're in this mess because we've bound ESNI to the handshake in a roundabout way rather than injecting the key into the key schedule. I believe this originally was to aid split mode, but we've since added this nonce anyway, so having frontend pass the key schedule addition into the backend is plausible. Perhaps this is worth reconsidering? Some thoughts:\r\n\r\nFirst, there isn't a slot in the key schedule for this. I think that's fine though, as long as we change the label. Here's one possibility:\r\n\r\n```\r\n             0\r\n             |\r\n             v\r\n   PSK ->  HKDF-Extract = Early Secret\r\n             |\r\n             +-----> Derive-Secret(...)\r\n             |                     = binder_key\r\n             |                     = client_early_traffic_secret\r\n             |                     = early_exporter_master_secret\r\n             v\r\n       Derive-Secret(., \"derived\", \"\")\r\n             |\r\n             v\r\n   (EC)DHE -> HKDF-Extract\r\n             |\r\n             v\r\n       Derive-Secret(., \"esni nonce\", \"\")\r\n             |\r\n             v\r\nESNI nonce -> HKDF-Extract = Handshake Secret\r\n             |\r\n             +-----> Derive-Secret(...)\r\n             |                     = client_handshake_traffic_secret\r\n             |                     = server_handshake_traffic_secret\r\n             v\r\n            ...\r\n ```\r\n(Arguably all the \"derived\" labels should have had names.)\r\n\r\nThe second issue is how to signal it on the client. I see two options:\r\n\r\n1. Cleartext signal in ServerHello. This violates \"do not stick out\" and makes the GREASE extensions totally useless.\r\n2. The client computes both server_handshake_traffic_secret values and trial-decrypts to figure out which one to use. This is trial decryption and non-destructive trial-decryption at that, so it's rather a headache. (On the plus side, it only needs to be done on the first handshake record.)\r\n\r\nNeither of these is very satisfactory but, then again, nor are our other two options. :-/\r\n\r\n**Conclusion**\r\n\r\nEverything is a mess.",
          "createdAt": "2019-07-08T20:38:58Z",
          "updatedAt": "2019-07-08T20:38:58Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood \r\n> how do you want to proceed here?\r\n\r\nAs we do not have time, I think we should merge #168 (it does not change the client behavior, and I think we agree that requiring the server to validate the ESNI extension found in 2nd CH is a good idea), while keeping this PR open for further discussion.",
          "createdAt": "2019-07-08T21:53:20Z",
          "updatedAt": "2019-07-08T21:53:20Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "cb1c91658944a23938b51d4cd420ddb5a33f186b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hrr-fresh-esni-key",
      "headRefOid": "8cf067d5ab8bd7d5621e50aa6991c6c6e4a94552",
      "mergeCommit": null
    },
    {
      "number": 172,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk5NTc4MDQ0",
      "title": "Fix typo in text for ClientEncryptedSNI.key_share",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/172",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-20T17:11:49Z",
      "updatedAt": "2019-07-23T19:43:24Z",
      "closedAt": "2019-07-23T19:43:24Z",
      "mergedAt": "2019-07-23T19:43:24Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you!",
          "createdAt": "2019-07-23T19:43:18Z",
          "updatedAt": "2019-07-23T19:43:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1NjM0Mzcw",
          "commit": {
            "abbreviatedOid": "112f9db"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-23T19:43:11Z",
          "updatedAt": "2019-07-23T19:43:11Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "393aa3301cda28b0d27e486ad595434d4b39a946",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "112f9db180f50c7f95ef6af40f1f95aecdf692cb",
      "mergeCommit": {
        "oid": "ddf3111a618bcda8791ced99aa7c87a90f165165"
      }
    },
    {
      "number": 174,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwMDg0NTI2",
      "title": "Remove `sni` reference from padded server name list",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/174",
      "state": "MERGED",
      "author": "mrsylerpowers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "#173 ",
      "createdAt": "2019-07-23T00:18:57Z",
      "updatedAt": "2019-07-23T19:42:54Z",
      "closedAt": "2019-07-23T19:42:54Z",
      "mergedAt": "2019-07-23T19:42:54Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1NjMzNjAy",
          "commit": {
            "abbreviatedOid": "971f231"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-23T19:41:46Z",
          "updatedAt": "2019-07-23T19:41:46Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "393aa3301cda28b0d27e486ad595434d4b39a946",
      "headRepository": "mrsylerpowers/draft-ietf-tls-esni",
      "headRefName": "sni-reference-remove",
      "headRefOid": "971f2318b74f06164fb3bd11ec84815d474896c2",
      "mergeCommit": {
        "oid": "aed9ec47295529ab9188a1deb6230175fcba912d"
      }
    },
    {
      "number": 175,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwMTA3MTU3",
      "title": "refer GREASE extension in resolution algorithm & formatting fix",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/175",
      "state": "CLOSED",
      "author": "gsamat",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I referred GREASE extensions in 4.2.2 Resolution algorithm to make it in line with 5.1.4. GREASE extensions\r\n\r\nalso fixed 4.2.2. Resolution algorithm formatting issue: line width > 72 resulted in ugly PDF",
      "createdAt": "2019-07-23T02:45:29Z",
      "updatedAt": "2019-11-04T20:36:07Z",
      "closedAt": "2019-11-04T20:36:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR no longer applies since this section of the document was removed.",
          "createdAt": "2019-11-04T20:36:06Z",
          "updatedAt": "2019-11-04T20:36:06Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "393aa3301cda28b0d27e486ad595434d4b39a946",
      "headRepository": "gsamat/draft-ietf-tls-esni",
      "headRefName": "patch-4",
      "headRefOid": "6c2c02346626ea88ee36f84018ac4e603b9f6202",
      "mergeCommit": null
    },
    {
      "number": 176,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwNzQzNTc0",
      "title": "Clarify that ESNIContents is not transmitted",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/176",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I got a little tripped up on this point! Maybe you have a better way to explain it.",
      "createdAt": "2019-07-24T14:11:10Z",
      "updatedAt": "2019-10-25T17:57:20Z",
      "closedAt": "2019-10-25T17:57:20Z",
      "mergedAt": "2019-10-25T17:57:20Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @dmcardle!",
          "createdAt": "2019-10-25T17:57:15Z",
          "updatedAt": "2019-10-25T17:57:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzYyNzQ5",
          "commit": {
            "abbreviatedOid": "483ca96"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T17:57:07Z",
          "updatedAt": "2019-10-25T17:57:07Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ddf3111a618bcda8791ced99aa7c87a90f165165",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "dmcardlebranch",
      "headRefOid": "483ca96533d05ce9c05f1a7ada5c91adde8946ed",
      "mergeCommit": {
        "oid": "6ade68ed92984b283ddf1b0834e452431688c903"
      }
    },
    {
      "number": 181,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1ODA0MTEy",
      "title": "editorial nits",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/181",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Credits to @huitema.",
      "createdAt": "2019-08-09T01:34:27Z",
      "updatedAt": "2019-08-09T17:40:40Z",
      "closedAt": "2019-08-09T17:40:40Z",
      "mergedAt": "2019-08-09T17:40:39Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyOTE1Njk5",
          "commit": {
            "abbreviatedOid": "a1da8a7"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-09T02:02:13Z",
          "updatedAt": "2019-08-09T02:02:17Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nindication would divulge the true server name.\r\n```",
              "createdAt": "2019-08-09T02:02:14Z",
              "updatedAt": "2019-08-09T03:33:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczMjczNjUz",
          "commit": {
            "abbreviatedOid": "e2eb0d8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-09T17:40:32Z",
          "updatedAt": "2019-08-09T17:40:32Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ddf3111a618bcda8791ced99aa7c87a90f165165",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/editorial",
      "headRefOid": "e2eb0d8b0e1d8febafe4b84d9f7f9ffd4cca5406",
      "mergeCommit": {
        "oid": "9e54d3572c171a65e522a3a045907282a046843e"
      }
    },
    {
      "number": 184,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI2NzI5MDAx",
      "title": "Add description about \"cipher suites\" via an ESNIKeys extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/184",
      "state": "MERGED",
      "author": "pengin7384",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add missing description for cipher_suites and add colon symbol to padded_length",
      "createdAt": "2019-10-10T13:12:22Z",
      "updatedAt": "2020-02-23T13:51:59Z",
      "closedAt": "2020-02-23T13:51:59Z",
      "mergedAt": "2020-02-23T13:51:59Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDk2Mzcx",
          "commit": {
            "abbreviatedOid": "8a9cace"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-23T13:51:54Z",
          "updatedAt": "2020-02-23T13:51:54Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9e54d3572c171a65e522a3a045907282a046843e",
      "headRepository": "pengin7384/draft-ietf-tls-esni",
      "headRefName": "encrypted-sni-record-patch",
      "headRefOid": "8a9cacebaf6910688743d794ef8469e3679c08b6",
      "mergeCommit": {
        "oid": "80df23129af22ea6846b7f2dfe1efe2e371892d0"
      }
    },
    {
      "number": 185,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI4ODk3MzAw",
      "title": "Remove partial split mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/185",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Based on comments in Montreal, I believe that the authors\r\nno longer intend to document the partial-split configuration.",
      "createdAt": "2019-10-16T18:30:25Z",
      "updatedAt": "2019-10-25T19:01:36Z",
      "closedAt": "2019-10-25T19:01:36Z",
      "mergedAt": "2019-10-25T19:01:36Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzY0MjAz",
          "commit": {
            "abbreviatedOid": "8e7113d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-10-25T17:59:47Z",
          "updatedAt": "2019-10-25T17:59:57Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Is this always true? Might the provider have access in shared mode?",
              "createdAt": "2019-10-25T17:59:47Z",
              "updatedAt": "2019-10-25T17:59:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3Mzk0ODkz",
          "commit": {
            "abbreviatedOid": "8e7113d"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T19:00:03Z",
          "updatedAt": "2019-10-25T19:00:04Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This paragraph is only about split mode (and this sentence is unchanged).",
              "createdAt": "2019-10-25T19:00:03Z",
              "updatedAt": "2019-10-25T19:00:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3Mzk1NTc4",
          "commit": {
            "abbreviatedOid": "8e7113d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T19:01:25Z",
          "updatedAt": "2019-10-25T19:01:26Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Oh, hah, yes. That\u2019s what I get for skimming. ",
              "createdAt": "2019-10-25T19:01:25Z",
              "updatedAt": "2019-10-25T19:01:26Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9e54d3572c171a65e522a3a045907282a046843e",
      "headRepository": "bemasc/draft-ietf-tls-esni",
      "headRefName": "bemasc-partial-split",
      "headRefOid": "8e7113d0204805c3e29cc1ef84e9fa041457ecd5",
      "mergeCommit": {
        "oid": "5abba83633afe4dc15e57a976dcd93be5119447b"
      }
    },
    {
      "number": 186,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxNjI3MjA3",
      "title": "Proposal: Use a hash instead of padding",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/186",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is (almost) entirely compatible with wildcard names\r\nand avoids the need for padding.",
      "createdAt": "2019-10-23T16:05:42Z",
      "updatedAt": "2019-10-23T20:22:36Z",
      "closedAt": "2019-10-23T20:22:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do not think this change is worth the complexity. First, it does not avoid the need for padding. The server certificate needs to be padded regardless, so the server already needs to make decisions based on the length distributions of known hostnames.\r\n\r\nSecond, it dramatically increases the complexity of deploying ESNI. In the existing design, the actual certificate lookup on the server is relatively unchanged. The TLS library could even abstract much of the name lookup, public name fallback, etc., from the application by simply passing the name along the same interface as before and leave that portion unchanged. This design forces the server to have a new digest-based path, which extends throughout the entire configuration pipeline.\r\n\r\nThe `label_limit` notion for dealing with wildcards is also another source of stateful deployment problems with configuration mismatches. Perhaps I used to use a wildcard cert, but now I'd like to switch to individual subdomains. This transition is difficult under this PR. For more fun, the folks managing the names may be different from the folks who implemented ESNI, so the deployment concern will go unnoticed.\r\n\r\nThe wildcard cert scheme is also messy with protocols that do not have their own in-band vhosting mechanism and just use TLS. HTTP doesn't care about HTTP has a Host header, so it doesn't actually care about the SNI. (I will observe, however, that the Host header should probably trigger padding too, so we're still back to square one. :-) )",
          "createdAt": "2019-10-23T16:42:59Z",
          "updatedAt": "2019-10-23T16:42:59Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, deployment is more complex in this mode.  I'm going to close this to avoid creating ongoing confusion; I just wanted to remind people that there are other options beyond debates about padding length, and we shouldn't be too quick to adopt a leaky padding scheme for the sake of handshake size.",
          "createdAt": "2019-10-23T20:22:35Z",
          "updatedAt": "2019-10-23T20:22:35Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9e54d3572c171a65e522a3a045907282a046843e",
      "headRepository": "bemasc/draft-ietf-tls-esni",
      "headRefName": "bemasc-hash",
      "headRefOid": "33f2537c2c47ed2c2110ff840fc6f82fa2d3c048",
      "mergeCommit": null
    },
    {
      "number": 187,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyMjkyNDY4",
      "title": "Replace ESNIKeys with ESNIConfig, and delegate the publishing container to HTTPSVC.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/187",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "DNSOP adopted HTTPSSVC recently [1]. This is a generalized Resource Record that supports the same functionality as the custom ESNI RRType, including direct IP address specification and ENSI key delivery. This change drops the custom DNS bits from the ESNI document and delegates this to HTTPSSVC, where it probably belongs. This change also renames ESNIKeys to ESNIConfig to more accurately capture its intended purpose, i.e., as a struct for conveying ESNI keys and metadata.\r\n\r\nThis should address #180, #179, #139, and #110.\r\n\r\n[1] https://mailarchive.ietf.org/arch/msg/dnsop/9zCxhCfIhDzA3Cv3D2k4NF_nj4s",
      "createdAt": "2019-10-25T00:24:16Z",
      "updatedAt": "2019-11-02T01:01:45Z",
      "closedAt": "2019-11-02T01:01:45Z",
      "mergedAt": "2019-11-02T01:01:45Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure that this is going to work with HTTPSSVC as currently defined. The current ESNIKeys record specifies the IP address explicitly and you are supposed to favor that. However, assuming I am reading HTTPSSVC S 6.4 correctly, ipv[46]hint are not in fact favored but are actually disfavored.\r\n\r\n  \"The \"ipv4hint\" and \"ipv6hint\" keys represent IP address hints for the\r\n   service.  If A and AAAA records for SvcDomainName are locally\r\n   available, the client SHOULD ignore these hints.  Otherwise, clients\r\n   MUST perform A and/or AAAA queries for SvcDomainName as in Section 3,\r\n   and clients SHOULD switch to an IP address in those records as soon\r\n   as possible.\"\r\n\r\nThis is counter to what we agreed upon for ESNI and resurrects the A/AAAA vs. ESNIKeys mismatch problem. \r\n\r\nUnless I am misunderstanding this, we should first fix HTTPSSVC before making this change.\r\n\r\n\r\n",
          "createdAt": "2019-10-25T16:34:42Z",
          "updatedAt": "2019-10-25T16:34:42Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the intent with HTTPSSVC is that, if you're using the HTTPSSVC record, you'd look up A/AAAA from the SvcDomainName not the origin name you queried. That way there's still a binding between A/AAAA and ESNIKeys.\r\n\r\nThis does, however, cost an extra DNS round-trip, so this plan does require the recursive resolvers follow HTTPSSVC for you like they do CNAME, otherwise it would not meet the performance requirements. DoT/DoH are an ecosystem reset, so maybe that's plausible? I think this goes back to how sacred you believe A and AAAA are and whether you believe it's rude to get IP addresses elsewhere. The HTTPSSVC record evidently has different views on this point than the ESNI record.",
          "createdAt": "2019-10-25T17:16:52Z",
          "updatedAt": "2019-10-25T17:16:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is counter to what we agreed upon for ESNI and resurrects the A/AAAA vs. ESNIKeys mismatch problem.\r\n\r\nI would choose to interpret their \"SHOULD ignore\" advice as optional to ensure the ESNIRecord functionality is maintained. @bemasc, perhaps we can clarify this in the HTTPSVC draft?",
          "createdAt": "2019-10-25T17:20:52Z",
          "updatedAt": "2019-10-25T17:20:52Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think the intent with HTTPSSVC is that, if you're using the HTTPSSVC record, you'd look up A/AAAA from the SvcDomainName not the origin name you queried. That way there's still a binding between A/AAAA and ESNIKeys.\r\n\r\nYep, that's exactly right.\r\n\r\n> I would choose to interpret their \"SHOULD ignore\" advice as optional to ensure the ESNIRecord functionality is maintained.\r\n\r\nI'm not sure I understand you.  The purpose of \"SHOULD ignore\" is to ensure that DNS-based load balancing of A/AAAA on SvcDomainName continues to work correctly.  Whether the client uses an ipv6hint or a AAAA record for SvcDomainName, it will be contacting a server that has the corresponding ESNI private key; there's no possibility of mismatch either way.\r\n\r\n> perhaps we can clarify this in the HTTPSVC draft?\r\n\r\nI think the confusion here is that in HTTPSSVC, clients use the IP of SvcDomainName, not the IP of the origin hostname.  There's no way for a client to accidentally combine the ESNIConfig for the SvcDomainName with the IP of the origin hostname (or of a different SvcDomainName).\r\n\r\nI think the draft is pretty clear on this point (e.g. the [intro example](https://tools.ietf.org/html/draft-nygren-dnsop-svcb-httpssvc-00#section-1.1)), but the authors always think that :).  Suggestions are welcome.",
          "createdAt": "2019-10-25T17:49:56Z",
          "updatedAt": "2019-10-25T17:49:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, so as @davidben points out, this requires a second resolution, which is a performance problem.",
          "createdAt": "2019-10-25T17:53:04Z",
          "updatedAt": "2019-10-25T17:53:04Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, waiting for a second resolution is the performance problem that ipv6hint solves, by giving the client an IP address along with the ESNIConfig in the same response.",
          "createdAt": "2019-10-25T18:13:19Z",
          "updatedAt": "2019-10-25T18:13:19Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc: then I just don't see the point of doing the second resolution. It seems disruptive and doesn't add anything. Once I have connected to the server, it can Alt-Svc me itself.",
          "createdAt": "2019-10-25T18:25:43Z",
          "updatedAt": "2019-10-25T18:25:43Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I should add, I'm not quite sure how I would implement this in Firefox. Say I resolve example.com and get 1.2.3.4 for ipv4 hints. Now I am supposed to in parallel connect to the server *and* try to resolve SvcDomainName? But what then? I've already started the connection so I'm not going to abort it if I get a 5.6.7.8....",
          "createdAt": "2019-10-25T18:35:51Z",
          "updatedAt": "2019-10-25T18:35:51Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I just don't see the point of doing the second resolution. It seems disruptive and doesn't add anything.\r\n\r\nConsider a CDN customer with their own (old-fashioned, static) DNS.  The customer publishes an HTTPSSVC record whose SvcDomainName, ESNIConfig, and IP hint are the CDN's domain, ESNIConfig, and IP.  Clients connect to the IP from the hint, use this ESNIConfig, and everything works ... but the customer has broken the CDN's load balancing.  All of their traffic is going to a single  CDN IP.\r\n\r\nThe point of the second resolution is to move customer traffic onto the CDN's preferred IP.\r\n\r\n> Once I have connected to the server, it can Alt-Svc me itself.\r\n\r\nTrue, but HTTPSSVC doesn't require clients to support Alt-Svc.  (Chrome, for example, does not support this feature of Alt-Svc.)\r\n\r\n> Say I resolve example.com and get 1.2.3.4 for ipv4 hints. Now I am supposed to in parallel connect to the server and try to resolve SvcDomainName? But what then? I've already started the connection so I'm not going to abort it if I get a 5.6.7.8....\r\n\r\nThe draft says clients \"SHOULD switch to an IP address in those records as soon as possible\".  An aggressive implementation might start connecting to 5.6.7.8, and close the connection to 1.2.3.4 once it is connected.  (This is roughly what Chrome does for QUIC upgrade.)  A less aggressive implementation might just let the A record sit in the local DNS cache, so that any subsequent connections to this origin can go to the CDN's preferred IP.",
          "createdAt": "2019-10-25T18:49:33Z",
          "updatedAt": "2019-10-25T18:49:33Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, so I think that this text needs a bunch of work before I would be comfortable with it, as I do not think your \"less aggressive implementation\" would be conformant with this SHOULD",
          "createdAt": "2019-10-25T18:51:03Z",
          "updatedAt": "2019-10-25T18:51:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr if that\u2019s the case, can you please suggest concrete changes to the text?",
          "createdAt": "2019-10-25T18:56:15Z",
          "updatedAt": "2019-10-25T18:56:15Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc is there some place I can send a PR?\n\nOn Fri, Oct 25, 2019 at 11:56 AM Christopher Wood <notifications@github.com>\nwrote:\n\n> @ekr <https://github.com/ekr> if that\u2019s the case, can you please suggest\n> concrete changes to the text?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/187?email_source=notifications&email_token=AAIPLIPSWDOAN7SHH24S3V3QQM6NBA5CNFSM4JE5AOYKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECJIAHA#issuecomment-546471964>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLINOF65ZGCXUMO47AOTQQM6NBANCNFSM4JE5AOYA>\n> .\n>\n",
          "createdAt": "2019-10-25T19:57:35Z",
          "updatedAt": "2019-10-25T19:57:35Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr yes, https://github.com/MikeBishop/dns-alt-svc/pulls",
          "createdAt": "2019-10-25T20:17:25Z",
          "updatedAt": "2019-10-25T20:17:25Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/MikeBishop/dns-alt-svc/pull/69\n\nOn Fri, Oct 25, 2019 at 1:17 PM Benjamin M. Schwartz <\nnotifications@github.com> wrote:\n\n> @ekr <https://github.com/ekr> yes,\n> https://github.com/MikeBishop/dns-alt-svc/pulls\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/187?email_source=notifications&email_token=AAIPLIIH2PM4BPFJCBSGKBTQQNH5PA5CNFSM4JE5AOYKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECJOJFY#issuecomment-546497687>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIO5B7V7QND6ZZZB5MDQQNH5PANCNFSM4JE5AOYA>\n> .\n>\n",
          "createdAt": "2019-10-25T20:44:09Z",
          "updatedAt": "2019-10-25T20:44:09Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, the new text has been merged, so I am now OK with this PR.\n\nOn Fri, Oct 25, 2019 at 1:43 PM Eric Rescorla <ekr@rtfm.com> wrote:\n\n> https://github.com/MikeBishop/dns-alt-svc/pull/69\n>\n> On Fri, Oct 25, 2019 at 1:17 PM Benjamin M. Schwartz <\n> notifications@github.com> wrote:\n>\n>> @ekr <https://github.com/ekr> yes,\n>> https://github.com/MikeBishop/dns-alt-svc/pulls\n>>\n>> \u2014\n>> You are receiving this because you were mentioned.\n>> Reply to this email directly, view it on GitHub\n>> <https://github.com/tlswg/draft-ietf-tls-esni/pull/187?email_source=notifications&email_token=AAIPLIIH2PM4BPFJCBSGKBTQQNH5PA5CNFSM4JE5AOYKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECJOJFY#issuecomment-546497687>,\n>> or unsubscribe\n>> <https://github.com/notifications/unsubscribe-auth/AAIPLIO5B7V7QND6ZZZB5MDQQNH5PANCNFSM4JE5AOYA>\n>> .\n>>\n>\n",
          "createdAt": "2019-10-25T21:07:46Z",
          "updatedAt": "2019-10-25T21:07:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTYzODUy",
          "commit": {
            "abbreviatedOid": "2daa3df"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T03:14:11Z",
          "updatedAt": "2019-10-25T03:14:40Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\npublication details to {{!HTTPSSVC=I-D.nygren-dnsop-svcb-httpssvc}}, though other delivery\r\n```",
              "createdAt": "2019-10-25T03:14:11Z",
              "updatedAt": "2019-10-25T21:08:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzQyMjA0",
          "commit": {
            "abbreviatedOid": "d0eaef9"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T17:18:04Z",
          "updatedAt": "2019-10-25T17:18:19Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Nit: s/retry_keys/retry_configs/",
              "createdAt": "2019-10-25T17:18:05Z",
              "updatedAt": "2019-10-25T21:08:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzQyNjg0",
          "commit": {
            "abbreviatedOid": "d0eaef9"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T17:19:02Z",
          "updatedAt": "2019-10-25T17:19:02Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Benefit of the ESNIConfig rename: really `retry_keys` should have been `retry_keyses`, but now we don't have to pretend to be Gollum. :-)",
              "createdAt": "2019-10-25T17:19:02Z",
              "updatedAt": "2019-10-25T21:08:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NDI3MTk5",
          "commit": {
            "abbreviatedOid": "d0eaef9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T20:09:00Z",
          "updatedAt": "2019-10-25T20:09:00Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5abba83633afe4dc15e57a976dcd93be5119447b",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/httpsvc",
      "headRefOid": "160dd9085c9ec730c7845fa6d74836b1739a645f",
      "mergeCommit": {
        "oid": "6457893d8614fe47f3e8365957985ec848d754b0"
      }
    },
    {
      "number": 194,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2NDY4NzMz",
      "title": "Add note about inconsistent cryptographic configurations.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/194",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #178.",
      "createdAt": "2019-11-04T20:45:17Z",
      "updatedAt": "2019-11-04T21:40:59Z",
      "closedAt": "2019-11-04T21:40:59Z",
      "mergedAt": "2019-11-04T21:40:59Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMzU3OTg0",
          "commit": {
            "abbreviatedOid": "371cf44"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T21:06:12Z",
          "updatedAt": "2019-11-04T21:06:22Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nthe contents of the ServerHello as this message is not encrypted.\r\n```  ",
              "createdAt": "2019-11-04T21:06:13Z",
              "updatedAt": "2019-11-04T21:07:29Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6457893d8614fe47f3e8365957985ec848d754b0",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/crypto-consistency",
      "headRefOid": "fdf6d5a3e259e555922dad7064d116965fee626f",
      "mergeCommit": {
        "oid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1"
      }
    },
    {
      "number": 195,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2NTEzNjg3",
      "title": "Clarify rules on order and repetition for ESNIConfig extensions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/195",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Followup on #183.\r\n\r\nLooks like ESNIConfig is the only ESNI structure that has extensions, now that we've delegated the key delivery to HTTPSSVC.\r\n\r\nShould I avoid reflowing the text?",
      "createdAt": "2019-11-04T22:38:32Z",
      "updatedAt": "2020-02-23T13:51:20Z",
      "closedAt": "2020-02-23T13:51:19Z",
      "mergedAt": "2020-02-23T13:51:19Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDk2MzAy",
          "commit": {
            "abbreviatedOid": "fdc917f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-23T13:51:01Z",
          "updatedAt": "2020-02-23T13:51:01Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "esniconfig-httpssvc-changes",
      "headRefOid": "fdc917ff8d9fb4d6a6c25062339adc444948bb48",
      "mergeCommit": {
        "oid": "9024e205e2b7f151c49882e49803f4486fa6d042"
      }
    },
    {
      "number": 196,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2OTIzOTM2",
      "title": "Tunnel version",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/196",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-05T18:29:17Z",
      "updatedAt": "2020-03-08T00:32:23Z",
      "closedAt": "2020-03-08T00:32:22Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I haven't looked at this in full detail yet, but one initial comment is that encrypting an entire ClientHello means doubling the size, and [post-quantum key shares](https://www.imperialviolet.org/2019/10/30/pqsivssl.html) are looking to be quite large. I believe [one of our experiments](https://www.imperialviolet.org/2018/04/11/pqconftls.html) suggested the additional cost is roughly linear to the number of bytes.\r\n\r\nWe could encrypt some sort of \"delta ClientHello\", either saying \"copy these extensions from the outside\" or something hilarious scheme where you specify a sequence of new bytes and references into your outer ClientHello... (I think the former is easier to send while the latter is easier to receive.)\r\n\r\nAnother thought, though it requires a side channel from frontend to backend, is the `ClientHelloInner` omits `key_shares` in favor of a new `key_shares_hashed` extension where you insert `SHA256(ClientHelloOuter.key_shares)` for transcript purposes. The receiver then asserts the hash matches and pretends you included `ClientHelloOuter.key_shares` in `ClientHelloInner` for handshake purposes.",
          "createdAt": "2019-11-05T23:43:29Z",
          "updatedAt": "2019-11-05T23:43:29Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, one big drawback here is clearly the size, and yeah, PQ makes that worse.\r\n\r\nWith that said, it seems like you could potentially ameliorate this by only including classical KeyShares in ClientHelloOuter. The rationale here would be that the only purpose of ClientHelloOuter is to enable the fallback handshake, and so those keys are just protecting the SNI (and ESNIConfig, but that's just there to protect SNI), and we could potentially live with that being non-quantum-safe, especially if we're not going to use PQ algorithms for ESNI encryption. And of course if we *do* use PQ algorithms for ESNI encryption, then the overhead of the second CH is only about 1/2 as opposed to double.\r\n\r\n\r\n\r\n",
          "createdAt": "2019-11-05T23:48:47Z",
          "updatedAt": "2019-11-05T23:48:47Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Wouldn't that would negate the point of GREASE? ClientHellos advertising ESNI would have large ciphertext and classical-only outer key shares, while ClientHellos not advertising ESNI would include the PQ outer key shares (and probably send a small GREASE extension ton compensate).",
          "createdAt": "2019-11-06T00:00:05Z",
          "updatedAt": "2019-11-06T00:00:05Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, that's true. I think I'd be willing to live with that tradeoff but\nperhaps others would not.\n\nOn Tue, Nov 5, 2019 at 4:00 PM David Benjamin <notifications@github.com>\nwrote:\n\n> Wouldn't that would negate the point of GREASE? ClientHellos advertising\n> ESNI would have large ciphertext and classical-only outer key shares, while\n> ClientHellos not advertising ESNI would include the PQ outer key shares\n> (and probably send a small GREASE extension ton compensate).\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/196?email_source=notifications&email_token=AAIPLIIXQ7PURA5TEIE2ETLQSICINA5CNFSM4JJGLDW2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEDEYQ7Y#issuecomment-550078591>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIOIH23TNN2NC7ODZLLQSICINANCNFSM4JJGLDWQ>\n> .\n>\n",
          "createdAt": "2019-11-06T00:01:47Z",
          "updatedAt": "2019-11-06T00:01:47Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The size-doubling issue could be addressed through the use of compression.  If the inner and outer values are the same, then the inner could just reference the outer (and the removal of encryption could also include expansion).",
          "createdAt": "2019-11-06T00:52:48Z",
          "updatedAt": "2019-11-06T00:52:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "By compression (or reusing stuff), doesn't the proposal become closer to the ESNI transformation design that we have been talking in https://github.com/kazuho/draft-rescorla-tls-esni/pull/1?",
          "createdAt": "2019-11-06T01:50:01Z",
          "updatedAt": "2019-11-06T01:50:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson Yeah, compression was what I was referring with \"delta ClientHello\". You could imagine a ClientHello-specific compression that knows how to toss extensions around (in which case, yeah, it starts getting closer to ESNI transformation), or some more generic delta encoding. Here's an ad hoc goofy thing:\r\n\r\n```\r\nenum { bytes(0), reference(1) } FragmentType;\r\n \r\nstruct {\r\n  uint24 offset;\r\n  uint24 length;\r\n} ReferenceFragment;\r\n \r\nopaque BytesFragment<1..2^24-1>;\r\n \r\nstruct {\r\n  FragmentType type;\r\n  select (Fragment.type) {\r\n    // Append these bytes.\r\n    case bytes: BytesFragment;\r\n    // Append the referenced fragment of the outer ClientHello.\r\n    case reference: ReferenceFragment;\r\n  }\r\n} Fragment;\r\n \r\nstruct {\r\n  // Included so preallocating the buffer and enforcing size limits is easy.\r\n  uint24 clienthello_length;\r\n  // Walk over all the fragments to reconstruct the ClientHello.\r\n  Fragment clienthello_fragments<0..2^24-1>;\r\n} ESNIPlaintext;\r\n```\r\n\r\nA ClientHello-specific encoding is easier to produce since senders know how their ClientHellos look like and we can tailor things what fields should and shouldn't be copied. But it's harder to decode since you need to add checks for silly questions like \"what order do I insert extensions?\" or \"what happens if the placeholder is missing\" or \"what happens if there are two placeholders?\" or \"what happens if the outer ClientHello is missing the extension to copy?\".\r\n\r\nConversely, though it may take more spec text to describe, a bytes-based encoding is easier to decode since you just blindly evaluate the two opcodes and only need to include a couple of checks. But it's harder to encode since you need to account for length prefixes when chopping things up.",
          "createdAt": "2019-11-06T15:55:10Z",
          "updatedAt": "2019-11-06T15:55:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr pointed out that delta-encoding tricks should include the hash of the reconstructed ClientHello, otherwise the ciphertext tag does not cover the key shares, etc., so the above needs one more field.",
          "createdAt": "2019-11-06T20:43:34Z",
          "updatedAt": "2019-11-06T20:43:34Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "While waiting for this or some similar PR to be merged, I played about a bit with implementing guesses as to how it might be done in a [branch](https://github.com/sftcd/openssl/tree/encch) of my ESNI-enabled OpenSSL fork. If interested here's the [diff](https://github.com/sftcd/openssl/compare/master...sftcd:encch) and [some notes](https://github.com/sftcd/openssl/blob/encch/esnistuff/echo.md) on what I did.\r\n\r\nDoing that was fairly messy but not that hard, the main thoughts/questions I was left with were:\r\n- <strike>it'd maybe be easier to have the ESNI-specific padding in the esni-nonce extension directly as that'd mean less change to OpenSSL API behaviour (applications can set callbacks to do padding themselves too)</strike> In the end, I added a CH padding extension to the inner CH, (sort of) as envisaged in the PR, but could as easily do the padding within the esni_nonce. Still not sure if there're any API issues. The ``padded_length`` field in the ESNIConfig is now (IMO) even more of a bad plan than before as the relevant thing to pad is the entire plaintext inner CH and not just the server_name - so whomever is writing values to the DNS has even less likelihood of knowing a good exact max/value. (And it can be >260 now too.)\r\n - I took a stab at using my OpenSSL code for [HPKE](https://github.com/sftcd/happykey) instead of the ESNI-specific stuff that's been in earlier drafts and that wasn't a problem (though I didn't spend time thinking about how exactly to use HPKE - I just set the TLS session key share as the AAD)\r\n- I'm still very unclear as to what rules should/must apply to the relationship between values in the inner and outer CH's - but the simpler we can make that the better (I don't mean compression here, just what rules are to apply when we have two versions of a thing, like the TLS session key share or ALPN for example)\r\n- For ALPN, I implemented support for different values in inner and outer CH, which was easy enough and could even be possibly useful:-) One upshot of that is that it more or less means that the server really ought also do record layer padding of the EncryptedExtensions as otherwise the length of that might give the game away where values like ALPN differ between inner and outer CH.\r\n\r\nAnd just in case: I didn't try any compression and this code is likely flakey as hell in error cases, so don't anyone go using it for anything:-) I plan to ditch it anyway once draft-06 is out.",
          "createdAt": "2020-01-29T14:33:01Z",
          "updatedAt": "2020-02-07T16:20:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #207.",
          "createdAt": "2020-03-08T00:32:22Z",
          "updatedAt": "2020-03-08T00:32:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4MDg5MTU0",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The design looks promising, I have just some minor comments.",
          "createdAt": "2019-11-18T03:56:13Z",
          "updatedAt": "2019-11-18T05:38:35Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Maybe: then \"it\" does not send",
              "createdAt": "2019-11-18T03:56:13Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            },
            {
              "originalPosition": 193,
              "body": "s/wil/will/",
              "createdAt": "2019-11-18T03:59:21Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            },
            {
              "originalPosition": 202,
              "body": "Is this a typo \"outer_extension\"?",
              "createdAt": "2019-11-18T04:40:36Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            },
            {
              "originalPosition": 126,
              "body": "This paragraph talks about sending a ESNIKeys that the client should use for retrying.\r\n\r\nTherefore, maybe s/If it rejects ESNI/If the client sent an ESNI \"encrypted_client_hello\" extension using a key not available to the server/.",
              "createdAt": "2019-11-18T05:32:16Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            },
            {
              "originalPosition": 667,
              "body": "Have you dropped the period by an accident?",
              "createdAt": "2019-11-18T05:37:53Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDQ4MTE1",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:35:00Z",
          "updatedAt": "2019-11-25T05:35:01Z",
          "comments": [
            {
              "originalPosition": 354,
              "body": "The draft -02 protocol seems to work without an unencrypted SNI. Is this adding a required unencrypted SNI?",
              "createdAt": "2019-11-25T05:35:01Z",
              "updatedAt": "2019-11-25T05:35:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDQ4ODQ5",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:38:15Z",
          "updatedAt": "2019-11-25T05:38:15Z",
          "comments": [
            {
              "originalPosition": 336,
              "body": "Double capital I in \"ClientHelloIInner\"",
              "createdAt": "2019-11-25T05:38:15Z",
              "updatedAt": "2019-11-25T05:38:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDQ5NjY0",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:41:45Z",
          "updatedAt": "2019-11-25T05:41:46Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "nit: Both the AP style guide and https://tools.ietf.org/html/rfc7322 no longer capitalize \"web\"",
              "createdAt": "2019-11-25T05:41:45Z",
              "updatedAt": "2019-11-25T05:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUwNDA2",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:45:05Z",
          "updatedAt": "2019-11-25T05:45:05Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "\"reject an ESNIConfig\"?\r\n\r\nI'm still not clear on the reason for server-controlled padding here. I can see using this figure as a hint, though.",
              "createdAt": "2019-11-25T05:45:05Z",
              "updatedAt": "2019-11-25T05:54:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUwODg1",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:47:08Z",
          "updatedAt": "2019-11-25T05:47:09Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "May want to cite draft-hoffman-c2pq or a successor draft here.",
              "createdAt": "2019-11-25T05:47:09Z",
              "updatedAt": "2019-11-25T05:47:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUxMzM5",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:49:10Z",
          "updatedAt": "2019-11-25T05:49:10Z",
          "comments": [
            {
              "originalPosition": 245,
              "body": "I've noticed that this draft uses \"encrypted SNI\" and \"ESNI\" interchangeably, but unpredictably. Would recommend taking a pass over all of these acronyms once the naming is settled (\"ECHO\" etc...)",
              "createdAt": "2019-11-25T05:49:10Z",
              "updatedAt": "2019-11-25T05:49:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUxNjQ0",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:50:34Z",
          "updatedAt": "2019-11-25T05:50:34Z",
          "comments": [
            {
              "originalPosition": 316,
              "body": "I think the commas are off here. I think the best fix might be to leave out \"large\" and write \"duplicated extensions\".",
              "createdAt": "2019-11-25T05:50:34Z",
              "updatedAt": "2019-11-25T05:50:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUyMDU0",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:52:24Z",
          "updatedAt": "2019-11-25T05:52:24Z",
          "comments": [
            {
              "originalPosition": 510,
              "body": "Incomplete sentence.",
              "createdAt": "2019-11-25T05:52:24Z",
              "updatedAt": "2019-11-25T05:52:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1NTQ1NjAz",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-20T22:08:44Z",
          "updatedAt": "2019-12-20T22:08:44Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Just to add to the seemingly endless traffic identification via packet size: https://isc.sans.edu/diary/25616",
              "createdAt": "2019-12-20T22:08:44Z",
              "updatedAt": "2019-12-20T22:08:44Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "ekr/draft-ietf-tls-esni",
      "headRefName": "tunnel_version",
      "headRefOid": "44a7d7dc0706c30932f645abd19fecfba3ef5883",
      "mergeCommit": null
    },
    {
      "number": 197,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2OTYyNzY5",
      "title": "Key schedule injection proposal.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/197",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-05T20:06:28Z",
      "updatedAt": "2019-11-22T00:52:13Z",
      "closedAt": "2019-11-22T00:52:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #196.",
          "createdAt": "2019-11-22T00:52:12Z",
          "updatedAt": "2019-11-22T00:52:12Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/key-schedule-injection",
      "headRefOid": "a22ffbe5e5aa1f00f9f6d6b541f00379bde8e937",
      "mergeCommit": null
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3MDI5Nzgw",
      "title": "Add a length prefix to ESNIConfig contents.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/198",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "ESNIConfig has a version number in front for extensibility, but it is\r\nunclear what the version invariants are. Presumably we would like\r\nversions to change the contents of an ESNIConfig (indeed different\r\ndrafts have done so), but it is not obvious this is possible and it is\r\nimpossible to skip over an ESNIConfig with a version you do not\r\nunderstand.\r\n\r\nFix this by moving the body of an ESNIConfig into an ESNIConfigContents\r\nand adding a length prefix in front.\r\n\r\nFixes #192.",
      "createdAt": "2019-11-05T22:03:51Z",
      "updatedAt": "2019-11-21T10:17:48Z",
      "closedAt": "2019-11-21T10:17:47Z",
      "mergedAt": "2019-11-21T10:17:47Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "esni-config-contents",
      "headRefOid": "4a589f9559fd8d65d923d595dc0be4a7e9851432",
      "mergeCommit": {
        "oid": "4a589f9559fd8d65d923d595dc0be4a7e9851432"
      }
    },
    {
      "number": 199,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3MDY0ODcw",
      "title": "Unify version/extension and key share negotiation mechanisms",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/199",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[This PR sits on top of #198. Ignore the first commit to look at it in isolation.]\r\n\r\nWe currently have two levels of mechanisms for servers to advertise multiple sets of parameters. First, each ESNIConfig has multiple keys in it, so a server can suport multiple groups at once. These keys are stapled together so a single HTTPSSVC record, etc., delivers the entire configuration.\r\n\r\nAt a layer above that, we have a version/extension-based mechanism. The server may advertise multiple ESNIConfigs to cover multiple versions of ESNI (hopefully we won't need this mechanism after standardization, but it's quite useful for draft versions) or multiple sets of mandatory extensions. Unlike the group advertisement, these are each in separate configuration units, so, e.g., they may be in multiple HTTPSSVC records.\r\n\r\nThis PR flattens the two mechanisms into one. Each ESNIConfig now has a single KeyShareEntry. Multiple groups and multiple versions are expressed in the same way: multiple ESNIConfig structures. It then introduces a wrapper ESNIConfigs structure which is the new unit of ESNI configuration delivered in HTTPSSVC, etc.\r\n\r\nThis should be paired with a change to draft-nygren-dnsop-svcb-httpssvc to carry an ESNIConfigs, not an ESNIConfig (formerly ESNIKeys). (@bemasc FYI)\r\n\r\nThis fixes a number of oddities:\r\n\r\n- Client and server need to maintain two levels of configuration. On the server, the structure has two layers of lists, something like list(tuple(ESNIConfig, list(PrivateKey))). Now the server maintains list(tuple(ESNIConfig, PrivateKey)). Conversely, the client needed two negotiation loops whereas now it only requires one.\r\n\r\n- Logic across different layers of the client stack now more reliably have the full ESNI configuration available in one unit.\r\n\r\n  In the old design, a single ESNIConfig, rather than a set of them, would be correlated with an IP address or CNAME, by way of the HTTPSSVC record. A server which supportsed multiple ESNI versions or mandatory extension sets would advertise several HTTPSSVC records, potentially with different IPs. That means the DNS and transport connection logic must know about TLS capabitilies to pick the right HTTPSSVC record.\r\n\r\n  In the new design, the server includes all its variations at once, so the DNS and transport logic can reasonably pick an HTTPSSVC purely based on whether the TLS stack supports ESNI, rather than the full set of capabilities. That is, the text in [0] does not work right now, and this PR fixes it.\r\n\r\nThe downside is that, in the likely case that the server only supports one version and one set of extensions, the non-key ESNI config bits (notably the public name; the rest is small) are repeated for every named group. However, the public name should not be that large and servers should only need one or two groups[1].\r\n\r\nThis also does make ESNIConfigs and ESNIConfig separate structures, which is slightly goofy. Alternate names if folks prefer:\r\n\r\n- ESNIConfig/ESNIConfigs => ESNIConfig/ESNIBundle\r\n- ESNIConfig/ESNIConfigs => ESNIKey/ESNIConfig\r\n\r\n[0] https://tools.ietf.org/html/draft-nygren-dnsop-svcb-httpssvc-00#section-8.1.1\r\n[1] https://www.imperialviolet.org/2016/05/16/agility.html",
      "createdAt": "2019-11-05T23:14:18Z",
      "updatedAt": "2019-11-06T15:44:28Z",
      "closedAt": "2019-11-06T15:44:28Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems to me that there are two changes here:\r\n\r\n1. Bundling all the ESNIConfigs into a single HTTPSVC record. This seems like a good idea for the reasons you lay out.\r\n\r\n2. Flattening the structure. I'm less enthusiastic about this: it requires duplicating data and is a new opportunity to have inconsistencies as well as bloat.",
          "createdAt": "2019-11-05T23:19:39Z",
          "updatedAt": "2019-11-05T23:19:39Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's a good point. It's late here, so I will see about splitting this into two PRs tomorrow.",
          "createdAt": "2019-11-05T23:24:26Z",
          "updatedAt": "2019-11-05T23:24:26Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Split this into #200 and #201.",
          "createdAt": "2019-11-06T15:44:27Z",
          "updatedAt": "2019-11-06T15:44:27Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "esni-configs",
      "headRefOid": "d4f38d88ab9e11718a638f669e7b254813d68ba8",
      "mergeCommit": null
    },
    {
      "number": 200,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3NDI4OTE5",
      "title": "Advertise multiple ESNIConfigs as a unit",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/200",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[This was split out of #199 as the hopefully less controversial idea. Also it sits on top of #198. Ignore the first commit to look at it in isolation.]\r\n\r\nWe have two levels of mechanisms for servers to advertise parameters. Each ESNIConfig has multiple keys, so a server can suport multiple groups at once. These keys are stapled together so a single HTTPSSVC record delivers the entire configuration.\r\n\r\nThen we have a versions/extensions mechanism. A server supporting multiple versions of ESNI or multiple sets of mandatory extensions must advertise multiple ESNIConfigs. Unlike the group advertisement, these require separate HTTPSSVC records. This means the full ESNI config is not reliably available to logic across different layers of the client stack. In particular, the HTTPSSVC spec text in [0] does not work. (@bemasc FYI)\r\n\r\nCurrently, a single ESNIConfig, rather than a set of them, is correlated with an IP address or CNAME, by way of the HTTPSSVC record. A server which supports multiple ESNI versions or mandatory extension sets must advertise several HTTPSSVC records, potentially with different IPs. DNS and transport logic must know TLS capabilities to pick the right HTTPSSVC record.\r\n\r\nThis PR introduces an ESNIConfigs structure which advertises a list of ESNIConfig structures. The ESNIConfigs is the new unit of ESNI configuration. This should be paired with a change to draft-nygren-dnsop-svcb-httpssvc to carry an ESNIConfigs, not an ESNIConfig (formerly ESNIKeys).\r\n\r\nNow the server can include the full config at once, so the DNS and transport logic can reasonably pick an HTTPSSVC purely based on whether the TLS stack supports ESNI, rather than the full set of capabilities. This fixes the text in [0].\r\n\r\nThat ESNIConfigs and ESNIConfig are separate structures is slightly goofy naming. Alternate names if folks prefer:\r\n\r\n- ESNIConfig/ESNIConfigs => ESNIConfig/ESNIBundle\r\n\r\n- ESNIConfig/ESNIConfigs => ESNIKeys/ESNIConfig\r\n  (Nuisance: an ESNIConfig is a list of ESNIKeyses, which brings back the double plural.)\r\n\r\n(While I'm here, fix the remnants of ESNIKeyShares. I'll split that out if this PR is controversial, but GitHub is really bad at dependent PRs, so I've left it together for now.)\r\n\r\n[0] https://tools.ietf.org/html/draft-nygren-dnsop-svcb-httpssvc-00#section-8.1.1",
      "createdAt": "2019-11-06T15:43:10Z",
      "updatedAt": "2019-11-21T10:17:46Z",
      "closedAt": "2019-11-21T10:17:46Z",
      "mergedAt": "2019-11-21T10:17:46Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This means the full ESNI config is not reliably available to logic across different layers of the client stack. In particular, the HTTPSSVC spec text in [0] does not work. (@bemasc FYI)\r\n\r\nWhy doesn't it work?  The transport side tries the highest-priority option, and the TLS library is free to reject it, in which case the transport side will try the next option, etc.  All the transport side needs to know is whether the TLS library supports ESNI.\r\n\r\nAre you thinking about a case where the client only supports ESNI version 1, and the server only offers ESNI version 2?",
          "createdAt": "2019-11-06T15:49:26Z",
          "updatedAt": "2019-11-06T15:49:26Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That presumes your retry loop is integrated up and down the layers. It also means that, unless you shortcircuit things and check ESNI ahead of time, you pay for a TCP roundtrip to the unsupported ESNIConfig addresses. It also doesn't account for cases when the client doesn't support any of the ESNI versions. In that case, it should connect without ESNI (presuming it would be okay doing so without ESNI configs).",
          "createdAt": "2019-11-06T16:02:37Z",
          "updatedAt": "2019-11-06T16:02:55Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That presumes your retry loop is integrated up and down the layers. It also means that, unless you shortcircuit things and check ESNI ahead of time, you pay for a TCP roundtrip to the unsupported ESNIConfig addresses.\r\n\r\nOK, I agree with all of this.  I'm happy to reduce the required level of integration, if we can find a way.\r\n\r\n> It also doesn't account for cases when the client doesn't support any of the ESNI versions. In that case, it should connect without ESNI (presuming it would be okay doing so without ESNI configs).\r\n\r\nAre you proposing that the TLS library should silently ignore an ESNIConfigs with all unsupported versions/ciphers, and send the SNI in cleartext?  That seems like a recommendation that should go in this draft.  Or are you proposing a fallback check that goes back to the transport layer?",
          "createdAt": "2019-11-06T16:37:00Z",
          "updatedAt": "2019-11-06T16:37:00Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Are you proposing that the TLS library should silently ignore an ESNIConfigs with all unsupported versions/ciphers, and send the SNI in cleartext? That seems like a recommendation that should go in this draft.\r\n\r\nIt is in the draft. It says you ignore ESNIConfigs you don't understand.",
          "createdAt": "2019-11-06T17:02:26Z",
          "updatedAt": "2019-11-06T17:02:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in Singapore; no objections. Will merge.",
          "createdAt": "2019-11-21T10:16:39Z",
          "updatedAt": "2019-11-21T10:16:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjQ0NDQw",
          "commit": {
            "abbreviatedOid": "72711a8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T20:38:24Z",
          "updatedAt": "2019-11-14T20:38:24Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "esni-configs-2",
      "headRefOid": "72711a8959dcf8f9b63c5c7e041a17b969f5f9ce",
      "mergeCommit": {
        "oid": "d45d404dd2000740ddef3d7a8a537c7c3b55e7a8"
      }
    },
    {
      "number": 201,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3NDI5NTUx",
      "title": "Flatten ESNI negotiation mechanisms",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/201",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[This was split out of #199 as the possibly more controversial idea. It's a simplification but does make configs larger. Also it sits on top of #198 and #200. Ignore the first two comments to look at it in isolation.]\r\n\r\nWe have two layers of parameter negotiation. Multiple KeyShareEntry values in an ESNIConfig, and multiple ESNIConfig values in an ESNIConfigs. We only need one mechanism, so store only one KeyShareEntry in an ESNIConfig.\r\n\r\nThis simplifies representing client and server configuration, which simplies implementation internals as well as interchange formats. Right now, on the server, configuration has two layers of lists, something like list(tuple(ESNIConfig, list(PrivateKey))). Now the server maintains list(tuple(ESNIConfig, PrivateKey)).\r\n\r\nNote also that draft-farrell-tls-pemesni-00 has this oddity around what to do if the ESNIKeys contains multiple keys. This is particularly a nuisance because a single standalone PRIVATE KEY / ESNIKEY pair is not usable because the server has committed to answering to *all* keys in the ESNIKeys. The server must consume multiple PEM files, match up the ESNIKeyses, and then assert that it has a complete set.\r\n\r\nThe downside is that, in the likely case that the server only supports one version and one set of extensions, the non-key ESNI config bits (notably the public name; the rest is small) are repeated for every named group. However, the public name should not be that large and servers should only need one or two groups (see https://www.imperialviolet.org/2016/05/16/agility.html).",
      "createdAt": "2019-11-06T15:44:17Z",
      "updatedAt": "2020-02-23T13:49:02Z",
      "closedAt": "2020-02-23T13:49:01Z",
      "mergedAt": "2020-02-23T13:49:01Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjQ1NzI3",
          "commit": {
            "abbreviatedOid": "67a2e15"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This LGTM -- thanks, David!",
          "createdAt": "2019-11-14T20:40:45Z",
          "updatedAt": "2019-11-14T20:40:45Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "esni-configs-flatten",
      "headRefOid": "67a2e15076a4e95c03b125d54e5d1888663e2605",
      "mergeCommit": {
        "oid": "4d2aa537160d22456a8bc1db9cf7a0295055963c"
      }
    },
    {
      "number": 203,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxMDkzMTY5",
      "title": "Remove ESNI RRType Considerations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/203",
      "state": "MERGED",
      "author": "mrsylerpowers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #202 ",
      "createdAt": "2019-11-14T17:31:37Z",
      "updatedAt": "2019-11-14T20:35:25Z",
      "closedAt": "2019-11-14T20:35:25Z",
      "mergedAt": "2019-11-14T20:35:25Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjQyOTM3",
          "commit": {
            "abbreviatedOid": "e9c66fc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T20:35:20Z",
          "updatedAt": "2019-11-14T20:35:20Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "mrsylerpowers/draft-ietf-tls-esni",
      "headRefName": "patch-1",
      "headRefOid": "e9c66fcbe8756a2c86461b70c56975ec71616c55",
      "mergeCommit": {
        "oid": "811def0f5f7f858a42a2c51cbf70baf0c2562202"
      }
    },
    {
      "number": 207,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1MjA5NDIy",
      "title": "ESNI -> ECHO",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/207",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change implements the ESNI -> ECHO design discussed in Singapore. There a couple pending TODOs, particularly around cross-CH HRR binding, but the meat is what's currently being analyzed. \r\n\r\ncc @davidben, @grittygrease, @martinthomson, @karthikbhargavan ",
      "createdAt": "2020-03-08T00:30:29Z",
      "updatedAt": "2020-03-09T21:57:43Z",
      "closedAt": "2020-03-09T21:57:43Z",
      "mergedAt": "2020-03-09T21:57:43Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTU2Mzk3",
          "commit": {
            "abbreviatedOid": "42c6c48"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This still seems a bit rough, but I think better in the spec than out.",
          "createdAt": "2020-03-09T21:56:12Z",
          "updatedAt": "2020-03-09T21:56:12Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f13e0c956c1b42e4121ee41904a77af1bacebf18",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/tunnel",
      "headRefOid": "42c6c489a9bfa7bdceb4b9b8b6c34415dae3ca68",
      "mergeCommit": {
        "oid": "7d53f5b6985242c18e1a988104090dc1f08a4d74"
      }
    },
    {
      "number": 208,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg3MzI4NjE2",
      "title": "Align client GREASE section with ClientEncryptedCH definition.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/208",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Also define the length of the randomly-generated \"encrypted_ch\" field.",
      "createdAt": "2020-03-12T16:02:12Z",
      "updatedAt": "2020-03-18T15:17:19Z",
      "closedAt": "2020-03-18T15:17:19Z",
      "mergedAt": "2020-03-18T15:17:18Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben @dvorak42",
          "createdAt": "2020-03-12T16:04:57Z",
          "updatedAt": "2020-03-12T16:04:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNjkwNzcy",
          "commit": {
            "abbreviatedOid": "2dd6ff2"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-12T16:03:19Z",
          "updatedAt": "2020-03-12T16:03:19Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Is `padded_length` supposed to be the length for \"encrypted_ch\"? I was unclear on this.",
              "createdAt": "2020-03-12T16:03:19Z",
              "updatedAt": "2020-03-13T15:18:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNzU3Mjc4",
          "commit": {
            "abbreviatedOid": "2dd6ff2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-12T17:25:35Z",
          "updatedAt": "2020-03-12T17:25:35Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "We should probably table this until we figure out the padding strategy. (Apparently that's still up in the air!) It also occurs to me that the first bullet in this list is obsolete -- we don't have a named group anymore or padded_length anymore:\r\n\r\n```\r\n      struct {\r\n          CipherSuite suite;\r\n          opaque record_digest<0..2^16-1>;\r\n          opaque enc<1..2^16-1>;\r\n          opaque encrypted_ch<1..2^16-1>;\r\n      } ClientEncryptedCH;\r\n```\r\n\r\nCan we just say something like the following? \r\n\r\n\"Set the \"suite\" field to a supported cipher suite. This selection SHOULD vary to exercise all supported configurations, but MAY be constant for successive connections to the same server in the same session.\"",
              "createdAt": "2020-03-12T17:25:35Z",
              "updatedAt": "2020-03-13T15:18:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MzczMzA1",
          "commit": {
            "abbreviatedOid": "2dd6ff2"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-13T15:04:11Z",
          "updatedAt": "2020-03-13T15:04:12Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Ah, ok. I'll bring the [TODO] back for the length of encrypted_ch.",
              "createdAt": "2020-03-13T15:04:11Z",
              "updatedAt": "2020-03-13T15:18:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2OTY1NTcw",
          "commit": {
            "abbreviatedOid": "750477a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-18T15:17:12Z",
          "updatedAt": "2020-03-18T15:17:12Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7d53f5b6985242c18e1a988104090dc1f08a4d74",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "dan-clean-up-grease",
      "headRefOid": "750477aad3b5b19c56d8c1975806309147adfc8f",
      "mergeCommit": {
        "oid": "db1d9a793c0640f03750612a4fd2be7bfe8f30b5"
      }
    },
    {
      "number": 209,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg4NDM5NjA1",
      "title": "padding scheme text",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/209",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I've tried to capture what I think is a reasonable way to handle padding now we've changed from ESNI->ECHO.  If we could do something like this, that'd be better than what's in -06.\r\n\r\nNote that I'd be even happier if we entirely eliminated ECHOConfig.minimum_inner_length - I don't think it actually adds any value and it represents yet another way to get a configuration wrong.  ",
      "createdAt": "2020-03-14T21:05:06Z",
      "updatedAt": "2020-05-03T23:58:42Z",
      "closedAt": "2020-05-03T23:58:42Z",
      "mergedAt": "2020-05-03T23:58:42Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the fixes. \r\nOn the general point, I think that *if* we keep the flexibility for the client to vary the inner/outer CH however it chooses, then we will also have to depend on clients to figure out how to pad well for whatever they do. If we constrain the inner/outer variance a lot, then we could do better.\r\nIt also strikes me that the minimum_inner_length is sort of in tension with the idea of compression - if a server has to set the minimum_inner_length to 300ish to handle clients that don't compress, then clients that do compress either don't get the benefit or have to ignore the minimum_inner_length.",
          "createdAt": "2020-03-16T15:01:18Z",
          "updatedAt": "2020-03-16T15:03:37Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think this PR works. The server does not have enough information to report a useful value, and the value the server reports is not useful to maintain good anonymity sets.\r\n\r\nThe server does not know that the client supports some large extension or key share type (or lots of cipher suites, ALPN protocols, etc). [Post-quantum key shares](https://www.imperialviolet.org/2018/12/12/cecpq2.html) are especially fun. It also doesn't know which extensions the client will compress from the outer ClientHello and which it will reencode.\r\n\r\nConversely, the value the server sets isn't useful. If the client implementation has a smaller baseline compression and extensions, we waste bytes without much benefit. Worse, if the client implementation has a larger baseline compression and extensions, this PR regresses anonymity. The ClientHello will then exceed `minimum_inner_length` and we don't hide the lengths of the sensitive bits.\r\n\r\nStepping back, we want to hide the distribution of ClientHelloInner lengths within some anonymity set. Most of the contributors to that length come from local client configuration: how many ciphers you support, what ALPN protocols, etc. The client is the one that knows, e.g., it sometimes asks servers for protocols A and B and sometimes for A and C. It largely has enough information to pad itself.\r\n\r\nThe main exception is the server name. Realistically we need to trim anonymity sets down to colocated services, and the client doesn't know that distribution of names. Thus, we want servers to report the value in ECHOConfig. Maybe we'll need more such statistics later, which is what extensions are for. It's annoying this is a bit complicated, but we've signing up to encrypt far more things now.\r\n\r\nI should note this presumes an anonymity set of similarly-configured clients. I think, realistically, that's all we can say rigorous things about. It's nice to reduce visible artifacts of configuration, which is why we *additionally* round up to multiples of 16, but that's something we can burn into the protocol without ECHOConfig support.",
          "createdAt": "2020-03-16T16:02:07Z",
          "updatedAt": "2020-03-16T16:03:17Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nHiya,\n\nOn 16/03/2020 16:02, David Benjamin wrote:\n> I don't think this PR works. The server does not have enough\n> information to report a useful value, and the value the server\n> reports is not useful to maintain good anonymity sets.\n> \n> The server does not know that the client supports some large\n> extension or key share type (or lots of cipher suites, ALPN\n> protocols, etc). It also doesn't know which extensions the client\n> will compress from the outer ClientHello and which it will reencode.\n> \n> Conversely, the value the server sets isn't useful. If the client\n> implementation has a smaller baseline compression and extensions, we\n> waste bytes without much benefit. Worse, if the client implementation\n> has a larger baseline compression and extensions, this PR regresses\n> anonymity. The ClientHello will then exceed `minimum_inner_length`\n> and we don't hide the lengths of the sensitive bits.\n\nSorry, not seeing that last. The PR just says (or was\nmeant to say) to pad to some multiple of 16 in that\ncase which I agree isn't much guidance, but does allow\ndoing something that works. (As well as allowing things\nthat don't work well;-)\n\n> \n> Stepping back, we want to hide the distribution of ClientHelloInner\n> lengths within some anonymity set. Most of the contributors to that\n> length come from local client configuration: how many ciphers you\n> support, what ALPN protocols, etc. The client is the one that knows,\n> e.g., it sometimes asks servers for protocols A and B and sometimes\n> for A and C. It largely has enough information to pad itself.\n\nI agree that all this really needs to be driven by the\nclient.\n\n> The main exception is the server name. Realistically we need to trim\n> anonymity sets down to colocated services, and the client doesn't\n> know that distribution of names. \n\nWell, yes and no. I don't believe a server config is\nuseful for that, (as I've argued before and still do;-)\nISTM the max server name value will almost always be\nset to 254. May as well tell the client to pad as do\nthat IMO.\n\n> Thus, we want servers to report the\n> value in ECHOConfig. Maybe we'll need more such statistics later,\n> which is what extensions are for. It's annoying this is a bit\n> complicated, but we've signing up to encrypt far more things now.\n> \n> I should note this presumes an anonymity set of similarly-configured\n> clients. I think, realistically, that's all we can say rigorous\n> things about. It's nice to reduce visible artifacts of configuration,\n> which is why we *additionally* round up to multiples of 16, but\n> that's something we can burn into the protocol without ECHOConfig\n> support.\n\nNot quite sure if I agree with that last para or not TBH!\n\nS.\n\n\n> \n",
          "createdAt": "2020-03-16T21:46:18Z",
          "updatedAt": "2020-03-16T21:46:18Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Conversely, the value the server sets isn't useful. If the client\r\n> > implementation has a smaller baseline compression and extensions, we\r\n> >  waste bytes without much benefit. Worse, if the client implementation\r\n> > has a larger baseline compression and extensions, this PR regresses\r\n> > anonymity. The ClientHello will then exceed `minimum_inner_length`\r\n> > and we don't hide the lengths of the sensitive bits.\r\n>\r\n> Sorry, not seeing that last. The PR just says (or was\r\n> meant to say) to pad to some multiple of 16 in that\r\n> case which I agree isn't much guidance, but does allow\r\n> doing something that works. (As well as allowing things\r\n> that don't work well;-)\r\n\r\nWell, if we were satisfied just padding names to a multiple of 16, we wouldn't need any of this. We'd just say to pad to a multiple 16 and move on. :-) In the current name-focused spelling, the client is always able to apply a smarter padding decision based on the server's knowledge of the name distribution. With this PR, clients whose local configuration exceeds or is near `minimum_inner_length` lose this and hit the baseline multiple of 16 behavior. Clients whose local configuration is decently below `minimum_inner_length` do hide the name distribution, but using many more bytes than they would with the current text.\r\n\r\n> > The main exception is the server name. Realistically we need to trim\r\n> > anonymity sets down to colocated services, and the client doesn't\r\n> > know that distribution of names.\r\n>\r\n> Well, yes and no. I don't believe a server config is\r\n> useful for that, (as I've argued before and still do;-)\r\n> ISTM the max server name value will almost always be\r\n> set to 254. May as well tell the client to pad as do\r\n> that IMO.\r\n\r\nWe have some metrics in Chrome on the distribution of DNS names. It's nowhere near 254. But, regardless, if you don't believe a server config is even useful for the name and agree with me that other extensions ought to be client-driven, I'm confused, why this PR? This PR seems to go in the opposite direction.\r\n\r\n> > I should note this presumes an anonymity set of similarly-configured\r\n> > clients. I think, realistically, that's all we can say rigorous\r\n> > things about. It's nice to reduce visible artifacts of configuration,\r\n> > which is why we *additionally* round up to multiples of 16, but\r\n> > that's something we can burn into the protocol without ECHOConfig\r\n> > support.\r\n>\r\n> Not quite sure if I agree with that last para or not TBH!\r\n\r\nHehe. Which part?",
          "createdAt": "2020-03-16T22:13:18Z",
          "updatedAt": "2020-03-16T22:13:18Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nHIya,\n\nOn 16/03/2020 22:13, David Benjamin wrote:\n>>> Conversely, the value the server sets isn't useful. If the\n>>> client implementation has a smaller baseline compression and\n>>> extensions, we waste bytes without much benefit. Worse, if the\n>>> client implementation has a larger baseline compression and\n>>> extensions, this PR regresses anonymity. The ClientHello will\n>>> then exceed `minimum_inner_length` and we don't hide the lengths\n>>> of the sensitive bits.\n>> \n>> Sorry, not seeing that last. The PR just says (or was meant to say)\n>> to pad to some multiple of 16 in that case which I agree isn't much\n>> guidance, but does allow doing something that works. (As well as\n>> allowing things that don't work well;-)\n> \n> Well, if we were satisfied just padding names to a multiple of 16, we\n> wouldn't need any of this. We'd just say to pad to a multiple 16 and\n> move on. :-) In the current name-focused spelling, the client is\n> always able to apply a smarter padding decision based on the server's\n> knowledge of the name distribution. With this PR, clients whose local\n> configuration exceeds or is near `minimum_inner_length` lose this and\n> hit the baseline multiple of 16 behavior. Clients whose local\n> configuration is decently below `minimum_inner_length` do hide the\n> name distribution, but using many more bytes than they would with the\n> current text.\n\nYes. That's IMO the downside of having any server config.\n(To answer your question below, I prefer not having any\nserver config at all but proposed this as I think it's\nbetter than draft-06.)\n\n> \n>>> The main exception is the server name. Realistically we need to\n>>> trim anonymity sets down to colocated services, and the client\n>>> doesn't know that distribution of names.\n>> \n>> Well, yes and no. I don't believe a server config is useful for\n>> that, (as I've argued before and still do;-) ISTM the max server\n>> name value will almost always be set to 254. May as well tell the\n>> client to pad as do that IMO.\n> \n> We have some metrics in Chrome on the distribution of DNS names. It's\n> nowhere near 254. \n\nHaving also looked at some passive DNS stuff, I fully\nagree. But ISTM for many scenarios the entity that\ngenerates the ECHOConfig won't know the distribution\nof names in use (e.g. whoever configures OpenSSL won't,\nsame with Apache etc.) so it's likely they'll have to\ngo for whatever is the max (i.e. 254). Same is true\nfor anyone with a wild-card server cert in play\nsomewhere.\n\n> But, regardless, if you don't believe a server\n> config is even useful for the name and agree with me that other\n> extensions ought to be client-driven, I'm confused, why this PR? This\n> PR seems to go in the opposite direction.\n\nSee above. I'm trying for either a modest improvement\nover draft-06 or for us all to arrive at a real\nimprovement by ditching the server config entirely:-)\n\n> \n>>> I should note this presumes an anonymity set of\n>>> similarly-configured clients. I think, realistically, that's all\n>>> we can say rigorous things about. It's nice to reduce visible\n>>> artifacts of configuration, which is why we *additionally* round\n>>> up to multiples of 16, but that's something we can burn into the\n>>> protocol without ECHOConfig support.\n>> \n>> Not quite sure if I agree with that last para or not TBH!\n> \n> Hehe. Which part?\n\nI like the last sentence. I think I dislike the 1st:-)\n\nCheers,\nS.\n\n> \n",
          "createdAt": "2020-03-16T22:28:24Z",
          "updatedAt": "2020-03-16T22:28:24Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > [...] With this PR, clients whose local configuration exceeds or is near `minimum_inner_length` lose this and hit the baseline multiple of 16 behavior.  [...trimmed for brevity, but please let me know if I've misinterpreted what 'That' referred to!]\r\n>\r\n> Yes. That's IMO the downside of having any server config.\r\n> (To answer your question below, I prefer not having any\r\n> server config at all but proposed this as I think it's\r\n> better than draft-06.)\r\n\r\nIt's not a downside of the draft-06 formulation, is it? The client learns something targeted to the name and can pad accordingly.\r\n\r\n> >  We have some metrics in Chrome on the distribution of DNS names. It's nowhere near 254.\r\n>\r\n> Having also looked at some passive DNS stuff, I fully\r\n> agree. But ISTM for many scenarios the entity that\r\n> generates the ECHOConfig won't know the distribution\r\n> of names in use (e.g. whoever configures OpenSSL won't,\r\n> same with Apache etc.) so it's likely they'll have to\r\n> go for whatever is the max (i.e. 254). Same is true\r\n> for anyone with a wild-card server cert in play\r\n> somewhere.\r\n\r\nEven with a wildcard server cert, the server should still know the distribution. For instance, `*.github.io` isn't going to see anything terribly long most of the time. (Looks like the registration limit is 39 characters.) For reference, this is how long a 254-character hostname is:\r\n\r\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\n\r\nIn order to enjoy wide adoption, ECHO can't be too much of a waste of resources.  I think it thus makes sense to target a different maximum here.\r\n\r\n> See above. I'm trying for either a modest improvement\r\n> over draft-06 or for us all to arrive at a real\r\n> improvement by ditching the server config entirely:-)\r\n\r\nI guess my view is that, because of this issue above, this is a regression over the draft-06 formulation, even though it looks more general.",
          "createdAt": "2020-03-17T19:32:10Z",
          "updatedAt": "2020-03-17T19:32:10Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nHiya,\n\nOn 17/03/2020 19:32, David Benjamin wrote:\n>>> [...] With this PR, clients whose local configuration exceeds or\n>>> is near `minimum_inner_length` lose this and hit the baseline\n>>> multiple of 16 behavior.  [...trimmed for brevity, but please let\n>>> me know if I've misinterpreted what 'That' referred to!]\n>> \n>> Yes. That's IMO the downside of having any server config. (To\n>> answer your question below, I prefer not having any server config\n>> at all but proposed this as I think it's better than draft-06.)\n> \n> It's not a downside of the draft-06 formulation, is it? The client\n> learns something targeted to the name and can pad accordingly.\n\nDraft-06 assumes that no other inner CH content has the\nproperty that server guidance will help. My claim is that\nthat guidance is useless in practice, and therefore\nunnecessary. I think the server config'd length in the PR\nis a little less useless:-)\n\n> \n>>> We have some metrics in Chrome on the distribution of DNS names.\n>>> It's nowhere near 254.\n>> \n>> Having also looked at some passive DNS stuff, I fully agree. But\n>> ISTM for many scenarios the entity that generates the ECHOConfig\n>> won't know the distribution of names in use (e.g. whoever\n>> configures OpenSSL won't, same with Apache etc.) so it's likely\n>> they'll have to go for whatever is the max (i.e. 254). Same is\n>> true for anyone with a wild-card server cert in play somewhere.\n> \n> Even with a wildcard server cert, the server should still know the\n> distribution. \n\nSome servers will. Some will not. Many (most?) server\nECHOConfig instances will make use of default settings.\nThose'll pick 254 because adding a new VirtualHost to\nan apache instance (or similar) won't be co-ordinated\nwith making a new ECHOConfig in general. And even it\nit were, (but it won't!) we get a TTL's worth of mismatch.\nIf we don't provide a way for clients to handle the case\nwhere the server config is too short, again servers will\npublish 254.\n\n> For instance, `*.github.io` isn't going to see anything\n> terribly long most of the time. \n\nI am more interested in random smaller web sites/hosters\nmyself. I think ECHO should work for those as well as we\ncan make it, (albeit with smaller anonymity sets), and\nthis tie between web server config and ECHOConfig is just\na bad plan for such.\n\n> (Looks like the registration limit is\n> 39 characters.) For reference, this is how long a 254-character\n> hostname is:\n> \n> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n>\n>  In order to enjoy wide adoption, ECHO can't be too much of a waste\n> of resources. \n\nAFAIK, all current deployments do just that. To be fair,\nthat's largely driven by CF's draft-02 deployment, but\nI think that backs up my argument that if there's a max,\nthat'll almost always be chosen, which implies it's a\nuseless field that leads to the inefficiency you note.\n\n> I think it thus makes sense to target a different\n> maximum here.\n\nThen it can't be the max:-) The 254 value matches the\nmax for server_name IIRC.\n\n> \n>> See above. I'm trying for either a modest improvement over draft-06\n>> or for us all to arrive at a real improvement by ditching the\n>> server config entirely:-)\n> \n> I guess my view is that, because of this issue above, this is a\n> regression over the draft-06 formulation, even though it looks more\n> general.\n\nOk. We disagree. But what do you think the client should\ndo? Draft-06 is IMO plainly incorrect in that it says to\npad in a way that'd expose other lengths should those be\nsensitive. If your answer were pad the SNI to at least\nECHOConfig.maximum_name_length and then make the overall\na multiple of 16, with as many added 16 octets blocks as\nthe client chooses, then a) that's != draft-06 and b) is\nquite close to this PR and c) just failing if the actual\nSNI in the inner CH is longer than the config setting\nseems quite wrong to me and d) hardcodes the assumption\nthat SNI is the only thing where the server may know\nbetter.\n\nCheers,\nS.\n\n\n> \n",
          "createdAt": "2020-03-17T20:06:49Z",
          "updatedAt": "2020-03-17T20:06:49Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Draft-06 assumes that no other inner CH content has the\r\n> property that server guidance will help. My claim is that\r\n> that guidance is useless in practice, and therefore\r\n> unnecessary. I think the server config'd length in the PR\r\n> is a little less useless:-)\r\n\r\nIf we come up with other places where server guidance is useful, that can be addressed with extensions. But, gotcha, I suppose that is where we disagree. I think server guidance on the overall ClientHello size is entirely useless, while server guidance on the name is may be useful.\r\n\r\n> I am more interested in random smaller web sites/hosters\r\n> myself. I think ECHO should work for those as well as we\r\n> can make it, (albeit with smaller anonymity sets), and\r\n> this tie between web server config and ECHOConfig is just\r\n> a bad plan for such.\r\n\r\nAgreed that it should also work for smaller things. I don't follow how this PR helps in that regard. It seems they still need to come up with a random value or a default, but now it's even less clear how to set it well.\r\n\r\n>> I think it thus makes sense to target a different\r\n>> maximum here.\r\n>\r\n> Then it can't be the max:-) The 254 value matches the\r\n> max for server_name IIRC.\r\n\r\nEr, yes, sorry I meant to say target a different public length. That is, 254 is so far from the maximum domain name in practice (As it should be! Hard length limits ought to be comfortably away from the actual requirement.), so padding up to it is wasteful. I think it would be better to pad up to a tighter value and, if we exceed it, accept that we only have the fallback multiple of 16 padding. (Or maybe a different strategy.) It does result in smaller anonymity sets in edge cases, but I think that a reasonable default tradeoff given other desires like broader deployment and not wasting too much of users' data.\r\n\r\n> Ok. We disagree. But what do you think the client should\r\n> do? Draft-06 is IMO plainly incorrect in that it says to\r\n> pad in a way that'd expose other lengths should those be\r\n> sensitive. If your answer were pad the SNI to at least\r\n> ECHOConfig.maximum_name_length and then make the overall\r\n> a multiple of 16, with as many added 16 octets blocks as\r\n> the client chooses, then a) that's != draft-06 and b) is\r\n> quite close to this PR and c) just failing if the actual\r\n> SNI in the inner CH is longer than the config setting\r\n> seems quite wrong to me and d) hardcodes the assumption\r\n> that SNI is the only thing where the server may know\r\n> better.\r\n\r\nI'm thinking something along the lines of:\r\n\r\n1. For each field, determine how much it makes sense to pad given what kinds of things it sends. If it varies ALPN, maybe round up to the largest of those. Most of this can be determined without server help.\r\n2. For fields where server help is useful, like the name, apply that help. Right now it's simply a `max` function. I'm also open to other strategies.\r\n3. Sum all that padding together.\r\n4. In order to generally reduce entropy across different kinds of clients, maybe apply some additional overall padding, like rounding up to a multiple of 16, which cuts down the state space by 16x and doesn't cost much. (Or maybe we should round up to the nearest `int(64 * 1.1**i)`? That avoids higher resolution on longer values while bounding the fraction of bytes wasted by this step.) That said, it's worth keeping in mind that clients already vary quite a bit in the cleartext portions of the ClientHello. There's a bit of tension between wanting to look like the other clients and wanting to ship new security improvements.\r\n\r\nThis is different from this PR because this PR asks the server to report a value including things it doesn't know anything about (how large the client-controlled parameters are). I don't quite follow (c). It seems this PR and the above proposal has roughly the same failure modes when something is too long. The difference is that `maximum_name_length`'s failure mode is only tripped on particular long names (something the server knows the distribution of), while this PR's equivalent failure mode is based on factors outside the server control, yet the server is responsible for the value.",
          "createdAt": "2020-03-17T22:02:45Z",
          "updatedAt": "2020-03-17T22:02:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For each field\r\n\r\nClarification: this is for each field where the client doesn't reference the outer ClientHello. If the client wishes to do that, it means the client doesn't consider that field secret so there isn't anything to pad.",
          "createdAt": "2020-03-17T22:03:58Z",
          "updatedAt": "2020-03-17T22:03:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I like @davidben's suggested algorithm, as an ideal padding function requires input from both the client and server. (Ideally, servers would send padding recommendations for each extension that might vary specifically for them, such as the server name. They don't have insight into anything else, so clients need to make padding decisions based on local configuration.)\r\n\r\n@sftcd, what do you think?",
          "createdAt": "2020-03-18T15:26:40Z",
          "updatedAt": "2020-03-18T15:26:40Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 18/03/2020 15:26, Christopher Wood wrote:\n> I like @davidben's suggested algorithm, as an ideal padding function\n> requires input from both the client and server. (Ideally, servers\n> would send padding recommendations for each extension that might vary\n> specifically for them, such as the server name. They don't have\n> insight into anything else, so clients need to make padding decisions\n> based on local configuration.)\n> \n> @sftcd, what do you think?\n\nCould live with it, but still prefer no server config.\nI'm looking a bit at some numbers and will try make a\nconcrete suggestion later today. If I don't get that\ndone, it seems fair to accept @davidben's algo and move\non.\n\nCheers,\nS.\n\n> \n",
          "createdAt": "2020-03-18T15:29:25Z",
          "updatedAt": "2020-03-18T15:29:25Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we can get away with no server config, I'm also entirely happy with that. Fewer moving parts is always great. We certainly could do that by saying names are padded up to 254, but I think that's too wasteful. But if we're happy with some global set of buckets that makes everyone happy (be it multiples of 16, some funny exponential thing), great!",
          "createdAt": "2020-03-18T15:57:47Z",
          "updatedAt": "2020-03-18T15:57:47Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n(trimming violently and responding slowly:-)\n\nOn 17/03/2020 22:02, David Benjamin wrote:\n> I'm thinking something along the lines of:\n\nSo your steps 1-6 is a better scheme than draft-06.\n\nI still think step 2 would be better as something like:\n\n2. ECHOConfig contains max_name_len as before but we\nRECOMMEND it be zero and a) if the name to be padded is\nlonger than max_name_len, then names will be padded as\nfollows: P=32-(len(name)%32)+heads_or_tails*32, or b)\nif the name to be padded is shorter than max_name_len\nthen we just do as the server asked and pad to that\nlength.\n\nThat (hopefully:-) means a default of \"pad out to the\nnext multiple of 32, then toss a coin and add another\n32 if the coin landed as heads.\"\n\nIf we landed somewhere there, I'd be happy to make this\nPR say that or to make a new one or whatever.\n\nAccording to some data I have the CDFs for names and\nfor these padded lengths would be as follows:\n\nLen, CDF, Padded-CDF\n32, 81.28, 40.64\n64, 97.87, 89.57\n96, 99.31, 98.59\n128, 99.87, 99.59\n\nThat means that 81.28 of names are <32 octets long\nand 40.64% of name+name_padding will be 32 octets\nlong. 97.87% of names are <64 octets and 89.57% of\nname+name_padding are 64 octets long.\n\nI think we should RECOMMEND setting max_name_len to\nzero unless an ESNI key generator has a specific\nreason to set it to a non-zero value. ISTM the use-case\nfor non-zero values is where the anonymity set has only\na few very long names that with length differences of\n>32 octets for which it is considered important to use\nECHO. I'm basically fine that we default to not\nserving that use-case wellmby default, as I don't\nbelieve it's real. (But I could be wrong;-)\n\n\nCheers,\nS.\n\n\n\n\n\n\n",
          "createdAt": "2020-03-20T11:34:52Z",
          "updatedAt": "2020-03-20T11:34:52Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "Could the sender always pad their packets to at least 1200 bytes or something, using an encrypted extension in the ClientHello?\r\n\r\nI don't understand the focus on server input to a padding function that would ideally fill out one packet.",
          "createdAt": "2020-03-21T02:49:10Z",
          "updatedAt": "2020-03-21T06:31:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd what's the value in adding zero or one 32B blocks after rounding? Why not just stick with what was done, say, in RFC8467? (We could make it read something like, \"clients may add zero or one blocks.\" Either way, I'm more or less fine with the suggested change. Would you mind updating this PR to match?)",
          "createdAt": "2020-03-22T16:31:39Z",
          "updatedAt": "2020-03-22T16:34:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't understand the focus on server input to a padding function that would ideally fill out one packet.\r\n\r\nPer [David's comment](https://github.com/tlswg/draft-ietf-tls-esni/pull/209#issuecomment-600322366) above, clients *could* use help from servers in choosing appropriate padding lengths. (Only servers know their name anonymity set.)",
          "createdAt": "2020-03-22T16:33:49Z",
          "updatedAt": "2020-03-22T16:33:49Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nHiya,\n\nOn 22/03/2020 16:32, Christopher Wood wrote:\n> @sftcd what's the value in adding zero or one 32B blocks after\n> rounding? Why not just stick with what was done, say, in RFC8467?\n>\n\nSay if the anonymity set has lots of names <32 length\n(~81% of names in the data I have) but a small number\nbetween 32 and 64 (~16% in my data). Then this should\ndisguise the use of the longer names at the expense\nof sending more octets. Would be v. happy to know if\nthat made sense to others.\n\nCheers,\nS.\n\n",
          "createdAt": "2020-03-22T16:39:07Z",
          "updatedAt": "2020-03-22T16:39:07Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nA friendly amendment below (but one I think is\nimportant)...\n\nOn 22/03/2020 16:34, Christopher Wood wrote:\n>> I don't understand the focus on server input to a padding function\n>> that would ideally fill out one packet.\n> \n> Per [David's\n> comment](https://github.com/tlswg/draft-ietf-tls-esni/pull/209#issuecomment-600322366)\n> above, clients *could* use help from servers in choosing appropriate\n> padding lengths. (Only servers know their name anonymity set.)\n> \n\nI think that last really needs to be \"Only servers can know\ntheir name anonymity set. But many servers will not know\nthat, either due to wildcard certs or because names/vhosts\nare added and removed all the time independent of whatever\nis in the DNS.\"\n\nCheers,\nS.\n",
          "createdAt": "2020-03-22T16:41:47Z",
          "updatedAt": "2020-03-22T16:41:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Would be v. happy to know if that made sense to others.\r\n\r\nIt makes sense, I'm just not not sure it's worth the cost. That said, this will always be an imperfect solution, so I'm happy either way.\r\n",
          "createdAt": "2020-03-22T16:44:11Z",
          "updatedAt": "2020-03-22T16:44:20Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 22/03/2020 16:44, Christopher Wood wrote:\n>> Would be v. happy to know if that made sense to others.\n> \n> It makes sense, I'm just not not sure it's worth the cost. \n\nYep. Me neither. It is cheaper than padding to 254 octets\nfor everyone though;-)\n\nPartly, I'm not that sympathetic towards anyone who\nwants to hide a crazily-long server_name. OTOH, I guess\nthere may be a few who can't easily change names so we\nprobably ought try do something for 'em.\n\nCheers,\nS.\n\n> That said,\n> this will always be an imperfect solution, so I'm happy either way.\n> \n> \n",
          "createdAt": "2020-03-22T16:48:26Z",
          "updatedAt": "2020-03-22T16:48:26Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> > I don't understand the focus on server input to a padding function that would ideally fill out one packet.\r\n> \r\n> Per [David's comment](https://github.com/tlswg/draft-ietf-tls-esni/pull/209#issuecomment-600322366) above, clients _could_ use help from servers in choosing appropriate padding lengths. (Only servers know their name anonymity set.)\r\n\r\nAgree that only servers could know their name anonymity set. But what is the cost of always padding out the ClientHello so it approaches the MTU? Just trying to understand why the spec attempts to economize on the number of bytes in the ClientHello packet.",
          "createdAt": "2020-03-24T00:19:13Z",
          "updatedAt": "2020-03-24T00:19:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> But what is the cost of always padding out the ClientHello so it approaches the MTU?\r\n\r\nAs far as I know, there's no reason other than folks might not want to always \"waste\" these bytes.",
          "createdAt": "2020-03-24T20:34:31Z",
          "updatedAt": "2020-03-24T20:34:31Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Padding the ClientHello up to an MTU isn't free. See the numbers here on what a 400-byte increase costs.\r\nhttps://www.imperialviolet.org/2018/04/11/pqconftls.html\r\n\r\nLikewise, also from that post and a [later experiment](https://www.imperialviolet.org/2019/10/30/pqsivssl.html), post-quantum key shares will likely exceed a packet anyway. I think our padding scheme should be designed with that expectation in mind (e.g., the `minimum_inner_length` mechanism fails this because a PQ key share in the inner ClientHello will blow past the built-in server assumptions on client behavior). Canary builds of Chrome already have code for such a thing behind a flag.\r\n\r\nEdit: Added a link to the later experiment, which I'd forgotten was a separate post.",
          "createdAt": "2020-03-24T21:04:12Z",
          "updatedAt": "2020-03-24T21:07:37Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> Padding the ClientHello up to an MTU isn't free. See the numbers here on what a 400-byte increase costs.\r\n> https://www.imperialviolet.org/2018/04/11/pqconftls.html\r\n\r\nIt's not quite clear what's going on in those results. For example, the mobile results are close to zero. Without seeing confidence intervals, and the distributions of the full packet sizes, I don't think this experiment settles this issue (although it could, with more detail). Also, is there a theory on /why/ 400 bytes might add latency?\r\n\r\n> Likewise, also from that post and a [later experiment](https://www.imperialviolet.org/2019/10/30/pqsivssl.html), post-quantum key shares will likely exceed a packet anyway. \r\n\r\nIf we're going to design the padding mechanism with PQ key shares in mind, but not conventional ones, that should be in the document.\r\n",
          "createdAt": "2020-03-25T03:49:27Z",
          "updatedAt": "2020-03-25T03:49:27Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It's not quite clear what's going on in those results. For example, the mobile results are close to zero. Without seeing confidence intervals, and the distributions of the full packet sizes, I don't think this experiment settles this issue (although it could, with more detail). Also, is there a theory on /why/ 400 bytes might add latency?\r\n\r\n@agl would know the details of that experiment, but I don't think the idea that sending more bytes takes more time would be terribly surprising! :-P\r\n\r\n> If we're going to design the padding mechanism with PQ key shares in mind, but not conventional ones, that should be in the document.\r\n\r\nI don't think anyone's suggested designing without conventional key shares in mind. They are what's deployed today, after all. However, we shouldn't design *only* for a small unpadded ClientHello. PQ key shares will need larger ones. Session tickets also go in the ClientHello, and it's common for TLS servers to stick client certificates inside tickets, so you can already get large ones today already.",
          "createdAt": "2020-03-25T18:06:08Z",
          "updatedAt": "2020-03-25T18:06:08Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> > It's not quite clear what's going on in those results. For example, the mobile results are close to zero. Without seeing confidence intervals, and the distributions of the full packet sizes, I don't think this experiment settles this issue (although it could, with more detail). Also, is there a theory on /why/ 400 bytes might add latency?\r\n> \r\n> @agl would know the details of that experiment, but I don't think the idea that sending more bytes takes more time would be terribly surprising! :-P\r\n\r\nLet's assume the results for \"SI\" in the first link actually do show a significant delta. The question is whether per-packet costs dominate or per-byte costs do, and whether the experiment sometimes increased the number of packets (e.g. by sometimes bumping the ultimate ClientHello size above 1280). See Section 5.1 in https://www.usenix.org/system/files/conference/atc12/atc12-final186.pdf for device performance metrics on bytes vs packets.\r\n\r\nLooking at the ClientHello traffic on my computer, I can see that Safari is sending ClientHello messages that are about 500-600 bytes. My copy of Chrome seems to be sending CurveCECPQ2 (16696?) shares, and its ClientHello messages are fragmented.",
          "createdAt": "2020-03-25T19:36:23Z",
          "updatedAt": "2020-03-25T19:36:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd will you be able to update this as above?",
          "createdAt": "2020-03-27T17:42:48Z",
          "updatedAt": "2020-03-27T17:42:48Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "would the spec allow me to put an arbitrarily-sized extension in the encrypted part of the ClientHello? if so, I don't care about the padding schemes.",
          "createdAt": "2020-03-29T05:32:52Z",
          "updatedAt": "2020-03-29T05:32:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> would the spec allow me to put an arbitrarily-sized extension in the encrypted part of the ClientHello? if so, I don't care about the padding schemes.\r\n\r\nYes, of course! The padding policies described here are guidance at best.",
          "createdAt": "2020-03-29T15:39:55Z",
          "updatedAt": "2020-03-29T15:39:55Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've updated the PR to try reflect the discussion above. Please take a peek and see if it seems useful now.",
          "createdAt": "2020-04-02T13:53:26Z",
          "updatedAt": "2020-04-02T13:53:26Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "This looks like the right idea. I'll review this again as well, but it's probably better to wait for @chris-wood's suggestions to be addressed.",
          "createdAt": "2020-04-04T21:17:46Z",
          "updatedAt": "2020-04-04T21:17:46Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for all the changes Chris. I think I've actioned all those as requested. If not, I tried, but failed:-)",
          "createdAt": "2020-04-04T21:33:38Z",
          "updatedAt": "2020-04-04T21:33:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd do you need any help moving this forward?",
          "createdAt": "2020-04-07T13:46:51Z",
          "updatedAt": "2020-04-07T13:46:51Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 07/04/2020 14:47, Christopher Wood wrote:\n> @sftcd do you need any help moving this forward?\n>\nDoing other stuff today but feel free to take the text\nand then do more edits. Or I can look at it tomorrow.\nEither's fine by me.\n\nS.\n",
          "createdAt": "2020-04-07T13:51:12Z",
          "updatedAt": "2020-04-07T13:51:12Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> On 07/04/2020 14:47, Christopher Wood wrote: @sftcd do you need any help moving this forward?\r\n> Doing other stuff today but feel free to take the text and then do more edits. \r\n\r\nThanks for taking the time. None of my comments are strongly-held opinions (meaning they only need to be addressed at all if others agree that the issues are important).\r\n\r\n",
          "createdAt": "2020-04-08T00:02:47Z",
          "updatedAt": "2020-04-08T00:02:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Strong +1 to @sayrer -- thank you for the work here, @sftcd!",
          "createdAt": "2020-04-08T00:27:26Z",
          "updatedAt": "2020-04-08T00:27:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd can you please resolve conflicts? @ekr @kazuho can you please review?",
          "createdAt": "2020-04-23T21:27:32Z",
          "updatedAt": "2020-04-23T21:27:32Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 24/04/2020 16:07, ekr wrote:\n> @ekr commented on this pull request.\n> \n> I am generally fine with this, with the exception of the random\n> padding, which I think should be omitted. It's hard to analyze and\n> the value is unclear. In particular, many clients will retry if they\n> receive TCP errors, and so the attacker can learn information about\n> the true minimum value by forging TCP RSTs and looking at the new\n> CH.\n\nFair point. The argument I'd make for keeping this\nis that if an anonymity set has ~80% of names <32\noctets, then if we do nothing, passive observation\nwill probably reveal when the server name is in\nthe longest ~20%. And I'd guess that only a few\nnames in that set would be popular/common, so we\ncould be giving away the game whenever an ECHO\nis 32 octets longer than the usual. The random\npadding could mitigate that passive attack but\nyes would be vulnerable to an active reset based\ncounter.\n\nI'd also be fine with just living with the issue\nin which case we might want to note that using\nECHO with uncommonly long names is a bad idea.\n\n> \n>> +and randomly add another 32 octets 50% of the time and then\n>> include that amount\n> +of additional padding.\n> \n> I actually don't think we should recommend the random padding. Let's\n> do the minimum here.\n> \n\n",
          "createdAt": "2020-04-24T15:15:50Z",
          "updatedAt": "2020-04-24T15:15:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's just drop the random addition. Servers don't (can't) do a padding check anyway, so clients can always choose to make this longer if desired.",
          "createdAt": "2020-04-24T16:38:05Z",
          "updatedAt": "2020-04-24T16:38:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd can you update this PR and resolve the conflicts?",
          "createdAt": "2020-04-24T16:38:18Z",
          "updatedAt": "2020-04-24T16:38:18Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "\"Fair point. The argument I'd make for keeping this\r\nis that if an anonymity set has ~80% of names <32\r\noctets, then if we do nothing, passive observation\r\nwill probably reveal when the server name is in\r\nthe longest ~20%. \"\r\n\r\nWhich is precisely why we want the server to provide the longest name, so the client can pad to it.\r\n",
          "createdAt": "2020-04-24T16:52:49Z",
          "updatedAt": "2020-04-24T16:52:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on today's call, let's do the following:\r\n\r\n1. Resolve merge conflicts.\r\n2. Drop random padding for the SNI. And add text which says that if the client's name is larger than max_name_length, it rounds up to the nearest 32B or 64B boundary.\r\n\r\n@sftcd do you need, or would you like, any help with this?",
          "createdAt": "2020-04-27T21:49:56Z",
          "updatedAt": "2020-04-27T21:49:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0ODUwNDM4",
          "commit": {
            "abbreviatedOid": "18d5638"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think that this approach is generally better, but it runs afoul of divergence in client configuration that could dominate the calculation.  For instance, a client that sends two key shares will have very different padding requirements to one that sends only one.  For that to work, we need to assume that implementation-/deployment-specific variation of the inner CH is largely eliminated as a result of the compression scheme we adopt.  That also assumes that these variations in client behaviour are not privacy-sensitive.  \r\n\r\nI think that we should be directly acknowledging those assumptions if that is indeed the case.\r\n\r\nIf there is a significant variation in size due to client-specific measures, then we're in a bit of an awkward position.  That might render any similarly simple scheme ineffective.  For instance, a client that later supports a set of ALPN identifiers that could vary in length depending on context cannot use this signal directly. It has to apply its own logic about the padding of that extension.  That a client is doing this won't be known to a server that deploys this today. In that case, the advice from the server (which knows most about the anonymity set across which it is hoping to spread the resulting CH), isn't going to be forced through an additional filter at the client.  The results are unlikely to be good without a great deal of care.",
          "createdAt": "2020-03-16T00:11:26Z",
          "updatedAt": "2020-03-16T00:23:38Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nthe plaintext is at least this long.\r\n```",
              "createdAt": "2020-03-16T00:11:27Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nGiven that extensions could be defined in the future that reveal sensitive information\r\nthrough their length, we cannot describe all the ways in which length information\r\n```",
              "createdAt": "2020-03-16T00:13:15Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\n  of the plaintext encoding of ClienHelloInner is greater than\r\n```",
              "createdAt": "2020-03-16T00:14:05Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 59,
              "body": "What about the converse?  Is it an error to send something that is not padded to the minimum length?",
              "createdAt": "2020-03-16T00:14:43Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1Mjk4Mzk4",
          "commit": {
            "abbreviatedOid": "18d5638"
          },
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-16T14:58:33Z",
          "updatedAt": "2020-03-16T14:58:33Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I think I'd say no, that's maybe better not treated as an error. But I could be convinced otherwise.",
              "createdAt": "2020-03-16T14:58:33Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NzA0OTQ0",
          "commit": {
            "abbreviatedOid": "9103fde"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the update! This looks like generally what we want. I left some recommendations for editorial improvements. ",
          "createdAt": "2020-04-04T14:39:33Z",
          "updatedAt": "2020-04-04T15:13:08Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Could we move this paragraph to the security considerations? ",
              "createdAt": "2020-04-04T14:39:33Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 32,
              "body": "Could we move this content to its own sub-section, perhaps with the title, \"Recommended Padding Scheme,\" to reflect the fact that it's optional?",
              "createdAt": "2020-04-04T14:43:05Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nFuture extensions could reveal sensitive information through their length. Consequently, \r\npadding should be flexible and support arbitrary extension changes. \r\n```",
              "createdAt": "2020-04-04T14:54:38Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nThe target padding length of most ClientHello extensions can be determined without server help.\r\n```",
              "createdAt": "2020-04-04T14:55:28Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nHowever, the \"server_name\" extension could benefit from server input (ECHOConfig.maximum_name_length). \r\nClients SHOULD compute the padding for this extension as follows:\r\n\r\n1. If ECHOConfig.maximum_name_length is longer than the actual server_name then \r\nclients SHOULD add padding to make up that difference.\r\n2. Otherwise, if ECHOConfig.maximum_name_length is zero or less than the length \r\nof the actual server_name then round the server_name up to a multiple of 32 octets \r\nand randomly add another 32 octets 50% of the time and then include that amount\r\nof additional padding.\r\n```",
              "createdAt": "2020-04-04T15:09:07Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 52,
              "body": "```suggestion\r\nThe amount of padding applied to the ClientHello is then computed as the sum of \r\nall per-extension padding values, rounded up to the nearest multiple of 32. \r\n(This additional rounding step aims to hide variance across different client\r\nimplementations.)\r\n```",
              "createdAt": "2020-04-04T15:09:19Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nIn addition to padding ClientHelloInner, clients and servers will also need\r\nto pad all other handshake messages that have sensitive-length fields. For\r\nexample, if a client proposes ALPN values in ClientHelloInner, the\r\nserver-selected value will be returned in an EncryptedExtension, so that\r\nhandshake message also needs to be padded using TLS record layer padding.\r\n```",
              "createdAt": "2020-04-04T15:09:32Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nadded or removed from the anonymity set during the lifetime of a particular\r\n```",
              "createdAt": "2020-04-04T15:10:29Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 42,
              "body": "Can we also merge this paragraph with the preceding one?",
              "createdAt": "2020-04-04T15:12:35Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NzYyMzQ2",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-04T21:59:52Z",
          "updatedAt": "2020-04-04T22:06:15Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "nit: this is a run-on sentence. Suggest breaking at \"...then this value can be set to zero. In that case, ...\"",
              "createdAt": "2020-04-04T21:59:52Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 42,
              "body": "Is this part right? Do clients need to consider padding for each field, or just the entire encrypted ClientHelloInner?",
              "createdAt": "2020-04-04T22:01:01Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 53,
              "body": "Suggest: \"add at least another 32 octets\".",
              "createdAt": "2020-04-04T22:03:44Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 75,
              "body": "Suggest: \"Variations in the length of the ClientHelloInner ciphertext...\"",
              "createdAt": "2020-04-04T22:05:44Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 64,
              "body": "Is there a good reference for \"TLS record layer padding\"? I think I know what this means, but it could be clearer.",
              "createdAt": "2020-04-04T22:05:49Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MjgwMTEy",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-06T14:02:29Z",
          "updatedAt": "2020-04-06T14:02:29Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "It's defined in Section 5.4 of RFC8446: https://tools.ietf.org/html/rfc8446#section-5.4",
              "createdAt": "2020-04-06T14:02:29Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MjgwODI4",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-06T14:03:14Z",
          "updatedAt": "2020-04-06T14:03:14Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Yep -- this is what was discussed way up above in this PR. ",
              "createdAt": "2020-04-06T14:03:14Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4ODk0ODM3",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T08:27:18Z",
          "updatedAt": "2020-04-07T08:27:18Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Ok, I will re-read this PR, since I don't get it.\r\n\r\nBut, even so, I think this section needs a rationale. It says \"clients need to determine how much to pad given the semantics of that field\", but there is no reason given.",
              "createdAt": "2020-04-07T08:27:18Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4OTAzODcx",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T08:39:05Z",
          "updatedAt": "2020-04-07T08:39:06Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Maybe that reference suggests a terminology issue. It says \"All encrypted TLS records can be padded to inflate the size of the TLSCiphertext.\" Does ECHO define things in terms of TLSCiphertext?\r\n\r\nI don't necessarily think there is a problem here, but in the two code bases I've read (rustls and NSS), the encrypted SNI or ClientHello haven't fit in all that cleanly.\r\n\r\nIt seems like the properties of the ClientHelloInner encryption are bit hand-wavy. I understand what's trying to be accomplished (and support that effort), but I think more explanatory text could be called for.\r\n",
              "createdAt": "2020-04-07T08:39:05Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MDYwMTA0",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T12:22:06Z",
          "updatedAt": "2020-04-07T12:28:11Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Or \"add one or more blocks of 32 octets\" just to exclude behaviours that undo the effect of rounding the padding to a multiple of 32 octets.  ",
              "createdAt": "2020-04-07T12:22:06Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 109,
              "body": "Do we need to update GREASE if we are rounding the packet sizes to multiples of 32 octets? If we want GREASE to look like ECHO then it should have the same external properties. ",
              "createdAt": "2020-04-07T12:26:53Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTE3OTc2",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T13:31:42Z",
          "updatedAt": "2020-04-07T13:31:42Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "\ud83d\udc4d to N >= 1 blocks. Clients can choose the distribution from which they want to sample N.",
              "createdAt": "2020-04-07T13:31:42Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTMxODI2",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T13:46:36Z",
          "updatedAt": "2020-04-07T13:46:36Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Yep -- there's a TODO in the GREASE section.",
              "createdAt": "2020-04-07T13:46:36Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTQzMzQ5",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T13:58:26Z",
          "updatedAt": "2020-04-07T13:58:27Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "On second thoughts, we should probably match what's done in encrypted DNS, because otherwise we could create a potential leak from correlating the DNS request length with the ECHO length. ",
              "createdAt": "2020-04-07T13:58:26Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODg3NzEw",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-12T19:19:52Z",
          "updatedAt": "2020-04-12T19:19:52Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I moved that rationale down to the security considerations section as suggested earlier. It could be moved back up, but basically anything where the length could be sensitive may need padding.",
              "createdAt": "2020-04-12T19:19:52Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODg4MjQx",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-12T19:27:03Z",
          "updatedAt": "2020-04-12T19:27:04Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Don't think copying DNS is correct. RFC 8467 calls for queries to be padded to a multiple of 128 octets and could be that the server-name is not the only sensitive name. \r\n\r\nI'm not sure there's a point in recommending against zero additional blocks of 32 - so long as you don't do zero too often it'd be ok. If you look back to the name lengths seen in the data I have it may be that zero additional blocks 50% of the time is ok. \r\n\r\nBut mainly, I'd say we may be better to wait 'till we have a few implementations and then see what makes best sense.",
              "createdAt": "2020-04-12T19:27:04Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODk5MTAz",
          "commit": {
            "abbreviatedOid": "abd6637"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-12T22:09:36Z",
          "updatedAt": "2020-04-12T22:09:36Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "> Don't think copying DNS is correct. RFC 8467 calls for queries to be padded to a multiple of 128 octets and could be that the server-name is not the only sensitive name.\r\n\r\nCan you show that there is no information leakage if the two aren't in sync?\r\n\r\n> I'm not sure there's a point in recommending against zero additional blocks of 32 - so long as you don't do zero too often it'd be ok. If you look back to the name lengths seen in the data I have it may be that zero additional blocks 50% of the time is ok.\r\n\r\nThe proposal above suggests N >= 1, not zero. In any case, as you suggest, spinning our wheels on something for which there is no backing data or analysis (yet) seems premature.",
              "createdAt": "2020-04-12T22:09:36Z",
              "updatedAt": "2020-04-12T22:09:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NTQ0NTky",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-23T23:26:45Z",
          "updatedAt": "2020-04-23T23:26:45Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Hmm, is this resolved?",
              "createdAt": "2020-04-23T23:26:45Z",
              "updatedAt": "2020-04-23T23:26:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDMwMTE3",
          "commit": {
            "abbreviatedOid": "abd6637"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I am generally fine with this, with the exception of the random padding, which I think should be omitted. It's hard to analyze and the value is unclear. In particular, many clients will retry if they receive TCP errors, and so the attacker can learn information about the true minimum value by forging TCP RSTs and looking at the new CH.",
          "createdAt": "2020-04-24T15:05:26Z",
          "updatedAt": "2020-04-24T15:07:01Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "I actually don't think we should recommend the random padding. Let's do the minimum here.",
              "createdAt": "2020-04-24T15:05:26Z",
              "updatedAt": "2020-04-24T15:07:01Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7d53f5b6985242c18e1a988104090dc1f08a4d74",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "abd6637cd2910dae0d3001a1d3edd41779dc4be4",
      "mergeCommit": {
        "oid": "aa15d6e4d5ec406d9c0c8f782284df5b543d0510"
      }
    },
    {
      "number": 210,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxMTE4OTgz",
      "title": "Fix lingering encrypted_server_name extension references.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/210",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-19T16:50:19Z",
      "updatedAt": "2020-03-19T16:50:56Z",
      "closedAt": "2020-03-19T16:50:56Z",
      "mergedAt": "2020-03-19T16:50:56Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "db1d9a793c0640f03750612a4fd2be7bfe8f30b5",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/nits",
      "headRefOid": "fd4d0004abb16ecc0ec50b73019d5cae342d64ed",
      "mergeCommit": {
        "oid": "9dab0e191c85d2043a5a5c835fae0abed30625da"
      }
    },
    {
      "number": 211,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkyNDczNzIz",
      "title": "Remove OPEN ISSUE regarding an explicit ECHO negotiated signal.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/211",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-23T15:57:23Z",
      "updatedAt": "2020-03-24T21:26:14Z",
      "closedAt": "2020-03-24T21:26:14Z",
      "mergedAt": "2020-03-24T21:26:14Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9dab0e191c85d2043a5a5c835fae0abed30625da",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/require-trial-decryption",
      "headRefOid": "f9ec40b7d40313da6a4da55abb5d9fca39e56696",
      "mergeCommit": {
        "oid": "4f57a871f670c2b291652ed5bca4c77ec5913f19"
      }
    },
    {
      "number": 212,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkyNTY5NDA2",
      "title": "Bind CHOuter to CHInner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/212",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This makes it so that changes to the outer CH do not affect the inner. If anything does change that might muck with the binder or decryption, then ECHO is ignored. (This should help GREASE.)",
      "createdAt": "2020-03-23T18:43:59Z",
      "updatedAt": "2020-05-20T15:59:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9dab0e191c85d2043a5a5c835fae0abed30625da",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/outer-binder",
      "headRefOid": "0c351a6651eb9b2319b5c3e97b82a2226417e713",
      "closedAt": "2020-05-20T15:59:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NzY5Nzky",
          "commit": {
            "abbreviatedOid": "867f908"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T19:47:56Z",
          "updatedAt": "2020-03-23T19:47:56Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Just noticed this \"and and\"",
              "createdAt": "2020-03-23T19:47:56Z",
              "updatedAt": "2020-03-23T20:18:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5Nzg5NTcz",
          "commit": {
            "abbreviatedOid": "867f908"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T20:17:28Z",
          "updatedAt": "2020-03-23T20:17:28Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Thanks :)",
              "createdAt": "2020-03-23T20:17:28Z",
              "updatedAt": "2020-03-23T20:18:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzM1MzU0",
          "commit": {
            "abbreviatedOid": "0c351a6"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-24T22:14:14Z",
          "updatedAt": "2020-03-24T22:21:13Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "This probably wants an extra sentence that you add the identity and binder to the PSK extension. At first I was confused what you did with the binder.",
              "createdAt": "2020-03-24T22:14:15Z",
              "updatedAt": "2020-03-24T22:21:13Z"
            },
            {
              "originalPosition": 43,
              "body": "(Hah. Nice!)",
              "createdAt": "2020-03-24T22:20:47Z",
              "updatedAt": "2020-03-24T22:21:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 213,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAwMTY3MDgz",
      "title": "README: fix links to WG docs",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/213",
      "state": "MERGED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-07T10:03:56Z",
      "updatedAt": "2020-04-13T15:04:03Z",
      "closedAt": "2020-04-13T15:04:03Z",
      "mergedAt": "2020-04-13T15:04:03Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4f57a871f670c2b291652ed5bca4c77ec5913f19",
      "headRepository": "Lekensteyn/draft-ietf-tls-esni",
      "headRefName": "pwu/readme-fixes",
      "headRefOid": "0106d1fe3ee5b249ff67fe883fa64c05d3a43e65",
      "mergeCommit": {
        "oid": "fef6612491aca10725d7ca7f9e1b7a3af8af5aa0"
      }
    },
    {
      "number": 221,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA2NjQ4ODE0",
      "title": "Rearrange sentences for better readability",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/221",
      "state": "MERGED",
      "author": "d1vyank",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-21T12:41:38Z",
      "updatedAt": "2020-04-24T18:55:04Z",
      "closedAt": "2020-04-24T18:55:04Z",
      "mergedAt": "2020-04-24T18:55:04Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMTk1MjYx",
          "commit": {
            "abbreviatedOid": "bdab7ed"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-24T18:54:58Z",
          "updatedAt": "2020-04-24T18:54:58Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "fef6612491aca10725d7ca7f9e1b7a3af8af5aa0",
      "headRepository": "d1vyank/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "bdab7ede73b13362fff475c8f7783e8578ade1a6",
      "mergeCommit": {
        "oid": "6858521382b4c14d6ce1ef4d0b211eab90a45b63"
      }
    },
    {
      "number": 222,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA3MDM5MzQ4",
      "title": "Fix outdated references to ESNIConfig",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/222",
      "state": "MERGED",
      "author": "d1vyank",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-22T04:33:39Z",
      "updatedAt": "2020-04-23T21:26:33Z",
      "closedAt": "2020-04-23T21:26:33Z",
      "mergedAt": "2020-04-23T21:26:33Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NDg5MDk2",
          "commit": {
            "abbreviatedOid": "c0fff68"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-23T21:26:26Z",
          "updatedAt": "2020-04-23T21:26:26Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "fef6612491aca10725d7ca7f9e1b7a3af8af5aa0",
      "headRepository": "d1vyank/draft-ietf-tls-esni",
      "headRefName": "nits",
      "headRefOid": "c0fff68851844847d14165fa0d1c1b6e75df5e0a",
      "mergeCommit": {
        "oid": "188c6a13fe29f468762542aea79f33ccc08170e6"
      }
    },
    {
      "number": 224,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEwMzE3ODA5",
      "title": "Replace ECHOConfig TLS ciphersuites with HPKE code points.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/224",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #218.\r\n\r\nA given ECHOConfig now lists a single HPKE public key, with the corresponding\r\nKEM identifier, and a list of acceptable AEAD and KDF algorithm identifiers.\r\nClients may then choose their preferred AEAD and KDF algorithms for ClientHello\r\nencryption.\r\n\r\nWe may need to provide some guidance, either here or in the HPKE document, about acceptable (KEM, KDF, AEAD) tuples. \r\n\r\ncc @bifurcation",
      "createdAt": "2020-04-28T19:36:29Z",
      "updatedAt": "2020-05-04T20:38:25Z",
      "closedAt": "2020-05-01T23:34:07Z",
      "mergedAt": "2020-05-01T23:34:07Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I hadn't realized these were separate IDs. Oh well.",
          "createdAt": "2020-05-01T23:33:47Z",
          "updatedAt": "2020-05-01T23:33:47Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "HpkeCipherSuite should also be used in ClientEncryptedCH.",
          "createdAt": "2020-05-04T20:26:10Z",
          "updatedAt": "2020-05-04T20:26:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops -- thanks, @ocheron! Fixed here: https://github.com/tlswg/draft-ietf-tls-esni/pull/231.",
          "createdAt": "2020-05-04T20:38:16Z",
          "updatedAt": "2020-05-04T20:38:25Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6858521382b4c14d6ce1ef4d0b211eab90a45b63",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hpke-codepoints",
      "headRefOid": "e7c73326b7c507ef455a0edea3eb24fac73594ce",
      "mergeCommit": {
        "oid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92"
      }
    },
    {
      "number": 225,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyMzg0NTYz",
      "title": "Deterministic padding",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/225",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This builds on #209, but removes the probabilistic pieces. I created a fresh PR to make review easier. \r\n\r\ncc @sftcd",
      "createdAt": "2020-05-02T02:04:54Z",
      "updatedAt": "2020-05-03T23:58:40Z",
      "closedAt": "2020-05-03T23:58:40Z",
      "mergedAt": "2020-05-03T23:58:40Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjU1MDI3",
          "commit": {
            "abbreviatedOid": "4cc7421"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-05-03T20:35:28Z",
          "updatedAt": "2020-05-03T20:41:35Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "This text seems a bit confusing because clients typically offer a fixed set of ALPNs for a given application.  Perhaps:\r\n\r\n\"Clients typically support a small number of application profiles. For instance, a browser might support HTTP with ALPN values [\"http/1.1, \"h2\"] and WebRTC media with ALPNs [\"webrtc\", \"c-webrtc\"]. Clients SHOULD pad this extension by rounding up to the total size of the longest ALPN extension across all application profiles\".\r\n",
              "createdAt": "2020-05-03T20:35:28Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            },
            {
              "originalPosition": 78,
              "body": "Say we just padded SNI and L = 0 and D = 10. We then compute the per-extension padding value as 22, but because of this paragraph we pad by 32? If so, I don't think this works, because if D was 11, we would also pad by 32, so now we are leaking the length of D.",
              "createdAt": "2020-05-03T20:40:26Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjYzNzM3",
          "commit": {
            "abbreviatedOid": "4cc7421"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T22:31:51Z",
          "updatedAt": "2020-05-03T22:31:51Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Discussed offline -- will remove and consider later on, as this exists to mask fixed-length values across different stacks, and fingerprinting stacks is already pretty trivial.",
              "createdAt": "2020-05-03T22:31:51Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjY0NDQ0",
          "commit": {
            "abbreviatedOid": "82e87bc"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-05-03T22:41:05Z",
          "updatedAt": "2020-05-03T22:41:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwMDEy",
          "commit": {
            "abbreviatedOid": "82e87bc"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:50:59Z",
          "updatedAt": "2020-05-03T23:50:59Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "This might be a little narrow a view.  In a browser, we have a bunch of things we might do.  But that is because the browser is platform.  But the anonymity set on a different platform (say you used the system TLS stack) is potentially wider (all apps) and cannot make the same claim about application profiles.",
              "createdAt": "2020-05-03T23:50:59Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwMDcx",
          "commit": {
            "abbreviatedOid": "82e87bc"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:51:39Z",
          "updatedAt": "2020-05-03T23:53:50Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "```suggestion\r\nhint, i.e., ECHOConfig.maximum_name_length.\r\n```",
              "createdAt": "2020-05-03T23:51:39Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwMjk3",
          "commit": {
            "abbreviatedOid": "82e87bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:54:13Z",
          "updatedAt": "2020-05-03T23:54:13Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "The point is that the \"platform,\" be it the stack used in the browser or in the OS, typically defines the set of values here and should pad accordingly. I'm fine with using the browser as an example here, as it's just a specific instance of that platform.",
              "createdAt": "2020-05-03T23:54:13Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/padding",
      "headRefOid": "fd78562ba6c9b8f6dd088ce51539dd2af461a04e",
      "mergeCommit": {
        "oid": "2f891d33205621199ef8e946a6416a9bee470006"
      }
    },
    {
      "number": 226,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE0MTY4",
      "title": "Provide guidance on ECHOConfig extension usage.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/226",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #216.\r\n\r\ncc @davidben, @bemasc, @mikebishop, @sftcd, @enygren",
      "createdAt": "2020-05-02T22:01:51Z",
      "updatedAt": "2020-05-07T18:43:33Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/ext-policy",
      "headRefOid": "de1eb1297d5f9375ae15586a8cb38cd2eb32ab98",
      "closedAt": "2020-05-07T18:43:32Z",
      "mergedAt": "2020-05-07T18:43:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f238f70420dbbab6085f959ce970e77d34e506e3"
      },
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "This looks fine, though I'll note that since an HTTPSSVC record is public and the outer ClientHello record is public, it's not unreasonable to pull values from there to put in the public fields since the observer already knows (or can get) them.  Restricting them to come only from the ECHOConfig seems unnecessary.\r\n\r\nI think the key observation in this PR is that the outer ClientHello isn't _really_ offering to establish a TLS connection -- it's a not-crazy-looking wrapper for the actual ClientHello inside the ECHO extension, and the vehicle for the recovery flow.  The only things a server can legitimately do are respond to the inner ClientHello or do a recovery handshake.  Thus, most of the things you might set on the outer ClientHello are irrelevant; they can be chosen to look innocuous, chosen at random, or copied from the inner ClientHello as the implementation chooses.",
          "createdAt": "2020-05-04T18:55:14Z",
          "updatedAt": "2020-05-04T18:55:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben, does this seem reasonable to you?",
          "createdAt": "2020-05-05T18:32:16Z",
          "updatedAt": "2020-05-05T18:32:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTc0Mjgx",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-03T01:45:14Z",
          "updatedAt": "2020-05-03T01:45:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjY4MDgy",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:27:52Z",
          "updatedAt": "2020-05-03T23:30:25Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "features or protections",
              "createdAt": "2020-05-03T23:27:53Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 19,
              "body": "Comma",
              "createdAt": "2020-05-03T23:28:17Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 38,
              "body": "SHOULD? ",
              "createdAt": "2020-05-03T23:28:58Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 43,
              "body": "Except, as we have discussed, the length, though I guess that is a part of the outer, too.",
              "createdAt": "2020-05-03T23:30:20Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwNDA0",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:55:10Z",
          "updatedAt": "2020-05-03T23:55:11Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Yep, I'm considering that part of the outer.",
              "createdAt": "2020-05-03T23:55:10Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwNDQ1",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:55:40Z",
          "updatedAt": "2020-05-03T23:55:40Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Isn't protection a feature?",
              "createdAt": "2020-05-03T23:55:40Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwNjA0",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:57:21Z",
          "updatedAt": "2020-05-03T23:57:22Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Will fix here and elsewhere!",
              "createdAt": "2020-05-03T23:57:22Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwNjI4",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:57:39Z",
          "updatedAt": "2020-05-03T23:57:40Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I read them both the same, so that works for me.",
              "createdAt": "2020-05-03T23:57:40Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE0MzQ3",
          "commit": {
            "abbreviatedOid": "27dcc7b"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:03:20Z",
          "updatedAt": "2020-05-05T20:05:39Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "functionality?",
              "createdAt": "2020-05-05T20:03:20Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 66,
              "body": "Or, I guess, as ECHOConfigV2, right?",
              "createdAt": "2020-05-05T20:05:05Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 73,
              "body": "I'm not sure there is a need to be this directive here. Why not leave this for future work.\r\n\r\nAlso, hypothetically, suppose that the extension was like \"make the nonce twice as long\"\r\n\r\n",
              "createdAt": "2020-05-05T20:05:34Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE5MzMz",
          "commit": {
            "abbreviatedOid": "27dcc7b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:11:05Z",
          "updatedAt": "2020-05-05T20:11:06Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Functionality is a bit more general -- let's go with that!",
              "createdAt": "2020-05-05T20:11:06Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTIyNjY1",
          "commit": {
            "abbreviatedOid": "27dcc7b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:16:04Z",
          "updatedAt": "2020-05-05T20:16:04Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Yeah, I'll add that: \"as ECHOConfig extensions, or an entirely new version of ECHOConfig.\"",
              "createdAt": "2020-05-05T20:16:04Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTMzMDI2",
          "commit": {
            "abbreviatedOid": "de1eb12"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:32:14Z",
          "updatedAt": "2020-05-05T20:32:15Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "That's fair (and a good point). It is a bit... restrictive. I just removed the sentence.",
              "createdAt": "2020-05-05T20:32:15Z",
              "updatedAt": "2020-05-05T20:32:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NzM4NDA3",
          "commit": {
            "abbreviatedOid": "de1eb12"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Seems reasonable.",
          "createdAt": "2020-05-07T18:41:03Z",
          "updatedAt": "2020-05-07T18:41:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 227,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE2Mzc3",
      "title": "Clarify \"do not stick out\" signals.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/227",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #215.\r\n\r\ncc @grittygrease ",
      "createdAt": "2020-05-02T22:23:28Z",
      "updatedAt": "2020-05-05T20:09:07Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/signals",
      "headRefOid": "6285d8fc9f4268146fdc6a4ae71f2589021c8641",
      "closedAt": "2020-05-05T20:09:07Z",
      "mergedAt": "2020-05-05T20:09:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1337c6915b0de26ddb98c4c44324d2572dead76f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE2MTQw",
          "commit": {
            "abbreviatedOid": "30f0e72"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-05T20:06:03Z",
          "updatedAt": "2020-05-05T20:06:36Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nsignal indicating use or negotiation of ECHO. Clients MAY GREASE the\r\n```",
              "createdAt": "2020-05-05T20:06:04Z",
              "updatedAt": "2020-05-05T20:08:57Z"
            },
            {
              "originalPosition": 21,
              "body": "This sentence is pretty long. Also, I would not use \"suspicious\" but rather \"unusual\" or \"meaningful\"",
              "createdAt": "2020-05-05T20:06:32Z",
              "updatedAt": "2020-05-05T20:08:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE3NTQ5",
          "commit": {
            "abbreviatedOid": "63dccdc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:08:15Z",
          "updatedAt": "2020-05-05T20:08:15Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Will fix!",
              "createdAt": "2020-05-05T20:08:15Z",
              "updatedAt": "2020-05-05T20:08:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 228,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE3MDc5",
      "title": "Clarify need for optional record digests.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/228",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #205.\r\n\r\ncc @huitema ",
      "createdAt": "2020-05-02T22:30:52Z",
      "updatedAt": "2020-05-03T23:31:40Z",
      "closedAt": "2020-05-03T14:05:08Z",
      "mergedAt": "2020-05-03T14:05:07Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTY2MTUy",
          "commit": {
            "abbreviatedOid": "3fac6b3"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Works for me.",
          "createdAt": "2020-05-02T22:45:05Z",
          "updatedAt": "2020-05-02T22:45:05Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/optional-digests",
      "headRefOid": "3fac6b33e11b9e7e88de96b6c2ca55eaba337598",
      "mergeCommit": {
        "oid": "02b26097b42890c7273216c196b33d4050565920"
      }
    },
    {
      "number": 230,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE4NDc0",
      "title": "Add information about per-client tracking via unique ECHOConfig structures",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/230",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #146.",
      "createdAt": "2020-05-02T22:45:49Z",
      "updatedAt": "2020-05-05T20:10:26Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/tracking",
      "headRefOid": "e3df7ba582baa1cfdfd6e910d1b47bba0cc8ea4e",
      "closedAt": "2020-05-05T20:10:26Z",
      "mergedAt": "2020-05-05T20:10:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e8f1fa948d271428e33493e962680fee4adca5e0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjY3NzE3",
          "commit": {
            "abbreviatedOid": "0f32404"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:23:19Z",
          "updatedAt": "2020-05-03T23:27:12Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "A paragraph break here might be good. You jump from description of the attack to a description of mitigating factors without segue. ",
              "createdAt": "2020-05-03T23:23:19Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            },
            {
              "originalPosition": 13,
              "body": "I don't think the v6 example is good. And none of these are especially strong, except perhaps the DNS one. \r\n\r\nFor me, the question is how targeted the delivery could be, and whether the client can then do anything about that. For instance, a client might decide to flush its ECHO config cache if it moves and wants to be unlinkable.",
              "createdAt": "2020-05-03T23:27:07Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcxMDU0",
          "commit": {
            "abbreviatedOid": "0f32404"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-04T00:02:27Z",
          "updatedAt": "2020-05-04T00:02:27Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "@martinthomson I'll remove the last sentence, not because of v6 (which I do think is a good example), but because it can probably bite us in the future when someone does turn it into a threat. :)\r\n\r\nOn the latter points, how about the following:\r\n\r\nThe cost of this type of attack scales linearly with the desired number of target clients. DNS caching behavior makes targeting individual users for extended periods of time, e.g., using per-client ECHOConfig structures delivered via HTTPSSVC RRs with high TTLs, challenging. Moreover, clients can flush any ECHOConfig state upon changing networks to mitigate potential linkability problems.",
              "createdAt": "2020-05-04T00:02:27Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDA3MDA4",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T17:32:07Z",
          "updatedAt": "2020-05-05T17:32:08Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Is the thinking here that the client might have some ECHOConfig state outside the DNS cache, or is this just saying the client could flush its DNS cache on network change? An attacker that can distribute per-client ECHOConfigs in DNS could just as easily distribute per-client A/AAAA records in DNS. (Well, A may be hard due to address scarcity, but AAAA should be doable.) So if you're concerned about this attack, you probably want to treat this as a DNS-wide issue and drop the entire DNS cache.",
              "createdAt": "2020-05-05T17:32:07Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDE0ODc4",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T17:42:41Z",
          "updatedAt": "2020-05-05T17:42:41Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Indeed -- in practice it'll likely be the entire cache. I didn't want to include other state (V4 or V6) to make any assumption on what the cache might contain, be it the DNS cache or something else. Is this just too generic for your taste?",
              "createdAt": "2020-05-05T17:42:41Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDIyMjAw",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T17:52:31Z",
          "updatedAt": "2020-05-05T17:52:31Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Mostly a clarifying question. Though perhaps we should say \"flushing any DNS state\" instead of flushing any ECHOConfig state\". Or perhaps \"flushing any DNS or ECHOConfig state\". Or maybe we leave it along because too many words. :-)",
              "createdAt": "2020-05-05T17:52:31Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDI4NTk2",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T18:00:46Z",
          "updatedAt": "2020-05-05T18:00:47Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I'm fine with \"flushing any DNS or ECHOConfig state\"!",
              "createdAt": "2020-05-05T18:00:46Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDQyODY3",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T18:20:10Z",
          "updatedAt": "2020-05-05T18:20:10Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "SGTM",
              "createdAt": "2020-05-05T18:20:10Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE2ODY5",
          "commit": {
            "abbreviatedOid": "bb6c1a3"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:07:13Z",
          "updatedAt": "2020-05-05T20:07:14Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nRRs with high TTLs, challenging. Clients can help mitigate this problem by\r\n```",
              "createdAt": "2020-05-05T20:07:13Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE2OTEy",
          "commit": {
            "abbreviatedOid": "bb6c1a3"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-05T20:07:16Z",
          "updatedAt": "2020-05-05T20:07:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 231,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEzMTcyMzA3",
      "title": "Fix remaining HPKE issues.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/231",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-04T20:38:06Z",
      "updatedAt": "2020-05-04T20:38:32Z",
      "closedAt": "2020-05-04T20:38:32Z",
      "mergedAt": "2020-05-04T20:38:31Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2f891d33205621199ef8e946a6416a9bee470006",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hpke-nits",
      "headRefOid": "a5a9ce65e9e196c4e4584fd88c0768fbb8f1688b",
      "mergeCommit": {
        "oid": "f00e1f070cd55813ac56fc9f6c4ac22ab5cb5b56"
      }
    },
    {
      "number": 234,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE2NDEyMjk1",
      "title": "Describe known active attacks",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/234",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #229.\r\n\r\nThis is for motivating some of our design decisions (and documenting what we know along the way). I meant to do this a while ago, but never got around to it. In particular, it describes why we have the following three bindings:\r\n\r\n1. Transcript to ECHO secret (to prevent client reaction attacks).\r\n2. CH1 to CH2 (to prevent HRR oracles).\r\n3. ClientHello to resumption PSK binder (to prevent resumption oracles).\r\n\r\nI'm *sure* the language and presentation can be improved, so suggestions to that effect are very much welcome!\r\n\r\ncc @martinthomson, @davidben, @dmcardle, @jhoyla, @kazuho, @karthikbhargavan, @grittygrease ",
      "createdAt": "2020-05-12T00:09:56Z",
      "updatedAt": "2020-05-21T13:07:55Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f238f70420dbbab6085f959ce970e77d34e506e3",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/active-attacks",
      "headRefOid": "df869d1ceac0fcfc951e710006cf078bb06dac3a",
      "closedAt": "2020-05-21T13:07:55Z",
      "mergedAt": "2020-05-21T13:07:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1e7e0d9ef6fc33984240891b0f30cf139c45a193"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the feedback! I incorporated your suggestions and clarified a few more things. I'm merging as-is since they seemed mostly editorial.",
          "createdAt": "2020-05-21T13:07:32Z",
          "updatedAt": "2020-05-21T13:07:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODI4Mjk4",
          "commit": {
            "abbreviatedOid": "7eb76ae"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-05-21T01:53:59Z",
          "updatedAt": "2020-05-21T02:04:24Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nThis section describes the rationale for ECHO properties and mechanics as defenses\r\n```",
              "createdAt": "2020-05-21T01:53:59Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nagainst active attacks. In all the attacks below, the attacker is on-path between\r\n```",
              "createdAt": "2020-05-21T01:54:10Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nabout the inner ClientHello, such as the true SNI value.\r\n```",
              "createdAt": "2020-05-21T01:54:24Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nThis attack uses the client's reaction to an incorrect certificate as an oracle.\r\n```",
              "createdAt": "2020-05-21T01:54:52Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nThe attacker intercepts a legitimate ClientHello and replies with a\r\n```",
              "createdAt": "2020-05-21T01:55:14Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 52,
              "body": "This isn't the attack I was thinking of. Rather, you withhold CV and so any client which does cert verification first will fail.",
              "createdAt": "2020-05-21T01:58:26Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 75,
              "body": "```suggestion\r\nto decrypt the Certificate and abort the connection.\r\n```",
              "createdAt": "2020-05-21T02:00:35Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 83,
              "body": "I think you need to say something about how this had to legitimately be an HRR case. Or can the attacker force it?",
              "createdAt": "2020-05-21T02:01:50Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 85,
              "body": "Note that this only works if the server (arguably incorrectly) stores the SNI from CH1.",
              "createdAt": "2020-05-21T02:02:27Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 85,
              "body": "```suggestion\r\nand HelloRetryRequest exchange with the result that the server encrypts the certificate to the attacker.\r\n```",
              "createdAt": "2020-05-21T02:02:57Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODM1MTA2",
          "commit": {
            "abbreviatedOid": "7eb76ae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T02:17:25Z",
          "updatedAt": "2020-05-21T02:17:25Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "That seems like a different variation, so I'll just note it. Thanks!",
              "createdAt": "2020-05-21T02:17:25Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODM1MjE3",
          "commit": {
            "abbreviatedOid": "7eb76ae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T02:17:49Z",
          "updatedAt": "2020-05-21T02:17:49Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Good point. I'll call out that assumption explicitly.",
              "createdAt": "2020-05-21T02:17:49Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODM1Mjcy",
          "commit": {
            "abbreviatedOid": "7eb76ae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T02:18:00Z",
          "updatedAt": "2020-05-21T02:18:00Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Yep! I'll note that, too. ",
              "createdAt": "2020-05-21T02:18:00Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 235,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE4Njg3Nzc4",
      "title": "Suggest size of GREASE encrypted_ch extension value.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/235",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This assumes the GREASE threat model is a misbehaving and lazy middlebox. That is, we aim to prevent ossification. It does nothing more to prevent an active attacker from learning whether or not a particular connection used GREASE. (That problem is probably better suited to something like MASQUE.)\r\n\r\ncc @davidben @ekr @martinthomson",
      "createdAt": "2020-05-15T16:29:25Z",
      "updatedAt": "2020-05-20T15:58:32Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f238f70420dbbab6085f959ce970e77d34e506e3",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/grease-size",
      "headRefOid": "cab69382afbc78bfd4df71f3004d1bc47017b303",
      "closedAt": "2020-05-20T15:58:32Z",
      "mergedAt": "2020-05-20T15:58:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5005670f318da0a19868a8858dc4c473e8bc3825"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging for now. We can come back later and address followup extensions if needed!",
          "createdAt": "2020-05-20T15:58:28Z",
          "updatedAt": "2020-05-20T15:58:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyODA2NDQ1",
          "commit": {
            "abbreviatedOid": "cab6938"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-15T16:44:03Z",
          "updatedAt": "2020-05-15T16:44:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 236,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxNTQ1NDg5",
      "title": "s/ECHO/ECH",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/236",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #232.",
      "createdAt": "2020-05-21T19:44:27Z",
      "updatedAt": "2020-05-22T03:12:05Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1e7e0d9ef6fc33984240891b0f30cf139c45a193",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/ech",
      "headRefOid": "4a37e99a9db136efe1941e2c54b962dbe6f72a77",
      "closedAt": "2020-05-21T19:49:50Z",
      "mergedAt": "2020-05-21T19:49:50Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "c4d4b7f531f85d72f7bb50755d1106f51287bfdc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDgyNjAw",
          "commit": {
            "abbreviatedOid": "4a37e99"
          },
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T20:51:08Z",
          "updatedAt": "2020-05-21T20:51:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "TLS Encrypted ClientHello \u2014> TECH!\r\n\r\n(Kidding, kidding)",
              "createdAt": "2020-05-21T20:51:09Z",
              "updatedAt": "2020-05-21T20:51:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTM4ODY0",
          "commit": {
            "abbreviatedOid": "4a37e99"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T22:36:29Z",
          "updatedAt": "2020-05-21T22:36:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Hah!",
              "createdAt": "2020-05-21T22:36:29Z",
              "updatedAt": "2020-05-21T22:36:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NjE2NDY3",
          "commit": {
            "abbreviatedOid": "4a37e99"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T02:52:55Z",
          "updatedAt": "2020-05-22T02:52:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Seeing this, I think that you should remove 1.3 from the title.  Sure, this is 1.3 only, but I think that this design is fine for 1.4 also.  If it isn't, I'm sure we can deal with that eventually.  I don't want to find that we ship a 1.4 (or 4) that is compatible with this and have people tell me that it isn't compatible.",
              "createdAt": "2020-05-22T02:52:56Z",
              "updatedAt": "2020-05-22T02:52:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NjIxNjQw",
          "commit": {
            "abbreviatedOid": "4a37e99"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T03:12:04Z",
          "updatedAt": "2020-05-22T03:12:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That's a fair point. I'll make that change in a separate PR!",
              "createdAt": "2020-05-22T03:12:05Z",
              "updatedAt": "2020-05-22T03:12:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 238,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzNDY3MjE4",
      "title": "Remove TLS 1.3 from the title, and re-categorize as a ST document.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/238",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Seeing no pushback on the list, this moves the draft from Experimental to ST.",
      "createdAt": "2020-05-26T21:14:10Z",
      "updatedAt": "2020-05-26T21:17:19Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "c4d4b7f531f85d72f7bb50755d1106f51287bfdc",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/retitle-and-recategorize",
      "headRefOid": "d86a8ea8f1c23a6d4e67f384c94dbad3dd3a4268",
      "closedAt": "2020-05-26T21:17:19Z",
      "mergedAt": "2020-05-26T21:17:19Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "a522e66aab86f9db0ce73edb999339887fa5a8ff"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4Njg0ODA0",
          "commit": {
            "abbreviatedOid": "a4fc9e8"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-26T21:15:34Z",
          "updatedAt": "2020-05-26T21:15:34Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "If we are going to change the title, let's make it match the abbrev\r\n\r\n\"TLS Encrypted Client Hello\"",
              "createdAt": "2020-05-26T21:15:34Z",
              "updatedAt": "2020-05-26T21:16:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4Njg0OTIx",
          "commit": {
            "abbreviatedOid": "a4fc9e8"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-26T21:15:45Z",
          "updatedAt": "2020-05-26T21:15:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4Njg1MzA4",
          "commit": {
            "abbreviatedOid": "a4fc9e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-26T21:16:24Z",
          "updatedAt": "2020-05-26T21:16:24Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Works for me!",
              "createdAt": "2020-05-26T21:16:24Z",
              "updatedAt": "2020-05-26T21:16:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 239,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzNDc1ODk1",
      "title": "Specify encrypted_client_hello and outer_extension codepoints.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/239",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Once we have some implementations that interop, we'll go ahead with early\r\ncodepoint allocation.\r\n\r\nThe new version matches -07, which will be the next draft version we submit.\r\n\r\ncc @martinthomson @grittygrease \r\n\r\nCloses #220.",
      "createdAt": "2020-05-26T21:34:38Z",
      "updatedAt": "2020-05-27T21:48:53Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a522e66aab86f9db0ce73edb999339887fa5a8ff",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/codepoints",
      "headRefOid": "16070b4d44fdf7a350765ecbe65ef58fe495ba34",
      "closedAt": "2020-05-27T21:48:52Z",
      "mergedAt": "2020-05-27T21:48:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "37854299237b63b0731bfd7c2399cbe80f82d662"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 241,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI0MTMzOTIy",
      "title": "Remove stale TODOs.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/241",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The misrouting content no longer applies since the backend server sees the full CH, with the true SNI.",
      "createdAt": "2020-05-27T21:56:17Z",
      "updatedAt": "2020-05-27T21:56:38Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "37854299237b63b0731bfd7c2399cbe80f82d662",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/remove-stale-todos",
      "headRefOid": "32f9d2bff330bb426838540d239e54631c84f377",
      "closedAt": "2020-05-27T21:56:38Z",
      "mergedAt": "2020-05-27T21:56:38Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "24f09934836f920a0f883be65207afb6d40f67be"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 242,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NjA3MjQy",
      "title": "Revert to experimental codepoints.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/242",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We'll request early codepoints after we get some implementation experience.",
      "createdAt": "2020-05-31T12:50:33Z",
      "updatedAt": "2020-05-31T18:45:45Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "24f09934836f920a0f883be65207afb6d40f67be",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/exp-codepoints",
      "headRefOid": "bfaf546a247080946e0ecbf45c7d05ece047af34",
      "closedAt": "2020-05-31T18:45:45Z",
      "mergedAt": "2020-05-31T18:45:45Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ed0b844eb2742f2820b9bd6b5829f493c36e628f"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I have no objection to echo_nonce -> echo_nonce_value but did you mean to do it in this PR?\r\n\r\nYeah, as I was specifying the extension codepoint I noticed the collision between this variable, so I figured changing it here was best.",
          "createdAt": "2020-05-31T18:45:41Z",
          "updatedAt": "2020-05-31T18:45:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTE2OTcw",
          "commit": {
            "abbreviatedOid": "bfaf546"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I have no objection to echo_nonce -> echo_nonce_value but did you mean to do it in this PR?",
          "createdAt": "2020-05-31T18:25:47Z",
          "updatedAt": "2020-05-31T18:25:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 243,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI3NTgxMDQ2",
      "title": "empty or random record digest for privacy",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/243",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed on the list, add a small bit of text in the section 10.3 to outline the behavior of clients seeking to protect server's privacy.",
      "createdAt": "2020-06-04T04:29:30Z",
      "updatedAt": "2020-06-04T23:51:37Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ed0b844eb2742f2820b9bd6b5829f493c36e628f",
      "headRepository": "huitema/draft-ietf-tls-esni",
      "headRefName": "record-digest-privacy",
      "headRefOid": "acdf2cc48fdbc2b2ff47f103787c9efd0e6c5aef",
      "closedAt": "2020-06-04T23:51:36Z",
      "mergedAt": "2020-06-04T23:51:36Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a40e95338385ef628cff3896ed61c31939143dd0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0OTAzMTE1",
          "commit": {
            "abbreviatedOid": "e04d483"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for clarifying! I suggested some language tweaks, but the core idea remains. ",
          "createdAt": "2020-06-04T23:30:47Z",
          "updatedAt": "2020-06-04T23:32:43Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\n\"encrypted_client_hello\" extension. In such settings, clients send \r\neither an empty record_digest or a randomly generated record_digest\r\nin the ClientEncryptedCH. (The precise implementation choice for this\r\nmechanism is out of scope for this document.) Servers in these settings \r\nmust perform trial decryption since they cannot identify the client's chosen \r\nECH key using the record_digest value. As a result, support for optional \r\nrecord digests may exacerbate DoS attacks.\r\n```",
              "createdAt": "2020-06-04T23:30:47Z",
              "updatedAt": "2020-06-04T23:48:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0OTExMjkz",
          "commit": {
            "abbreviatedOid": "acdf2cc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-06-04T23:51:32Z",
          "updatedAt": "2020-06-04T23:51:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 244,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI4MTEyNDE0",
      "title": "Fix typo of \"ClientHelloInner\".",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/244",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-04T21:57:51Z",
      "updatedAt": "2020-06-04T23:27:15Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ed0b844eb2742f2820b9bd6b5829f493c36e628f",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "5264fbf087a9c3c63f444562517522c2662588af",
      "closedAt": "2020-06-04T23:27:15Z",
      "mergedAt": "2020-06-04T23:27:15Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3dca4fddac8ca04c430ef8348427241a67cca83b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0OTAwODQy",
          "commit": {
            "abbreviatedOid": "5264fbf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-04T23:27:10Z",
          "updatedAt": "2020-06-04T23:27:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 246,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2MDE3NDU1",
      "title": "Adopt new HTTPS RR name.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/246",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://datatracker.ietf.org/doc/draft-ietf-dnsop-svcb-https/. Hopefully this one sticks.",
      "createdAt": "2020-06-17T18:16:41Z",
      "updatedAt": "2020-06-18T02:33:07Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a40e95338385ef628cff3896ed61c31939143dd0",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/https-rr",
      "headRefOid": "eb764befd43ec4a827757effb39449d7cf253d25",
      "closedAt": "2020-06-18T02:33:06Z",
      "mergedAt": "2020-06-18T02:33:06Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "cb08c09093b1c6119707516a93ea9a008dc47139"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 247,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2MDI3OTY3",
      "title": "Expand text around security and privacy goals.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/247",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #245.",
      "createdAt": "2020-06-17T18:39:45Z",
      "updatedAt": "2020-06-18T08:48:35Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a40e95338385ef628cff3896ed61c31939143dd0",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/expand-goals",
      "headRefOid": "2ce972f8b8236b16ea214fefb0ab925693097598",
      "closedAt": "2020-06-18T02:34:01Z",
      "mergedAt": "2020-06-18T02:34:01Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "675704cf71d2f090368a8dbbf5f50197519a1493"
      },
      "comments": [
        {
          "author": "sharpie7",
          "authorAssociation": "NONE",
          "body": "Thanks. The changes look to cover my point in #245.",
          "createdAt": "2020-06-18T08:48:35Z",
          "updatedAt": "2020-06-18T08:48:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNjkyMjAy",
          "commit": {
            "abbreviatedOid": "b59c873"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T19:03:01Z",
          "updatedAt": "2020-06-17T19:03:02Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Same ECHConfig is necessary, but not sufficient I think. If the hosts share an ECHConfig but have not other TLS config (the deleted paragraph above), the hosts are distinguishable. (I've lost track of whether the current level of ClientHello binding is sufficient to limit this to anonymity within the negotiated values or the full config...) The third paragraph mentions this, but it seems to be clarifying point (2), but point (2) doesn't actually imply this.",
              "createdAt": "2020-06-17T19:03:01Z",
              "updatedAt": "2020-06-17T19:21:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNjkzMjcz",
          "commit": {
            "abbreviatedOid": "b59c873"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T19:04:41Z",
          "updatedAt": "2020-06-17T19:04:41Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Fair :) I was trying to get away without too much text. I can clarify that this is necessary (and rework text accordingly).",
              "createdAt": "2020-06-17T19:04:41Z",
              "updatedAt": "2020-06-17T19:21:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNjk3MDU5",
          "commit": {
            "abbreviatedOid": "c48746c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T19:10:08Z",
          "updatedAt": "2020-06-17T19:10:08Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "@davidben, reworked. Please have another look!",
              "createdAt": "2020-06-17T19:10:08Z",
              "updatedAt": "2020-06-17T19:21:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzAzNjU3",
          "commit": {
            "abbreviatedOid": "1630c00"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-17T19:19:50Z",
          "updatedAt": "2020-06-17T19:20:11Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Super nitpicky nitpick: we can probably trim the \"For example, [...]\" sentence down to:\r\n\r\nFor example, if a client-facing server services many backend origin hosts, only one of which supports some cipher suite, it may be possible to identify that host based on the contents of unencrypted handshake messages.\r\n\r\n(It's already giving an example, and being more specific uses fewer words.)",
              "createdAt": "2020-06-17T19:19:50Z",
              "updatedAt": "2020-06-17T19:21:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzA0MzEx",
          "commit": {
            "abbreviatedOid": "1630c00"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T19:20:48Z",
          "updatedAt": "2020-06-17T19:20:49Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Works for me -- thanks!",
              "createdAt": "2020-06-17T19:20:49Z",
              "updatedAt": "2020-06-17T19:21:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 249,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQwMzA5MTgw",
      "title": "Move to Standards track.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/249",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-25T23:39:37Z",
      "updatedAt": "2020-06-27T15:50:42Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "675704cf71d2f090368a8dbbf5f50197519a1493",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/std",
      "headRefOid": "3b4fa8dbe997161eb2ab4eee5e7560c22ecd3fe1",
      "closedAt": "2020-06-27T15:50:41Z",
      "mergedAt": "2020-06-27T15:50:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ce728f09363ef83341d77ba6f7d9d9b2732bd053"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 250,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU5NDc3ODQ1",
      "title": "Fix typo caused by rename from ECHO to ECH.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/250",
      "state": "MERGED",
      "author": "orrc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes a minor search/replace mistake in #236.",
      "createdAt": "2020-07-30T18:25:11Z",
      "updatedAt": "2020-07-31T00:14:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ce728f09363ef83341d77ba6f7d9d9b2732bd053",
      "headRepository": "orrc/draft-ietf-tls-esni",
      "headRefName": "patch-1",
      "headRefOid": "b5bc766a6e44e430779032cf753d661ed61310da",
      "closedAt": "2020-07-31T00:11:28Z",
      "mergedAt": "2020-07-31T00:11:28Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d322c0f5b695b623f8d0630df6e821ab2a00bae5"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops. :-)",
          "createdAt": "2020-07-31T00:11:24Z",
          "updatedAt": "2020-07-31T00:11:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODQyNjIy",
          "commit": {
            "abbreviatedOid": "b5bc766"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-31T00:11:18Z",
          "updatedAt": "2020-07-31T00:11:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 254,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY0ODIzNzk1",
      "title": "Lint the document",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/254",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR replaces \". \" (period followed by one space) with \".  \" (period followed by two spaces) and ensures each line is at most 80 characters. No other changes (editorial or otherwise) are intended.",
      "createdAt": "2020-08-07T20:54:36Z",
      "updatedAt": "2020-08-10T19:41:40Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d322c0f5b695b623f8d0630df6e821ab2a00bae5",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "d322c0f5b695b623f8d0630df6e821ab2a00bae5",
      "closedAt": "2020-08-10T19:41:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 255,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY1Njk4MTgz",
      "title": "Lint",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/255",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This ensures that each paragraph line breaks at 80 characters. No other change is intended (editorial or otherwise).",
      "createdAt": "2020-08-10T19:53:09Z",
      "updatedAt": "2020-08-11T13:01:41Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d322c0f5b695b623f8d0630df6e821ab2a00bae5",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "edit1",
      "headRefOid": "1edc81121901c44dda39aba55401aba579aeb4e9",
      "closedAt": "2020-08-10T19:54:16Z",
      "mergedAt": "2020-08-10T19:54:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fca62c225d87cc8403c847358285c2c69c5ef647"
      },
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do you want to borrow the linter that we use in QUIC?  Just copy [these lines](https://github.com/quicwg/base-drafts/blob/1373d195146a5a0d5ea911816ecb6d813b129545/Makefile#L15-L26) to your Makefile along with [this script](https://github.com/quicwg/base-drafts/blob/master/.lint.py).",
          "createdAt": "2020-08-11T01:40:19Z",
          "updatedAt": "2020-08-11T01:40:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Brilliant!",
          "createdAt": "2020-08-11T13:01:41Z",
          "updatedAt": "2020-08-11T13:01:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTMzNDA3",
          "commit": {
            "abbreviatedOid": "1edc811"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-10T19:54:12Z",
          "updatedAt": "2020-08-10T19:54:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 256,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY1NzEyOTU3",
      "title": "Editorial",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/256",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- Use the term \"plaintext\" consistently.\r\n- Be consistent about the number of spaces following a period. (We'll go with one.)\r\n- Editorial changes to Sec.1-3.",
      "createdAt": "2020-08-10T20:23:46Z",
      "updatedAt": "2020-08-10T23:05:37Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "fca62c225d87cc8403c847358285c2c69c5ef647",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "edit1",
      "headRefOid": "c6a2ae2ee2a783478ba0cefba3dc4ebb932fa520",
      "closedAt": "2020-08-10T23:05:37Z",
      "mergedAt": "2020-08-10T23:05:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f182eae1482934f7dfdc4846ff78d2bdcf610b8e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjE1MjIx",
          "commit": {
            "abbreviatedOid": "ba5b747"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "LGTM modulo some nits. Thanks!",
          "createdAt": "2020-08-10T21:55:35Z",
          "updatedAt": "2020-08-10T22:05:15Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nThe TLS Working Group has studied the problem of protecting the SNI, but has\r\n```",
              "createdAt": "2020-08-10T21:55:36Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nThe protocol specified by this document takes a different approach. It assumes\r\n```",
              "createdAt": "2020-08-10T21:55:54Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 63,
              "body": "```suggestion\r\nThis protocol is designed to operate in one of two topologies illustrated\r\n```",
              "createdAt": "2020-08-10T21:56:47Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 98,
              "body": "```suggestion\r\nand backend servers are physically separated.\r\n```",
              "createdAt": "2020-08-10T21:58:18Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 131,
              "body": "```suggestion\r\nClientHelloInner message) and then encrypts this message using the ECH public key. It then\r\n```",
              "createdAt": "2020-08-10T22:00:28Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 142,
              "body": "```suggestion\r\nUpon receiving ClientHelloOuter, the client-facing server processes the encrypted\r\n```",
              "createdAt": "2020-08-10T22:01:41Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 142,
              "body": "Since decryption may fail",
              "createdAt": "2020-08-10T22:01:48Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\nterminates the TLS connection with the client. Importantly, the provider does not have access\r\nto the plaintext of the connection.\r\n```",
              "createdAt": "2020-08-10T22:05:06Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjIzMTg5",
          "commit": {
            "abbreviatedOid": "84cd441"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T22:11:44Z",
          "updatedAt": "2020-08-10T22:11:44Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "ack",
              "createdAt": "2020-08-10T22:11:44Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjIzMjQ5",
          "commit": {
            "abbreviatedOid": "84cd441"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T22:11:52Z",
          "updatedAt": "2020-08-10T22:11:52Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "fixing",
              "createdAt": "2020-08-10T22:11:52Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjI1MDIw",
          "commit": {
            "abbreviatedOid": "84cd441"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T22:15:49Z",
          "updatedAt": "2020-08-10T22:15:50Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "When I first read this document, I thought the fact that the SNI was sent in the clear from the client-facing server to the backend server was an attack. As such, I think we want to be explicit about this assumption. This seems like a reasonable place to do so since we're talking about the parties in the protocol and how they communicate with one another.",
              "createdAt": "2020-08-10T22:15:50Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjI2MDk1",
          "commit": {
            "abbreviatedOid": "907ff3d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T22:18:01Z",
          "updatedAt": "2020-08-10T22:18:01Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "There's a couple reasons I push back here: (1) the connection might not be long-lived, and (2) the threat we're mostly concerned with is the client<->client-facing-server snooper (an adversary which sees client-facing-server<->backend connections might learn the SNI if it were not encrypted, but it wouldn't learn the client's IP. Basically, this is too restrictive of a threat model, and somewhat orthogonal to the protocol itself. ",
              "createdAt": "2020-08-10T22:18:01Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjQ0OTk0",
          "commit": {
            "abbreviatedOid": "c6a2ae2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-10T23:05:32Z",
          "updatedAt": "2020-08-10T23:05:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 257,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2MDkzMzk1",
      "title": "Adopt QUIC linter, and fix some issues flagged.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/257",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks, @martinthomson!",
      "createdAt": "2020-08-11T13:08:05Z",
      "updatedAt": "2020-08-11T13:08:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f182eae1482934f7dfdc4846ff78d2bdcf610b8e",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/adopt-quic-linter",
      "headRefOid": "d134dac10ae79ecd680267a95cea7f123e8d6d14",
      "closedAt": "2020-08-11T13:08:59Z",
      "mergedAt": "2020-08-11T13:08:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2d31c5f0a63c4dc238cdfc9d51089ae4a647b75d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 258,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2MTE5OTgw",
      "title": "Fix superfluous padding edge cases.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/258",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks, @bemasc, for raising this! ",
      "createdAt": "2020-08-11T13:53:49Z",
      "updatedAt": "2020-08-11T14:12:00Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2d31c5f0a63c4dc238cdfc9d51089ae4a647b75d",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/fix-padding",
      "headRefOid": "456b6496dfe1d5f74a2d4a272e53f98c3ecf9e1f",
      "closedAt": "2020-08-11T14:12:00Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the improvement.  Note that this formula still has no length ambiguity when L == 31 and D == 32.  It's not clear to me whether that's consistent with the design goal.",
          "createdAt": "2020-08-11T13:59:17Z",
          "updatedAt": "2020-08-11T13:59:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing.",
          "createdAt": "2020-08-11T14:12:00Z",
          "updatedAt": "2020-08-11T14:12:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 259,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2MjYyNjIw",
      "title": "WIP: Editorial changes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/259",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The PR contains several \"TODOs\" that must be resolved for merging this.",
      "createdAt": "2020-08-11T17:57:49Z",
      "updatedAt": "2020-08-13T19:37:30Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2d31c5f0a63c4dc238cdfc9d51089ae4a647b75d",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "edit",
      "headRefOid": "c9a3ebdd7e0eb458a2eaf04452328a2587cea744",
      "closedAt": "2020-08-13T19:37:30Z",
      "mergedAt": "2020-08-13T19:37:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5f86ef0a0bdcfce58a606de4a216213ebbed1a4d"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Three TODOs remain.\r\nLet me know before you merge, I'd like to roll these into a single commit.",
          "createdAt": "2020-08-13T18:47:01Z",
          "updatedAt": "2020-08-13T18:47:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2Mjg3MDQx",
          "commit": {
            "abbreviatedOid": "fb053ab"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-08-12T21:22:43Z",
          "updatedAt": "2020-08-12T21:42:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\u2764\ufe0f ",
              "createdAt": "2020-08-12T21:22:43Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 4,
              "body": "Agreed. Let's make an issue for this (and remove the TODO)!",
              "createdAt": "2020-08-12T21:23:07Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 204,
              "body": "`enc` matches HPKE, so I think we should keep it as is.",
              "createdAt": "2020-08-12T21:26:32Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 33,
              "body": "I'm not sure this level of detail is needed here. Perhaps we can simply say, \"The client determines whether ECH was accepted or rejected and proceeds accordingly. The details for each procedure are described in {{section}}.\"",
              "createdAt": "2020-08-12T21:27:24Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 39,
              "body": "I don't think this is needed (here).",
              "createdAt": "2020-08-12T21:27:46Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 79,
              "body": "That's true. We can rewrite this as a paragraph, e.g., saying \"The remaining contents of the `ECHConfig` structure are an opaque byte string...\"",
              "createdAt": "2020-08-12T21:29:47Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 118,
              "body": "I think we should revert this change. The padding scheme specifically applies to the ClientHelloInner.",
              "createdAt": "2020-08-12T21:30:44Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 159,
              "body": "I don't think this is necessary. The version field speaks for itself, and this section doesn't add much. Can we remove this?",
              "createdAt": "2020-08-12T21:32:28Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 188,
              "body": "That's a good idea, yep!",
              "createdAt": "2020-08-12T21:33:24Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 197,
              "body": "How about `config_digest`?",
              "createdAt": "2020-08-12T21:33:56Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 216,
              "body": "```suggestion\r\nWhen the client-facing server accepts ECH, it does not send this extension. When it\r\n```",
              "createdAt": "2020-08-12T21:34:58Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 235,
              "body": "```suggestion\r\nThis document also defines the \"ech_required\" alert, which clients MUST send\r\n```",
              "createdAt": "2020-08-12T21:35:45Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 239,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-08-12T21:35:54Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 250,
              "body": "Can we remove this TODO and make it an issue?",
              "createdAt": "2020-08-12T21:36:23Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 278,
              "body": "Good point. We should probably shuffle things around.",
              "createdAt": "2020-08-12T21:36:58Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 276,
              "body": "It probably doesn't. Can you find a better home for it?",
              "createdAt": "2020-08-12T21:37:34Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 300,
              "body": "Yes -- each KDF has an associated hash function.",
              "createdAt": "2020-08-12T21:37:49Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 313,
              "body": "I'm not sure this is correct -- let's remove this and track it in a separate issue.",
              "createdAt": "2020-08-12T21:39:58Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 319,
              "body": "It makes sure that the outer extension contents are not modified.",
              "createdAt": "2020-08-12T21:40:12Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 325,
              "body": "By redundant do you mean identical?",
              "createdAt": "2020-08-12T21:40:52Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzAwMjIz",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:47:02Z",
          "updatedAt": "2020-08-12T21:47:02Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "Ack, removing TODO",
              "createdAt": "2020-08-12T21:47:02Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzAxMzIw",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:49:09Z",
          "updatedAt": "2020-08-12T21:49:09Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "The high-level description is incomplete, since it doesn't talk about how the client processes the server's response. I think it's good to be complete, even if high-level.",
              "createdAt": "2020-08-12T21:49:09Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzAyNjk2",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:51:57Z",
          "updatedAt": "2020-08-12T21:51:58Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "As written, the \"ech_nonce\" section comes out of nowhere, since it's purpose isn't articulated until \"security considerations\". My view is that any code point defined in the spec needs to be mentioned in the overview. In fact, I would include \"outer_extensions\" here, too.",
              "createdAt": "2020-08-12T21:51:58Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzAzMDE5",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:52:40Z",
          "updatedAt": "2020-08-12T21:52:40Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "Not until I understand the PSK story. I'll leave this unresolved for now.",
              "createdAt": "2020-08-12T21:52:40Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzAzMzcx",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:53:22Z",
          "updatedAt": "2020-08-12T21:53:23Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Sure, but this isn't the right place for it. It's a tiny part of the protocol. We can describe inline below when it arises. ",
              "createdAt": "2020-08-12T21:53:23Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzAzNjQ3",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:53:54Z",
          "updatedAt": "2020-08-12T21:53:54Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "What I proposed was high level, I think. We should avoid redundancies in the spec where possible. ",
              "createdAt": "2020-08-12T21:53:54Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzA2MTAy",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:58:59Z",
          "updatedAt": "2020-08-12T21:59:00Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "From the spec, it seems like all that's required of the KDF is that it's an \"extract-then-expand\" KDF:\r\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hpke-05#section-4\r\n\r\nIn fact, the currently assigned code points are all for HKDF:\r\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hpke-05#section-7.2\r\n\r\nBut AFAICT there's no requirement that the KDF always have some underlying hash function. As an alternative to HKDF, one can imagine a dedicated primitive that satisfies the extract-then-expand API but is not constructed from a hash function.\r\n\r\nSorry if this is nit-picky :) ",
              "createdAt": "2020-08-12T21:58:59Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzA3MTU2",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:01:03Z",
          "updatedAt": "2020-08-12T22:01:03Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "I see your point. Let's replace this with `Extract` instead of `Hash` and call it a day.",
              "createdAt": "2020-08-12T22:01:03Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzA3NTg0",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:01:50Z",
          "updatedAt": "2020-08-12T22:01:51Z",
          "comments": [
            {
              "originalPosition": 319,
              "body": "Is there a specific attack this prevents?",
              "createdAt": "2020-08-12T22:01:51Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzA4NDQ4",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:03:33Z",
          "updatedAt": "2020-08-12T22:03:34Z",
          "comments": [
            {
              "originalPosition": 325,
              "body": "I mean that I would shallow-copy any extension that appears in both the inner and outer CH. The computational overhead is low, it reduces the size of the outer CH, and it seems simpler than shallow-copying select things. (Suppose someone else invents another big extension after ECH is implemented.)",
              "createdAt": "2020-08-12T22:03:34Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzEwMDA2",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:06:55Z",
          "updatedAt": "2020-08-12T22:06:55Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I think of it as a gentle introduction to the protocol flow, which, IMO, aids understanding later on. I think the slight redundancy is worth it. If you don't think it is, then I'll revert this.",
              "createdAt": "2020-08-12T22:06:55Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzEwMzMy",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:07:40Z",
          "updatedAt": "2020-08-12T22:07:41Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "Well, that would change the protocol. Better to make it an issue?",
              "createdAt": "2020-08-12T22:07:40Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzExNDA3",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:10:06Z",
          "updatedAt": "2020-08-12T22:10:07Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "Yep!",
              "createdAt": "2020-08-12T22:10:07Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzExNjcw",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:10:36Z",
          "updatedAt": "2020-08-12T22:10:37Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Let's flush it out first and then we can decide if it's too deep? I commented on WIP text.",
              "createdAt": "2020-08-12T22:10:36Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzEyNzY0",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:12:54Z",
          "updatedAt": "2020-08-12T22:12:54Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/260",
              "createdAt": "2020-08-12T22:12:54Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzEzNzY5",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:14:57Z",
          "updatedAt": "2020-08-12T22:14:57Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Ack, moving TODO to section on ech_nonce.",
              "createdAt": "2020-08-12T22:14:57Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzE2NDEw",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:20:45Z",
          "updatedAt": "2020-08-12T22:20:45Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/261",
              "createdAt": "2020-08-12T22:20:45Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzIwODQy",
          "commit": {
            "abbreviatedOid": "78254d3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:30:29Z",
          "updatedAt": "2020-08-12T22:30:29Z",
          "comments": [
            {
              "originalPosition": 313,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/262",
              "createdAt": "2020-08-12T22:30:29Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzIyMTE2",
          "commit": {
            "abbreviatedOid": "6aed3e4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:33:23Z",
          "updatedAt": "2020-08-12T22:33:23Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Sounds good, I don't see your comment though.",
              "createdAt": "2020-08-12T22:33:23Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzQ0NDQ0",
          "commit": {
            "abbreviatedOid": "6aed3e4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T23:32:30Z",
          "updatedAt": "2020-08-12T23:32:30Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "It's the first comment in this thread :) ",
              "createdAt": "2020-08-12T23:32:30Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTMwNjQ2",
          "commit": {
            "abbreviatedOid": "6aed3e4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:35:53Z",
          "updatedAt": "2020-08-13T16:35:54Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Applied your suggested change.",
              "createdAt": "2020-08-13T16:35:53Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTMyNTQw",
          "commit": {
            "abbreviatedOid": "1fc6a35"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:38:30Z",
          "updatedAt": "2020-08-13T16:38:31Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Hmmm, I'm curious though: shouldn't this field have a label?\r\nhttps://tools.ietf.org/html/rfc8446#section-3.8",
              "createdAt": "2020-08-13T16:38:31Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTMzNTAx",
          "commit": {
            "abbreviatedOid": "1fc6a35"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:39:44Z",
          "updatedAt": "2020-08-13T16:39:44Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "Reverted.",
              "createdAt": "2020-08-13T16:39:44Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTM3MTIy",
          "commit": {
            "abbreviatedOid": "1fc6a35"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:44:23Z",
          "updatedAt": "2020-08-13T16:44:24Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Yes, I'll revert this. However, it seems technically incorrect to me: using RFC 8446 as the authoritative standard, the `select` block is only defined for enumerated types. This might be splitting hairs though ... I'm not sure how strict RFCs are about this.",
              "createdAt": "2020-08-13T16:44:23Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTM5NTEw",
          "commit": {
            "abbreviatedOid": "1fc6a35"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:47:39Z",
          "updatedAt": "2020-08-13T16:47:40Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Reverted.",
              "createdAt": "2020-08-13T16:47:40Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTQxNTQ2",
          "commit": {
            "abbreviatedOid": "1fc6a35"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:50:22Z",
          "updatedAt": "2020-08-13T16:50:22Z",
          "comments": [
            {
              "originalPosition": 188,
              "body": "Done.",
              "createdAt": "2020-08-13T16:50:22Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTQ2NzE0",
          "commit": {
            "abbreviatedOid": "1fc6a35"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:55:29Z",
          "updatedAt": "2020-08-13T16:55:29Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "I like it. Changed.",
              "createdAt": "2020-08-13T16:55:29Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTY5OTgz",
          "commit": {
            "abbreviatedOid": "ec44304"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:10:01Z",
          "updatedAt": "2020-08-13T17:10:02Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Done.",
              "createdAt": "2020-08-13T17:10:01Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTcwNTg2",
          "commit": {
            "abbreviatedOid": "ec44304"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:10:54Z",
          "updatedAt": "2020-08-13T17:10:55Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "This is addressed by https://github.com/tlswg/draft-ietf-tls-esni/issues/253. But I think it might be worth resolving this issue as part of this PR. Or should we wait?",
              "createdAt": "2020-08-13T17:10:54Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc1MDEz",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:17:03Z",
          "updatedAt": "2020-08-13T17:17:03Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "It's a union, basically, whose value depends on the type. I don't know what would be the desired label, so I'd be fine with the current text or what's proposed above. ",
              "createdAt": "2020-08-13T17:17:03Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc1MTUw",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:17:15Z",
          "updatedAt": "2020-08-13T17:17:16Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "Let's wait.",
              "createdAt": "2020-08-13T17:17:15Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc1Njgw",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:18:00Z",
          "updatedAt": "2020-08-13T17:18:00Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "Let's remove the TODO then. ",
              "createdAt": "2020-08-13T17:18:00Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc2MTAw",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:18:31Z",
          "updatedAt": "2020-08-13T17:18:32Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "Let's either remove the TODO and file an issue, or address this here.",
              "createdAt": "2020-08-13T17:18:31Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc5NzE5",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:23:33Z",
          "updatedAt": "2020-08-13T17:23:33Z",
          "comments": [
            {
              "originalPosition": 319,
              "body": "I don't think so. We didn't have analyze this case (yet), so the safe thing was just hash to prevent changes. On reflection, any change in the outer extension values would change the transcript if the inner CH was selected, so maybe it's not needed? This is worth an issue.",
              "createdAt": "2020-08-13T17:23:33Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgwNDI4",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:24:31Z",
          "updatedAt": "2020-08-13T17:24:31Z",
          "comments": [
            {
              "originalPosition": 325,
              "body": "Right, identical. This would be a change, so let's move it to an issue.",
              "createdAt": "2020-08-13T17:24:31Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgxNDMw",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:25:54Z",
          "updatedAt": "2020-08-13T17:25:54Z",
          "comments": [
            {
              "originalPosition": 355,
              "body": "I'm not sure I understand the question here. I don't think the text suggests that the group is part of the ciphersuite. We can probably s/\"an appropriate group or\"/\"a\"",
              "createdAt": "2020-08-13T17:25:54Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgyMTEw",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:26:50Z",
          "updatedAt": "2020-08-13T17:26:50Z",
          "comments": [
            {
              "originalPosition": 406,
              "body": "This specifies how the parameters are populated, which is different from their definitions above. Let's keep it for now.",
              "createdAt": "2020-08-13T17:26:50Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgyNDgy",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:27:19Z",
          "updatedAt": "2020-08-13T17:27:20Z",
          "comments": [
            {
              "originalPosition": 410,
              "body": "It means the outer CH SNI value contains \"ECHConfig.public_name\".",
              "createdAt": "2020-08-13T17:27:19Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgyODky",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:27:52Z",
          "updatedAt": "2020-08-13T17:27:52Z",
          "comments": [
            {
              "originalPosition": 416,
              "body": "That seems reasonable. Let's file an issue to expand on those details, and remove this TODO.",
              "createdAt": "2020-08-13T17:27:52Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgzNTI4",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:28:39Z",
          "updatedAt": "2020-08-13T17:28:40Z",
          "comments": [
            {
              "originalPosition": 424,
              "body": "It's a RECOMMENDED padding scheme. What's the confusion?",
              "createdAt": "2020-08-13T17:28:40Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTg0Mjcy",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:29:42Z",
          "updatedAt": "2020-08-13T17:29:43Z",
          "comments": [
            {
              "originalPosition": 435,
              "body": "Again, this is a RECOMMENDED policy. Clients could alternatively pad their inner CH to 1024B, or something. Padding is needed to hide size metadata. It doesn't affect the protocol mechanics.",
              "createdAt": "2020-08-13T17:29:43Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTg0NTcy",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Left more comments for consideration. Nice edits!",
          "createdAt": "2020-08-13T17:30:05Z",
          "updatedAt": "2020-08-13T17:30:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTkxMzcw",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:39:27Z",
          "updatedAt": "2020-08-13T17:39:28Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "What I don't like about your proposal is that the `length` field gives the length of a nameless field. I think `content` would be a reasonable label.",
              "createdAt": "2020-08-13T17:39:28Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTkyMjEy",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:40:36Z",
          "updatedAt": "2020-08-13T17:40:37Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "Ack, removing TODO.",
              "createdAt": "2020-08-13T17:40:37Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTk0MjA1",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:43:20Z",
          "updatedAt": "2020-08-13T17:43:20Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "Actually, this is the *only* place in the document where \"ech_accept\" appears. This needs to be defined.",
              "createdAt": "2020-08-13T17:43:20Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTk5MDcx",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:50:18Z",
          "updatedAt": "2020-08-13T17:50:18Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "I see little difference between that and `contents`, so, let's just keep the current text?",
              "createdAt": "2020-08-13T17:50:18Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTk5NTc5",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:51:01Z",
          "updatedAt": "2020-08-13T17:51:01Z",
          "comments": [
            {
              "originalPosition": 319,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/263",
              "createdAt": "2020-08-13T17:51:01Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDAwMzU5",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:52:06Z",
          "updatedAt": "2020-08-13T17:52:06Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Oh, \"contents\" is fine. The suggested change is to give the variant a label.",
              "createdAt": "2020-08-13T17:52:06Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDAxNTIz",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:53:45Z",
          "updatedAt": "2020-08-13T17:53:45Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "Done.",
              "createdAt": "2020-08-13T17:53:45Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDAyNzgx",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:55:27Z",
          "updatedAt": "2020-08-13T17:55:28Z",
          "comments": [
            {
              "originalPosition": 355,
              "body": "That works for me.\r\nDone.",
              "createdAt": "2020-08-13T17:55:28Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDAzNDE2",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:56:16Z",
          "updatedAt": "2020-08-13T17:56:17Z",
          "comments": [
            {
              "originalPosition": 406,
              "body": "Ack, removing TODO.",
              "createdAt": "2020-08-13T17:56:16Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDIzMDk2",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:23:45Z",
          "updatedAt": "2020-08-13T18:23:45Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Hmm, I'm not sure what to here. I'm resolving this and leaving the text as is.",
              "createdAt": "2020-08-13T18:23:45Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDI0NTA0",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:25:49Z",
          "updatedAt": "2020-08-13T18:25:49Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "Is this an issue, or shall we define the alert here? I'm not sure how to do this.",
              "createdAt": "2020-08-13T18:25:49Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDI2ODUw",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:29:13Z",
          "updatedAt": "2020-08-13T18:29:13Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "Let's just make it an issue. It'll be a small change.",
              "createdAt": "2020-08-13T18:29:13Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDI3NTU4",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:30:14Z",
          "updatedAt": "2020-08-13T18:30:15Z",
          "comments": [
            {
              "originalPosition": 325,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/265.",
              "createdAt": "2020-08-13T18:30:15Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDMwMDY4",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:33:55Z",
          "updatedAt": "2020-08-13T18:33:56Z",
          "comments": [
            {
              "originalPosition": 410,
              "body": "Ack, resolving.",
              "createdAt": "2020-08-13T18:33:56Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDMzNDIy",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:38:56Z",
          "updatedAt": "2020-08-13T18:38:57Z",
          "comments": [
            {
              "originalPosition": 416,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/266",
              "createdAt": "2020-08-13T18:38:56Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDMzNjU5",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:39:18Z",
          "updatedAt": "2020-08-13T18:39:19Z",
          "comments": [
            {
              "originalPosition": 424,
              "body": "I'll resolve this TOOD for now.",
              "createdAt": "2020-08-13T18:39:18Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDM0MTUx",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:40:02Z",
          "updatedAt": "2020-08-13T18:40:03Z",
          "comments": [
            {
              "originalPosition": 435,
              "body": "Resolving for now.",
              "createdAt": "2020-08-13T18:40:02Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDM3NjAw",
          "commit": {
            "abbreviatedOid": "4c9319b"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:45:14Z",
          "updatedAt": "2020-08-13T18:45:15Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/267",
              "createdAt": "2020-08-13T18:45:14Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDQwMTAx",
          "commit": {
            "abbreviatedOid": "8a92f4e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:49:07Z",
          "updatedAt": "2020-08-13T18:49:07Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "This is already described in the section you reference, so let's remove this TODO.",
              "createdAt": "2020-08-13T18:49:07Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDQwMjMx",
          "commit": {
            "abbreviatedOid": "8a92f4e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:49:20Z",
          "updatedAt": "2020-08-13T18:49:21Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n{{client-behavior}} for details.)\r\n```",
              "createdAt": "2020-08-13T18:49:20Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDQxODMz",
          "commit": {
            "abbreviatedOid": "8a92f4e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:51:41Z",
          "updatedAt": "2020-08-13T18:51:41Z",
          "comments": [
            {
              "originalPosition": 362,
              "body": "That seems reasonable -- thanks!",
              "createdAt": "2020-08-13T18:51:41Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDQyNDQy",
          "commit": {
            "abbreviatedOid": "8a92f4e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:52:33Z",
          "updatedAt": "2020-08-13T18:52:33Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Done.",
              "createdAt": "2020-08-13T18:52:33Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDQ1MjMy",
          "commit": {
            "abbreviatedOid": "d67c284"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:54:41Z",
          "updatedAt": "2020-08-13T18:54:41Z",
          "comments": [
            {
              "originalPosition": 362,
              "body": "Done.",
              "createdAt": "2020-08-13T18:54:41Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDUxNjk1",
          "commit": {
            "abbreviatedOid": "4d7f789"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T19:04:23Z",
          "updatedAt": "2020-08-13T19:04:23Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "This is meant to be clarifying, not a spec change. The \"ech_required\" alert MUST be sent in this case, correct?",
              "createdAt": "2020-08-13T19:04:23Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDUyOTk3",
          "commit": {
            "abbreviatedOid": "4d7f789"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T19:06:20Z",
          "updatedAt": "2020-08-13T19:06:20Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Oops, missed this. Shall I make this change?",
              "createdAt": "2020-08-13T19:06:20Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDcxOTQ3",
          "commit": {
            "abbreviatedOid": "c9a3ebd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T19:35:27Z",
          "updatedAt": "2020-08-13T19:35:27Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "\ud83d\udc4d yep!",
              "createdAt": "2020-08-13T19:35:27Z",
              "updatedAt": "2020-08-13T19:35:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDcyMDky",
          "commit": {
            "abbreviatedOid": "c9a3ebd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for these editorial cleanups!",
          "createdAt": "2020-08-13T19:35:42Z",
          "updatedAt": "2020-08-13T19:35:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 268,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4MzAzNjMz",
      "title": "Fix superfluous padding edge cases.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/268",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Consider the following values for L and D, where L is the server's hint\r\nand D is the length of the domain name.\r\n\r\n~~~\r\n    D1     D2      D3\r\n... -+--|---+---|---+---|----->\r\n        L     32*n   32*(n+1)\r\n~~~\r\n\r\nThis change pads D according to the following rules.\r\n\r\n- D1: D <= L, so round up to L.\r\n- D2: 32*(n-1) <= L < D <= 32*n, round up to 32*(n+1).\r\n- D3: 32*(n-1) <= L <= 32*n < D, round up to 32*(n+1).\r\n\r\nCase D2 exists because the anonymity set of of D, if rounded to 32*n\r\n(instead of 32*(n+1), is less than 32. The new padding algorithm ensures\r\nthat the anonymity set for D whenever D > L is at least 32 elements.\r\n\r\nCloses #252. Thanks, @bemasc!",
      "createdAt": "2020-08-15T12:57:39Z",
      "updatedAt": "2020-08-30T15:37:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5f86ef0a0bdcfce58a606de4a216213ebbed1a4d",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/fix-padding",
      "headRefOid": "1cfe0cc4a61fbc1078aed36cd10c3675825c365b",
      "closedAt": "2020-08-30T15:37:22Z",
      "mergedAt": "2020-08-30T15:37:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3ee7678e12c49cd6015899e675bf227bbb50835b"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @davidben, @kjacobs-moz, @dmcardle, @ekr, @martinthomson",
          "createdAt": "2020-08-19T15:42:07Z",
          "updatedAt": "2020-08-19T15:42:07Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "TBH I am not sure that this is worth it, but I believe it is correct.",
          "createdAt": "2020-08-21T22:41:15Z",
          "updatedAt": "2020-08-21T22:41:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MDExOTkx",
          "commit": {
            "abbreviatedOid": "96942ef"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-08-15T19:03:09Z",
          "updatedAt": "2020-08-15T19:04:27Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Technically this no longer \"rounds D up to the nearest multiple of 32 bytes\".  How about\r\n```suggestion\r\n   multiple of 32 bytes that permits at least 32 bytes of length ambiguity.\r\n```",
              "createdAt": "2020-08-15T19:03:09Z",
              "updatedAt": "2020-08-15T19:12:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MDEyNDU2",
          "commit": {
            "abbreviatedOid": "96942ef"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-15T19:12:33Z",
          "updatedAt": "2020-08-15T19:12:34Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Better \u2014 thanks!",
              "createdAt": "2020-08-15T19:12:34Z",
              "updatedAt": "2020-08-15T19:12:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MDE5NzMx",
          "commit": {
            "abbreviatedOid": "1cfe0cc"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-15T21:55:02Z",
          "updatedAt": "2020-08-15T21:55:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 269,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4OTQ1Njkx",
      "title": "Proposal: Retry-only ECHConfig",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/269",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A server operator always has the option to operate in a retry-only mode, which may be necessary if updating the published ECHConfig is difficult and long-lived keys are undesirable.  This change improves forward-secrecy in that configuration.",
      "createdAt": "2020-08-17T16:45:35Z",
      "updatedAt": "2020-09-21T17:52:55Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5f86ef0a0bdcfce58a606de4a216213ebbed1a4d",
      "headRepository": "bemasc/draft-ietf-tls-esni",
      "headRefName": "patch-1",
      "headRefOid": "dbb0f87207689ce7684d99286ccadcf26dd54f87",
      "closedAt": "2020-09-21T17:52:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Are there folks looking to deploy such a thing? The current retry flow costs 2-RTT (TCP + TLS) on top of a normal handshake. I don't think that's something to encourage. It's currently meant as a recovery flow. I think something meant to be used more frequently would want to look different and, in particular, stay in one connection to keep the overhead at 1-RTT. Possibly even with some client state for subsequent connections, though squaring that with multi-CDN is tricky.\r\n\r\nThat sort of thing came up on the list, but IIRC folks weren't very excited about the complexity involved and we kept it as a simpler, recovery-only story.",
          "createdAt": "2020-08-17T17:18:10Z",
          "updatedAt": "2020-08-17T17:18:10Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree; it's too expensive for normal use, and not worth complicating clients to improve performance.\r\n\r\nI'm thinking of use cases where DNS is not the distribution channel, and updating the ECHConfig is difficult.  It would be nice to be able to see that the ECHConfig is not \"pinning\" a key, and to have a shorter ECHConfig for very constrained distribution channels (e.g. a QR code).\r\n\r\nA client like this might fetch and cache real ECHConfigs once it's connected, but I think we can leave that to the application layer.",
          "createdAt": "2020-08-17T18:15:23Z",
          "updatedAt": "2020-08-17T18:15:23Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this idea!",
          "createdAt": "2020-08-18T14:52:35Z",
          "updatedAt": "2020-08-18T14:52:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "From the interim: we need more clarification of the use case. This can also be addressed in future work as an extension. @bemasc, can we close this and punt to a future change?",
          "createdAt": "2020-09-21T15:52:52Z",
          "updatedAt": "2020-09-21T15:52:52Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think an extension would allow us to _omit_ information as suggested here, but it sounds like there's no consensus to support this so I don't want to create delay.",
          "createdAt": "2020-09-21T17:52:55Z",
          "updatedAt": "2020-09-21T17:52:55Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 270,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MDExNjg4",
      "title": "Adjust and generalize cached_info guidance.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/270",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Now that we've switched to encrypting the entire ClientHello, there's\r\nnothing wrong with cached_info in ClientHelloOuter, provided it's based\r\non the public name rather than the inner name. And, more generally,\r\nname-specific extensions take some care.\r\n\r\nReplace the prohibition with more general guidance in Security\r\nConsiderations, with cached_info merely being an example.\r\n\r\nThis addresses issue #266.",
      "createdAt": "2020-08-17T18:55:06Z",
      "updatedAt": "2020-08-17T20:41:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5f86ef0a0bdcfce58a606de4a216213ebbed1a4d",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "cached-info",
      "headRefOid": "4e179fe14da4d16b7b985cdb0c5afa5c9c527d02",
      "closedAt": "2020-08-17T20:41:24Z",
      "mergedAt": "2020-08-17T20:41:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4ab5190580e30318764b92a776bfb8522cbb3ecb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4ODA4OTcw",
          "commit": {
            "abbreviatedOid": "c3cd016"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with a couple suggestions -- thanks!",
          "createdAt": "2020-08-17T20:26:46Z",
          "updatedAt": "2020-08-17T20:29:38Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\ntrue server name. For example, the \"cached_info\" ClientHello extension\r\n```",
              "createdAt": "2020-08-17T20:26:46Z",
              "updatedAt": "2020-08-17T20:38:28Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nClientHelloOuter. It MAY send such values in the ClientHelloInner.\r\n```",
              "createdAt": "2020-08-17T20:28:43Z",
              "updatedAt": "2020-08-17T20:38:28Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nwhich would reveal a sensitive ClientHelloInner property, such as the true\r\nserver name. It MAY send values associated with the public name in the \r\nClientHelloOuter.\r\n```",
              "createdAt": "2020-08-17T20:29:27Z",
              "updatedAt": "2020-08-17T20:38:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4ODE3ODAw",
          "commit": {
            "abbreviatedOid": "4e179fe"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-17T20:41:17Z",
          "updatedAt": "2020-08-17T20:41:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 271,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MDM2NDU0",
      "title": "Require the KDF to be HKDF-based",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/271",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The spec makes use of the \"hash function underlying the KDF\", but the\r\nHPKE spec does not require such a function to exist. This resolves the\r\nissue by requiring that HKDF is used for key derivation in ECH.\r\n\r\nThis resolves #261.",
      "createdAt": "2020-08-17T19:52:26Z",
      "updatedAt": "2020-08-17T23:43:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4ab5190580e30318764b92a776bfb8522cbb3ecb",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hkdf",
      "headRefOid": "96f3cecd473933836155b17badee77b5e0b1165e",
      "closedAt": "2020-08-17T23:43:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I rolled up your changes.",
          "createdAt": "2020-08-17T21:19:24Z",
          "updatedAt": "2020-08-17T21:19:24Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In light of @martinthomson's point on the mailing list, we might want to reconsider this PR.",
          "createdAt": "2020-08-17T22:58:52Z",
          "updatedAt": "2020-08-17T22:59:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I really don't feel strongly about this. We don't have any other KDFs at the moment, and swapping in a new one later is trivial. ",
          "createdAt": "2020-08-17T23:06:54Z",
          "updatedAt": "2020-08-17T23:06:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Dropping this in favor of #276.",
          "createdAt": "2020-08-17T23:43:57Z",
          "updatedAt": "2020-08-17T23:43:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4ODMyNTI5",
          "commit": {
            "abbreviatedOid": "6d049d8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM modulo two nits. If and when an alternate KDF comes out and we need and want to support it for ECH, we can write text allowing it. For now, it seems fine to constrain ourselves to HKDF, given how tightly coupled it is to TLS 1.3 as is. ",
          "createdAt": "2020-08-17T21:05:55Z",
          "updatedAt": "2020-08-17T21:07:44Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "```suggestion\r\n  with the HPKE KDF.\r\n```",
              "createdAt": "2020-08-17T21:05:56Z",
              "updatedAt": "2020-08-17T21:19:04Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\ni.e., the hash function underlying the HPKE HKDF variant.\r\n```",
              "createdAt": "2020-08-17T21:06:33Z",
              "updatedAt": "2020-08-17T21:19:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 272,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MDQzMTQ1",
      "title": "Remove \"outer_extension\" compression guidance",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/272",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #265.",
      "createdAt": "2020-08-17T20:08:35Z",
      "updatedAt": "2020-08-19T22:40:09Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5f86ef0a0bdcfce58a606de4a216213ebbed1a4d",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "compression_guidance",
      "headRefOid": "8f380b9a9b27d865c5eeb34e3b79db70f4e6f924",
      "closedAt": "2020-08-19T22:40:09Z",
      "mergedAt": "2020-08-19T22:40:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b78f62ef04cc47a66bdaad01833bf546f21856ae"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMDEyNDky",
          "commit": {
            "abbreviatedOid": "8f380b9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-19T22:39:58Z",
          "updatedAt": "2020-08-19T22:39:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 273,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MDQzMjQ1",
      "title": "Update a few citations to RFCs.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/273",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-17T20:08:48Z",
      "updatedAt": "2020-08-17T20:19:34Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5f86ef0a0bdcfce58a606de4a216213ebbed1a4d",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "update-citations",
      "headRefOid": "843793117fa2c7fd786d12ea45794e2805a037d3",
      "closedAt": "2020-08-17T20:19:34Z",
      "mergedAt": "2020-08-17T20:19:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "37e0e6a14db945988d21a08f506a3e74a8fc6bb7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4ODA0NTMw",
          "commit": {
            "abbreviatedOid": "8437931"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-17T20:19:28Z",
          "updatedAt": "2020-08-17T20:19:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 276,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MTIxMTkz",
      "title": "Resolve mismatch between ECH and HPKE API",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/276",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Per @martinthomson's suggestion, this replaces computations involving the \"hash underlying the KDF\" with evaluation of the KDF itself. This respects the API defined in the HPKE draft.\r\n\r\nThis supersedes #271.",
      "createdAt": "2020-08-17T23:43:36Z",
      "updatedAt": "2020-08-26T12:46:17Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b78f62ef04cc47a66bdaad01833bf546f21856ae",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hkdf2",
      "headRefOid": "202ab60e6e43543b6cc18c0e66348bea6961230b",
      "closedAt": "2020-08-26T12:46:17Z",
      "mergedAt": "2020-08-26T12:46:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ffdd0db49c096f548aceb9eec05a3d7b189bfd01"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey @chris-wood and @martinthomson, I rolled up your changes! Please have another look before merging.",
          "createdAt": "2020-08-18T15:09:04Z",
          "updatedAt": "2020-08-18T15:09:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased and rolled up.",
          "createdAt": "2020-08-19T19:05:56Z",
          "updatedAt": "2020-08-19T19:05:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks -- let's let this stew until Friday, at which point we can merge.",
          "createdAt": "2020-08-19T19:18:19Z",
          "updatedAt": "2020-08-19T19:18:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased.",
          "createdAt": "2020-08-20T00:52:29Z",
          "updatedAt": "2020-08-20T00:52:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTA0NTI0",
          "commit": {
            "abbreviatedOid": "f42a0db"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-17T23:54:27Z",
          "updatedAt": "2020-08-17T23:57:36Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nentire ClientHelloInner message as:\r\n```",
              "createdAt": "2020-08-17T23:54:27Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\n  Section 4 of {{!I-D.irtf-cfrg-hpke}}.)\r\n```\r\n\r\n(I had some difficultly locating it without a more specific pointer.)",
              "createdAt": "2020-08-17T23:56:32Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 11,
              "body": "Rather than repeat the definition here, what you probably want to do is make a new section under {{outer-extensions}} and cite that.  It's reasonable to do that as a follow-up though.",
              "createdAt": "2020-08-17T23:57:08Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTA2MjM5",
          "commit": {
            "abbreviatedOid": "f42a0db"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:00:01Z",
          "updatedAt": "2020-08-18T00:00:01Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Should we avoid referring to sections numbers in drafts, in case they change?",
              "createdAt": "2020-08-18T00:00:01Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTA0NjY1",
          "commit": {
            "abbreviatedOid": "f42a0db"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-17T23:54:59Z",
          "updatedAt": "2020-08-18T00:00:59Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\n: Equal to `Extract(Expand(\"\", config), \"ech_config_digest\", Nh)`, where `config` is the \r\n`ECHConfig` structure, and `Extract`, `Expand`, and `Nh` are as defined by the KDF API in\r\n{{!I-D.irtf-cfrg-hpke}}.\r\n```",
              "createdAt": "2020-08-17T23:54:59Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\n  hash = Extract(Expand(\"\", inner), \"ech_inner_digest\", Nh)\r\n```",
              "createdAt": "2020-08-17T23:55:32Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nwhere `inner` is the ClientHelloInner structure, and `Extract`, `Expand`, and `Nh` are as \r\ndefined by the KDF API in {{!I-D.irtf-cfrg-hpke}}. Then, the client removes and replaces\r\nextensions from ClientHelloInner with a single \"outer_extensions\" extension. The\r\nlist of `outer_extensions` include those which were removed from\r\nClientHelloInner, in the order in which they were removed. The hash contains the\r\nfull ClientHelloInner hash computed above.\r\n```",
              "createdAt": "2020-08-17T23:55:52Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTA2NzMy",
          "commit": {
            "abbreviatedOid": "f42a0db"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:01:27Z",
          "updatedAt": "2020-08-18T00:01:28Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Let's do it in follow up.\r\n\r\nMy view is that the hash should be dropped from outer_extensions: see #263.",
              "createdAt": "2020-08-18T00:01:27Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTA5NTc3",
          "commit": {
            "abbreviatedOid": "f42a0db"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:10:17Z",
          "updatedAt": "2020-08-18T00:10:18Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Is the empty string <=> all zero thing a deliberate choice or just an odd quirk of HKDF (via HMAC)?  I agree that in this case the difference isn't important and an empty string is fine, but do we need to be careful about this at all?",
              "createdAt": "2020-08-18T00:10:17Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTEwNDgw",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:13:09Z",
          "updatedAt": "2020-08-18T00:13:09Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "For HKDF it's the same (if salt's omitted, HKDF just fills in a zero-length string of Nh bytes), but for other KDFs it might not be. So we decided to just stick with empty strings, and I think we ought to do the same here.",
              "createdAt": "2020-08-18T00:13:09Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTEwODk3",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:14:29Z",
          "updatedAt": "2020-08-18T00:14:30Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "[You have to be careful with the salt length for HKDF](https://hal.inria.fr/hal-02100345). As I recall, a safe choice is the output length of the underlying hash function. (This is `Nh` in the HPKE draft.) This is also what's done in RFC 8446.",
              "createdAt": "2020-08-18T00:14:30Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTExMzUz",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:15:57Z",
          "updatedAt": "2020-08-18T00:15:58Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Quoting from the HKDF RFC:\r\n\r\n> salt: if not provided, it is set to a string of HashLen zeros.\r\n\r\nWhat I'm proposing is that we omit this, since we don't want HKDF quirks impacting future KDFs. (This is a deliberate design choice we made for HPKE.)",
              "createdAt": "2020-08-18T00:15:57Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTExODcy",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:17:37Z",
          "updatedAt": "2020-08-18T00:17:37Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Is \"\" the same as Nh-length byte stering? I read \"\" as the 0-length string.",
              "createdAt": "2020-08-18T00:17:37Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTExOTgz",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:18:01Z",
          "updatedAt": "2020-08-18T00:18:02Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "(See above thread.)",
              "createdAt": "2020-08-18T00:18:02Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTEyMTg5",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:18:39Z",
          "updatedAt": "2020-08-18T00:18:40Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "It's an empty string, i.e., equivalent to not providing the input. (We could add text clarifying that!)",
              "createdAt": "2020-08-18T00:18:40Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTEyNjM0",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:20:18Z",
          "updatedAt": "2020-08-18T00:20:18Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "What does it look like, syntactically, if the salt isn't provided? Were I reading this, I would think that the salt is the empty string.\r\n\r\nPossible variants:\r\n- `Extract(salt, ikm)` where `salt` is ...\r\n- `Extract(\"\", ikm)` (I read this as the empty string)\r\n- `Extract(0, ikm)` (not sure how to read this, lol)",
              "createdAt": "2020-08-18T00:20:18Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTE3MjA2",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:36:08Z",
          "updatedAt": "2020-08-18T00:36:08Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Chatted offline -- `Extract(\"\", ikm)` is the way to go!",
              "createdAt": "2020-08-18T00:36:08Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTE4OTc2",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:42:12Z",
          "updatedAt": "2020-08-18T00:42:12Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Will do with this in the morning!",
              "createdAt": "2020-08-18T00:42:12Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTE5MTg1",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:42:51Z",
          "updatedAt": "2020-08-18T00:42:52Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "We'll go with \"\" == \"\\x00\" * Nh, here and below. I'll add a paranthetical to clarify this the first time we use this.",
              "createdAt": "2020-08-18T00:42:51Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NTUxNDYy",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T15:08:16Z",
          "updatedAt": "2020-08-18T15:08:17Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done.",
              "createdAt": "2020-08-18T15:08:16Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NTcwNzc5",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-08-18T15:27:57Z",
          "updatedAt": "2020-08-18T15:29:43Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "The order is wrong here -- it should be Expand(Extract(...))",
              "createdAt": "2020-08-18T15:27:58Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 11,
              "body": "This should be `Extract`, not `Expand`.",
              "createdAt": "2020-08-18T15:28:58Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 37,
              "body": "Backwards here, too.",
              "createdAt": "2020-08-18T15:29:05Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 69,
              "body": "Since this is no longer a hash function output (and not a digest), perhaps we should rename this to `config_id`, or something. ",
              "createdAt": "2020-08-18T15:29:40Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjgyMjQy",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T17:38:52Z",
          "updatedAt": "2020-08-18T17:38:52Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "ahh, good catch",
              "createdAt": "2020-08-18T17:38:52Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjgzMjQw",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T17:40:15Z",
          "updatedAt": "2020-08-18T17:40:16Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Fixed, here and below.",
              "createdAt": "2020-08-18T17:40:15Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjgzODY3",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T17:41:07Z",
          "updatedAt": "2020-08-18T17:41:08Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done.",
              "createdAt": "2020-08-18T17:41:07Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5Njg1MTAw",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T17:42:48Z",
          "updatedAt": "2020-08-18T17:42:49Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "I'd be ok with this change, though existing issues refer to `config_digest`. Why don't we put this on the stack of editorial TODOs?",
              "createdAt": "2020-08-18T17:42:49Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5Njg1NDAy",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T17:43:12Z",
          "updatedAt": "2020-08-18T17:43:13Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Done",
              "createdAt": "2020-08-18T17:43:13Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5ODk4MTQz",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T23:32:41Z",
          "updatedAt": "2020-08-18T23:32:42Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Yeah, that's fine.",
              "createdAt": "2020-08-18T23:32:41Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5ODk4NTQy",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T23:33:48Z",
          "updatedAt": "2020-08-18T23:33:48Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Let's make a note to change this to something other than `hash`, too. (If we keep it!)",
              "createdAt": "2020-08-18T23:33:48Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5ODk4OTEy",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with the latest changes. Thanks!",
          "createdAt": "2020-08-18T23:34:43Z",
          "updatedAt": "2020-08-18T23:34:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5OTAxNzIz",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-18T23:43:02Z",
          "updatedAt": "2020-08-18T23:44:08Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "It's easy to fix.  If HPKE was so unstable, I'd be less inclined to depend on it.",
              "createdAt": "2020-08-18T23:43:02Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 37,
              "body": "`config_id` ? or, for now: \r\n\r\n```suggestion\r\n  config_digest = Expand(Extract(\"\", inner), \"ech_inner_digest\", Nh)\r\n```",
              "createdAt": "2020-08-18T23:43:30Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5OTA1MzU1",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T23:54:01Z",
          "updatedAt": "2020-08-18T23:54:01Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Well this is the hash of the inner CH, not of the config. Let's just change this name in a separate PR. ",
              "createdAt": "2020-08-18T23:54:01Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5OTUyMDg2",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-19T00:58:04Z",
          "updatedAt": "2020-08-19T00:58:05Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Noted.",
              "createdAt": "2020-08-19T00:58:05Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5OTUzNjUx",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-19T00:59:00Z",
          "updatedAt": "2020-08-19T00:59:01Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Agreed.",
              "createdAt": "2020-08-19T00:59:00Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 277,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MTQ2Mjg2",
      "title": "Nit: fix typo: change 'Hkpe' to 'Hpke'.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/277",
      "state": "MERGED",
      "author": "cbartle891",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix for https://github.com/tlswg/draft-ietf-tls-esni/issues/275.",
      "createdAt": "2020-08-18T01:24:33Z",
      "updatedAt": "2020-08-18T03:54:41Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4ab5190580e30318764b92a776bfb8522cbb3ecb",
      "headRepository": "cbartle891/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "6b5d04e7b27127527f78ec7152572115915ac6b8",
      "closedAt": "2020-08-18T03:54:41Z",
      "mergedAt": "2020-08-18T03:54:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "65f77a332de82ae6c666ed02d893b410b1e9f041"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTMxOTUw",
          "commit": {
            "abbreviatedOid": "6b5d04e"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-18T01:27:57Z",
          "updatedAt": "2020-08-18T01:27:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTczNDI1",
          "commit": {
            "abbreviatedOid": "6b5d04e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-18T03:54:35Z",
          "updatedAt": "2020-08-18T03:54:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 279,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcwMTUwOTc3",
      "title": "Fix typo CllientHelloInner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/279",
      "state": "MERGED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes a small typo.",
      "createdAt": "2020-08-19T13:04:33Z",
      "updatedAt": "2020-08-19T14:02:34Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "65f77a332de82ae6c666ed02d893b410b1e9f041",
      "headRepository": "thomwiggers/draft-ietf-tls-esni",
      "headRefName": "fix-typo",
      "headRefOid": "32c83a66cdb1de8553add83f9e40ae00eba3b459",
      "closedAt": "2020-08-19T14:02:34Z",
      "mergedAt": "2020-08-19T14:02:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "250bd072036d663a39966e8a5ff243d54a3bf49d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNDg5NjA1",
          "commit": {
            "abbreviatedOid": "32c83a6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-19T14:02:30Z",
          "updatedAt": "2020-08-19T14:02:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 282,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcwNDU2MTE3",
      "title": "Fix leftover references to 'retry_keys'",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/282",
      "state": "MERGED",
      "author": "kjacobs-moz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #281 ",
      "createdAt": "2020-08-19T21:05:31Z",
      "updatedAt": "2020-08-19T22:38:00Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "250bd072036d663a39966e8a5ff243d54a3bf49d",
      "headRepository": "kjacobs-moz/draft-ietf-tls-esni",
      "headRefName": "retry_keys_fix",
      "headRefOid": "0680dc293db6da282f4c0bdd4399fee1c96480ed",
      "closedAt": "2020-08-19T22:38:00Z",
      "mergedAt": "2020-08-19T22:38:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "dedb887565b4d1a60e396669d4ec39463c398826"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMDExNzA0",
          "commit": {
            "abbreviatedOid": "0680dc2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-08-19T22:37:55Z",
          "updatedAt": "2020-08-19T22:37:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 283,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxMjgyODA0",
      "title": "Add ECH confirmation (option (3))",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/283",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This changes changes the semantics of the \"encrypted_client_hello\" (aka \"ech\") extension so that the server confirms ECH acceptance. The client adds an \"ech\" extension to ClientHelloInner that contains a random nonce; when the server accepts, it echoes this nonce back.\r\n\r\n**Protocol flow:**\r\n* **On input of the client's outer CH.** If the server accepts ECH, it uses the inner CH; and if the server rejects or does not support ECH, then it uses the outer CH. If the server accepts, then it adds an \"ech\" extension to its SH with nonce sent in the \"ech\" extension of the inner CH; if the server rejects, then it adds an \"ech\" extension to its SH with a random nonce. It may also add and an \"ech\" extension to its EE with the updated ECH configuration.\r\n* **On input of the server's SH, EE, \u2026, Finished.** If the SH has the \"ech\" extension with the payload sent in the inner CH, then it proceeds as if the inner CH was used; otherwise it proceeds as if the outer CH was used, updating its ECH configuration if applicable.\r\n\r\nThis addresses #274. It also makes the naming of extensions defined in the spec consistent.\r\n\r\nREVISED on 9/2.",
      "createdAt": "2020-08-20T23:02:09Z",
      "updatedAt": "2020-09-03T17:23:06Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3426cfbf3f25bd2aa23a13e8700702717c05a42f",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "ech_confirmation",
      "headRefOid": "c229d615d4f40d8584096f33d6884372276c581d",
      "closedAt": "2020-09-03T17:13:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OPEN ISSUE: Does the new extension impact the HRR logic? I don't think so, but I'm hoping someone else can have a look.",
          "createdAt": "2020-08-20T23:10:06Z",
          "updatedAt": "2020-08-20T23:10:06Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This design breaks \"split mode\".  The origin server doesn't have the HPKE context, so it can't produce the exported value.  I think this loss is unnecessary and worth avoiding.",
          "createdAt": "2020-08-21T00:23:44Z",
          "updatedAt": "2020-08-21T00:23:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The \"ech_confirm\" in the inner CH is sent to the backend server, who echoes it back. (As you suggested.) The backend doesn't need to know the HPKE context. Unless I made a mistake, which is entirely possible --- can you point me to the issue? (A comment on the line you're worried about would be ideal.)",
          "createdAt": "2020-08-21T00:28:16Z",
          "updatedAt": "2020-08-21T00:28:16Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the explanation.  You're right; I didn't understand that it is the _client_ who is performing the export.  That should be fine.\r\n\r\nI'm curious why you specify that the client perform this export operation, as opposed to using an unspecified source of randomness?  Is the server supposed to check that it matches, or ignore the contents?",
          "createdAt": "2020-08-21T00:32:50Z",
          "updatedAt": "2020-08-21T00:32:50Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "I share Ben's curiosity -- it seems like the exporter provides no value here beyond what a PRNG would.  The client is differentiating between an echo of the value it provided in CHInner or a randomly-generated value supplied by the server in response to an empty value.  The same could be achieved by simply generating a random nonce and looking for an echo or not.",
          "createdAt": "2020-08-21T01:30:09Z",
          "updatedAt": "2020-08-21T01:30:09Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The same critique applies to the \"ech_nonce\" extension. I think the benefit of using the HPKE context here is reducing dependence on an \"unspecified source of randomness\" (i.e., PRNG).",
          "createdAt": "2020-08-21T14:53:53Z",
          "updatedAt": "2020-08-21T14:58:42Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As I've noted elsewhere, I don't understand why \"ech_nonce\" is needed at all.\r\n\r\nI don't have an informed opinion about the use of the exporter here, but I think we need to be clearer on whether the server is permitted to validate the contents.\r\n\r\nMy preference would be to give it a non-ECH-related name (e.g. \"client_hello_id\"), and require that servers not validate the contents.  I think that would be more conducive to wide deployment, including any future use cases where the applicable ClientHello is unclear.\r\n\r\nWe could also make the use of exporter a \"SHOULD\", if you think it's a good practice but not required for interoperability.",
          "createdAt": "2020-08-21T15:17:04Z",
          "updatedAt": "2020-08-21T15:17:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> As I've noted elsewhere, I don't understand why \"ech_nonce\" is needed at all.\r\n\r\nI tend to think \"ech_nonce\" should be removed, but we should confine that discussion to #253.\r\n\r\n> I don't have an informed opinion about the use of the exporter here, but I think we need to be clearer on whether the server is permitted to validate the contents.\r\n\r\nI'd suggest: \"the server MAY verify extension's contents and abort with an \"illegal_parameter\" alert if value is incorrect\".\r\n\r\n> My preference would be to give it a non-ECH-related name (e.g. \"client_hello_id\"), and require that servers not validate the contents. I think that would be more conducive to wide deployment, including any future use cases where the applicable ClientHello is unclear.\r\n\r\nUsage of \"ech_confirm\" implies usage of \"ech\", so I think there needs to be a clear association between the extensions' names. A name like \"client_hello_id\" removes this association. Perhaps it would be more appropriate to have the confirmation request be a field of the existing \"ech\" extension, rather than define a brand new extension for this purpose?\r\n\r\n> We could also make the use of exporter a \"SHOULD\", if you think it's a good practice but not required for interoperability.\r\n\r\nWhat's the value of giving the implementer a choice here? It seems to me that we should *either* use the PRNG *or* use the HPKE context. Since usage of \"ech_confirm\" implies usage of \"ech\", I think it's fine to go with the latter.",
          "createdAt": "2020-08-21T15:47:42Z",
          "updatedAt": "2020-08-21T15:50:07Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "> What's the value of giving the implementer a choice here? It seems to me that we should _either_ use the PRNG _or_ use the HPKE context. Since usage of \"ech_confirm\" implies usage of \"ech\", I think it's fine to go with the latter.\r\n\r\nThe reverse argument is equally valid.  There's apparently no value in specifying how the client gets this number, only the properties that it needs to have (i.e. that an observer can't predict it).  If an implementation wants to use an exporter as a source of entropy, that breaks nothing, but any source of entropy will do.\r\n\r\nThe exporter seems primarily useful in the case where one side generates the value and the other side verifies it, which is another way to spell this approach.  It makes the server implementation marginally more complex, though, and I think the echo-or-random spelling is fine.\r\n\r\n> > My preference would be to give it a non-ECH-related name (e.g. \"client_hello_id\"), and require that servers not validate the contents. I think that would be more conducive to wide deployment, including any future use cases where the applicable ClientHello is unclear.\r\n> \r\n> Usage of \"ech_confirm\" implies usage of \"ech\", so I think there needs to be a clear association between the extensions' names. A name like \"client_hello_id\" removes this association. Perhaps it would be more appropriate to have the confirmation request be a field of the existing \"ech\" extension, rather than define a brand new extension for this purpose?\r\n\r\nI think @bemasc is looking to a future where either non-ECH clients include this extension to help ECH stand out less, or where the same mechanism could be used to disambiguate under other circumstances.  In other words, this doesn't inherently need to be an ECH-specific extension, merely one that ECH leverages, so perhaps it shouldn't be.\r\n\r\nOn both questions, I think my response is the same:  Let's not build in constraints that aren't actually accomplishing anything.",
          "createdAt": "2020-08-21T18:31:36Z",
          "updatedAt": "2020-08-21T18:31:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> On both questions, I think my response is the same: Let's not build in constraints that aren't actually accomplishing anything.\r\n\r\nWell said. I'm not sure about the name change, but I'm with you on using the PRNG instead of depending on HPKE. I'll change this in the PR.\r\n",
          "createdAt": "2020-08-21T21:29:47Z",
          "updatedAt": "2020-08-21T21:29:47Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Belay that, I forgot about split mode.  Though the duplication of the nonce remains a valid concern.",
          "createdAt": "2020-08-24T06:17:19Z",
          "updatedAt": "2020-08-24T06:17:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson:\r\n\r\n>  Though the duplication of the nonce remains a valid concern.\r\n\r\nWe might consider either (a) removing \"ech_nonce\" and replacing it with this or (b) re-purposing \"ech_nonce\". ",
          "createdAt": "2020-08-24T19:59:11Z",
          "updatedAt": "2020-08-24T19:59:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This proposes two 16 byte extensions that are generated in effectively identical fashion.  It seems like echoing ech_nonce would achieve the goal you are looking for here, at the cost of making this signaling mandatory.",
          "createdAt": "2020-08-25T00:15:09Z",
          "updatedAt": "2020-08-25T00:15:09Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This proposes two 16 byte extensions that are generated in effectively identical fashion.  It seems like echoing ech_nonce would achieve the goal you are looking for here, at the cost of making this signaling mandatory.\r\n\r\nHave a look at the most recent changes--- the confirmation tag is now generated differently than \"ech_nonce\". I agree that \"ech_nonce\" is redundant, but I think this needs to be addressed in a separate PR.\r\n\r\n",
          "createdAt": "2020-08-25T17:13:33Z",
          "updatedAt": "2020-08-25T17:13:33Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It might be nice to explicitly introduce the extension by saying it has three forms and spell them out.\r\n\r\nI'll address this tomorrow morning.",
          "createdAt": "2020-08-25T22:21:19Z",
          "updatedAt": "2020-08-25T22:21:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @martinthomson,\r\n\r\n> We have an `ech` extension that appears in the outer CH and the inner CH. The outer contains HPKE junk, which is good. The inner contains ECHNonce (?). It appears in SH and echoes the value from the inner. It appears in EE and contains fallback info.\r\n\r\nI apologize for the lack of clarity. As @MikeBishop suggested, we should add a table that summarizes all of this information. Perhaps something like this:\r\n\r\n  | Message     | Payload type                            |\r\n  |-----------------|------------------------------------------|\r\n  | outer CH     | ClientECH (contains inner CH) |\r\n  | inner CH     | ECHNonce (random number) |\r\n  | SH              | ECHNonce (echoes inner CH on accept; random number on reject) |\r\n  | EE              | ServerECH (contains retry config) |   \r\n\r\n\r\n> But this still has `ech_nonce` defined, and relatively unchanged. So I'm now completely lost.\r\n\r\nAs I've said, I've been trying to keep changes to \"ech_nonce\" out of this PR. We could overload it by having the SH echo the payload of \"ech_nonce\", as you suggest; but this is a significant change to that extension's semantics. In particular, to mitigate the attack described in [Section 10.9.1](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#name-client-reaction-attack-miti), the payload of \"ech_nonce\" needs to be kept secret. This would not be the case if it were echoed in the SH.\r\n\r\nTaking a step back, there's the larger question of whether \"ech_nonce\" is redundant. In particular, if the inner CH.random is independent from the outer CH.random, then the inner CH.random serves the same purpose as the \"ech_nonce\" extension. (See the discussion of issue #253.)\r\n\r\nThis leaves us to options: leave \"ech_nonce\" out of this PR and consider removing it later; or re-purpose \"ech_nonce\" for this PR. I'd be happy with either, but the latter needs to be discussed in the context of #253.\r\n\r\n> (I'm pretty sure that we will need to write a bunch of new code to handle the inner/outer split, but our extension handling code definitely won't like having the same extension in both inner and outer.)\r\n\r\nSomething to keep in mind is that ClientHelloInner is \"synthetic\" in the sense that it doesn't ever appear as a handshake message on the wire. It's consumed by the client-facing server in Shared Mode and used to construct a real ClientHello in Split Mode. Hence, the \"ech\" extension is only offered *on the wire* in CH, SH, and EE.\r\n\r\n",
          "createdAt": "2020-08-26T16:27:38Z",
          "updatedAt": "2020-08-26T17:24:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The usual way to present the different options for extension content is to use the `select` syntax.  But the split between inner and outer makes that hard.  Maybe the right thing to do is use ech_nonce for this and echo that in SH.  Then you have ech_nonce as `opaque[16]` and ech only appears in the outer CH and EE.",
          "createdAt": "2020-08-26T22:42:20Z",
          "updatedAt": "2020-08-26T22:42:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of #287.",
          "createdAt": "2020-09-03T17:13:16Z",
          "updatedAt": "2020-09-03T17:13:16Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Isn't there an issue with spoof and replay? Suppose an MITM observes a transaction and block the server's response. Instead, the MITM constructs its own SH, as a response to the outer CH, but sets the first 8 bytes of the server random to a copy of the 1st 8 bytes in the response of the original server. If the server was doing ECH, the connection between client and MITM will fail -- other wise it will succeed, or at least progress. The MITM has thus detected whether the server was doing ECH.",
          "createdAt": "2020-09-03T17:19:30Z",
          "updatedAt": "2020-09-03T17:19:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema, your question doesn't apply to this PR. Can you please re-post it to  #287?",
          "createdAt": "2020-09-03T17:23:06Z",
          "updatedAt": "2020-09-03T17:23:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDc1OTE4",
          "commit": {
            "abbreviatedOid": "434b0ac"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Why does this use the same construction as `ech_nonce`?  Wouldn't it be better to have the server produce a new value derived from the same context?  That is, make this `ech_nonce` with a different context string.\r\n\r\nHaving the confirmation optional is a feature you should lose.  Absent some concerns in the discussion that I don't share, it isn't a good idea to build all the options.",
          "createdAt": "2020-08-24T01:49:45Z",
          "updatedAt": "2020-08-24T01:49:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODAyODUx",
          "commit": {
            "abbreviatedOid": "434b0ac"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I haven't had the chance to look at this carefully yet (procrastinating on writing perf review things :-) ), but some surface-level comments below:",
          "createdAt": "2020-08-24T19:42:37Z",
          "updatedAt": "2020-08-24T19:58:57Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Did you mean to rename the `ExtensionType` value instead?",
              "createdAt": "2020-08-24T19:42:37Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            },
            {
              "originalPosition": 239,
              "body": "HRR right now is quite a headache if the client doesn't match the inner and outer key_share and cipher suite preferences (to the point that I'd argue we should mandate that in the current form). If we're going the new extension route, I think it makes sense to put the indicator in HRR too. But we can sort that out separately.",
              "createdAt": "2020-08-24T19:49:27Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            },
            {
              "originalPosition": 121,
              "body": "Why is this optional? Either it's part of the protocol or not. The spec should pick one. Variations in specs cause complexity throughout the system (every server would need to test both and make sure they work) and should only be there when they're necessary.\r\n\r\nNote also that TLS does not allow unsolicited extensions, so any ServerHello extension either needs to be in the ClientHello (but mandated), or we that if you offer `ech`, an `ech_confirm` response is allowed as a special case. Alternatively...\r\n\r\nHaving two separate extensions at all seems unnecessary. Why not just use the `ech` codepoint? That would avoid this entire mess. There's plenty of precedent for extensions taking different forms in different contexts (`key_share` looks different between ClientHello, HelloRetryRequest, and ServerHello).\r\n\r\n(Hrm. I'm not sure how the unsolicited extensions rule works if the inner ClientHello is chosen and lacks the `ech` extension. Something we may also need to sort out.)",
              "createdAt": "2020-08-24T19:55:22Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODE1MjQ0",
          "commit": {
            "abbreviatedOid": "4962d98"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T20:01:43Z",
          "updatedAt": "2020-08-24T20:01:44Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "I had the same thought. The problem I see is that we currently use the \"ech\" codepoint for retry keys. We might define a codepoint for \"ech_retry\" so that the confirmation logic is carried by \"ech\". However, the client needs to solicit this extension.\r\n\r\nI'm open to this if it makes more sense!",
              "createdAt": "2020-08-24T20:01:43Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODIyMzQx",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T20:12:57Z",
          "updatedAt": "2020-08-24T20:12:58Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Yes, thanks for spotting this!\r\n\r\nI apologize for that careless mistake.",
              "createdAt": "2020-08-24T20:12:57Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODI2Njgx",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T20:19:54Z",
          "updatedAt": "2020-08-24T20:19:55Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "The retry keys are carried in EncryptedExtensions while this is ServerHello, right? I don't think we've any precedent yet for an SH + EE extension, but extensions having different format between messages is common and seems fine to me.",
              "createdAt": "2020-08-24T20:19:54Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODI4NDU3",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T20:22:42Z",
          "updatedAt": "2020-08-24T20:22:43Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "One nice thing about \"ech\" / \"ech_retry\" is that it aligns ECH with the usual TLS extension logic, since the server can opt-out of both without breaking the protocol. Currently if the client offers \"ech_confirm\", the server MUST respond, or else be non-compliant.",
              "createdAt": "2020-08-24T20:22:42Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODMzMTk2",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T20:30:07Z",
          "updatedAt": "2020-08-24T20:30:07Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "> The retry keys are carried in EncryptedExtensions while this is ServerHello, right?\r\n\r\nYes.\r\n\r\n> I don't think we've any precedent yet for an SH + EE extension, but extensions having different format between messages is common and seems fine to me.\r\n\r\nI was under the impression that this is disallowed in TLS 1.3, but looking at RFC 8446 I'm not so sure.\r\n",
              "createdAt": "2020-08-24T20:30:07Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODkzMTIy",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T22:13:59Z",
          "updatedAt": "2020-08-24T22:14:00Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "> I was under the impression that this is disallowed in TLS 1.3, but looking at RFC 8446 I'm not so sure.\r\n\r\nTo clarify: I'm aware of extensions in which the server's response may be in one of many messages, but I'm not aware of any case in which the same extension appears in multiple messages in the same flight. I'd be fine with this, though it might be a pain for NSS (cc/ @martinthomson).",
              "createdAt": "2020-08-24T22:13:59Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MDA5NTA2",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T00:13:39Z",
          "updatedAt": "2020-08-25T00:13:39Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "I think that we can make it work if we need to.",
              "createdAt": "2020-08-25T00:13:39Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MDA5OTE3",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T00:14:57Z",
          "updatedAt": "2020-08-25T00:14:58Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "Right on, I'll update this PR tomorrow morning.",
              "createdAt": "2020-08-25T00:14:58Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0Njg1NDM1",
          "commit": {
            "abbreviatedOid": "fd7dabb"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T17:10:57Z",
          "updatedAt": "2020-08-25T17:10:58Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "Updated! I dropped \"ech_confirm\" and changed the semantics of \"ech\". Specifically, the extension appears in four messageas:\r\n- ClientHelloOuter, same payload as usual;\r\n- CleintHelloInner, with a random ECHNonce;\r\n- ServerHello, with an ECHNonce that is the same as the ClientHelloInner in case of acceptance and a random value otherwise; and\r\n- EncryptedExtensions, with retry ECHConfigs.",
              "createdAt": "2020-08-25T17:10:57Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0ODAxODQ2",
          "commit": {
            "abbreviatedOid": "9afc2dd"
          },
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "So just so we're clear, this extension now has three possible forms in four locations:\r\n\r\n- ClientECH in ClientHelloOuter\r\n- ECHNonce in ClientHelloInner and ServerHello\r\n- ServerECH in EncryptedExtensions\r\n\r\nIt might be nice to explicitly introduce the extension by saying it has three forms and spell them out.  They're all there, but it's a little confusing to read a definition followed by an exception followed by an exception to the exception.",
          "createdAt": "2020-08-25T19:49:42Z",
          "updatedAt": "2020-08-25T20:08:35Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "```suggestion\r\nWhen the client offers the \"ech\" extension, the server MAY include an \"ech\"\r\n```",
              "createdAt": "2020-08-25T19:49:42Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            },
            {
              "originalPosition": 244,
              "body": "```suggestion\r\nmessage with a ClientECH value, servers set up their HPKE context and\r\n```",
              "createdAt": "2020-08-25T19:54:52Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            },
            {
              "originalPosition": 433,
              "body": "```suggestion\r\n   \"CH, SH, EE\", and \"Recommended\" column being set to \"Yes\".\r\n```",
              "createdAt": "2020-08-25T20:04:02Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTQ1ODUz",
          "commit": {
            "abbreviatedOid": "9afc2dd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:05:21Z",
          "updatedAt": "2020-08-25T22:05:21Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Done.",
              "createdAt": "2020-08-25T22:05:21Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTQ2NDg1",
          "commit": {
            "abbreviatedOid": "9afc2dd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:06:30Z",
          "updatedAt": "2020-08-25T22:06:30Z",
          "comments": [
            {
              "originalPosition": 244,
              "body": "Done.",
              "createdAt": "2020-08-25T22:06:30Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTQ3MzQz",
          "commit": {
            "abbreviatedOid": "9afc2dd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:08:12Z",
          "updatedAt": "2020-08-25T22:08:13Z",
          "comments": [
            {
              "originalPosition": 433,
              "body": "Done.",
              "createdAt": "2020-08-25T22:08:12Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MDgwNDA0",
          "commit": {
            "abbreviatedOid": "98bf22f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This seems very confusing right now.\r\n\r\nWe have an `ech` extension that appears in the outer CH and the inner CH.  The outer contains HPKE junk, which is good.  The inner contains ECHNonce (?).  It appears in SH and echoes the value from the inner.  It appears in EE and contains fallback info.\r\n\r\nBut this still has `ech_nonce` defined, and relatively unchanged.  So I'm now completely lost.\r\n\r\n(I'm pretty sure that we will need to write a bunch of new code to handle the inner/outer split, but our extension handling code definitely won't like having the same extension in both inner and outer.)",
          "createdAt": "2020-08-26T00:58:14Z",
          "updatedAt": "2020-08-26T01:02:43Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "Is this still here?  This change is a little confusing now.  (I find the document confusing, frankly.)",
              "createdAt": "2020-08-26T00:58:15Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 286,
      "id": "MDExOlB1bGxSZXF1ZXN0NDczNDYyODI4",
      "title": "Add ECH confirmation (option (3), can fall back to (2))",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/286",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is an alternative to #283 where by the server indicates what it confirms in the ECHConfig. Either explicitly it indicates acceptance or rejection, as in option (3); or it indicates rejection only, as in option (2). It also adds an expiration date to the ECH configuration.\r\n\r\nThis PR also adds deployment considerations for server rollback. In particular, for option (2) the server must not rollback ECH until the ECH configuration. expires.\r\n\r\nThis addresses #274.",
      "createdAt": "2020-08-25T20:23:16Z",
      "updatedAt": "2020-09-03T17:13:50Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3ee7678e12c49cd6015899e675bf227bbb50835b",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "ech_confirmation2",
      "headRefOid": "8ccf78255009f33cbc3fbe5d6a9b18e40d75bdee",
      "closedAt": "2020-09-03T17:13:50Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "NOTE: This branch needs to be rebased on #283. Ping me if you'd like me to do this.",
          "createdAt": "2020-09-02T18:18:16Z",
          "updatedAt": "2020-09-02T18:18:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of #287.",
          "createdAt": "2020-09-03T17:13:50Z",
          "updatedAt": "2020-09-03T17:13:50Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 287,
      "id": "MDExOlB1bGxSZXF1ZXN0NDczNDYyOTEy",
      "title": "Add ECH confirmation signal",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/287",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This change provides an explicit confirmation of ECH acceptance. To do so, the backend server overwrites the last 8 bytes of the SH.random with a value derived from ClientHelloInner.random and the first 24 bytes of ServerHello.random.\r\n\r\nThis addresses #274.\r\n\r\nREVISED 9/21.",
      "createdAt": "2020-08-25T20:23:21Z",
      "updatedAt": "2020-09-22T20:44:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "375b4587f2981c414b5a737d3e98823c6ce1cba9",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "ech_confirmation3",
      "headRefOid": "213766c135dac70dcf82212cad3a2ccada626b50",
      "closedAt": "2020-09-22T20:44:35Z",
      "mergedAt": "2020-09-22T20:44:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "723af1d0f30c1461902716bfda10e050c25b3511"
      },
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Isn't there an issue with spoof and replay? Suppose an MITM observes a transaction and block the server's response. Instead, the MITM constructs its own SH, as a response to the outer CH, but sets the first 8 bytes of the server random to a copy of the 1st 8 bytes in the response of the original server. If the server was doing ECH, the connection between client and MITM will fail -- other wise it will succeed, or at least progress. The MITM has thus detected whether the server was doing ECH.",
          "createdAt": "2020-09-03T17:21:37Z",
          "updatedAt": "2020-09-03T17:21:37Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Providing details of the attack mentioned above, in QUIC context:\r\n```\r\nCH (include ECH) sent in QUIC Initial Packet ---->\r\n              MITM copies and forwards from its own address ------->\r\n                              Server processes CH/ECH, creates SH.\r\n                              If processing ECH, sticks 8 bytes hint in Server Random\r\n                         <--- Server sends packet in QUIC Initial Packet\r\n              MITM creates its own MITM-SH, with 8 bytes of server random copied from real SH\r\n         <--- MITM coalesces Initial packet (MITM-SH) with Hanshake packet (First bytes of encrypted extension)\r\nIf Client accepts SH, client computes handshake key using secrets from outer CH,\r\nSend ACK in Handshake packet --->\r\n              MITM decrypts handshake packet, assesses that EH was not \r\n              used. Drops the connection at that point.\r\n\r\nIf Client recognizes hint, client computes handshake key using secrets from inner ECH,\r\nand cannot decrypt Handshake packet. Client may send Initial ACK, will not\r\nsend Handshake ACK.\r\n              MITM observes that it does not receive handshake ACK,\r\n              May repeat its own Initial and Handshake packets a couple time to be sure.\r\n              After 3-4 repeats, deduces that ECH was used by client and server.\r\n```",
          "createdAt": "2020-09-03T17:53:11Z",
          "updatedAt": "2020-09-03T17:56:25Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am thinking of solutions that are robust against this kind of MITM attack, but they are more complicated than just copying the 8 bytes. You need to make the 8 byte some kind of hash of both the client's hint and the server's key share. That way, anyone replaying the hint has to use the same key share, and cannot hope to decrypt the responses.",
          "createdAt": "2020-09-03T18:07:29Z",
          "updatedAt": "2020-09-03T18:07:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema: This mechanism isn't designed to prevent an active attacker from deducing whether ECH was used. Note that there are much simpler attacks for doing so: just probe the target server for the ECH configuration, then observe a handshake between the target client and the server.",
          "createdAt": "2020-09-03T18:15:35Z",
          "updatedAt": "2020-09-03T18:15:35Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton I agree that it boils down to \"do we care\". The current ECH design does stick out quite a bit. The MITM can find whether the client sent an ECH extension. So it may make sense to keep it simple, accept the vulnerability, and document it in the ECH security considerations. ",
          "createdAt": "2020-09-03T18:28:18Z",
          "updatedAt": "2020-09-03T18:28:18Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "For that matter, you could replay the ClientHello several times and check whether the interesting bytes of the server's keyshare or the extension remain constant for any of these designs, assuming the server doesn't have more general defenses against a replayed ClientHello.  As long as it's a simple echo, I think that criticism is fair against all of these proposals.  Which means either complexity or accepting that such detection is inevitable anyway.",
          "createdAt": "2020-09-03T18:45:16Z",
          "updatedAt": "2020-09-03T18:45:16Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can fix the constant aspect by incorporating the rest of the ServerHello.random. But yeah, it's a question of what kind of attacker we're interested in for GREASE. If we want to defeat active attacks, I think we'd need to do things like:\r\n\r\n* Bind the *entire* outer CH into the ECH decryption. Otherwise, there's attacks ranging from the key shares to simply replacing the cipher suite list with garbage. (If the server responds, the server must not have looked at the outer cipher suite.)\r\n* Switch decryption failure to fallback rather than error (#290), otherwise the attacker could perturb the ciphertext and see if the server noticed.\r\n\r\nThen there's whether the attacker is allowed to compare config_ids in two connections, or look up and recognize the particular server's ECH config. For example, if you do a DNS lookup or just trigger the retry flow, you can learn the expected config_id and look for it. The trial decryption option or #177 could work. From there, there's still recognizing the public name from the queried ECH config. (Though that depends on whether the public name is one you'd expect in normal traffic or not.)",
          "createdAt": "2020-09-03T20:29:54Z",
          "updatedAt": "2020-09-03T20:29:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding the \"don't stick out\" requirement, the goal of this proposal is *not* to thwart an active distinguisher, but merely to trick a dumb middlebox, which we presume to be passive and ignorant of the configuration. It would be helpful if folks would limit discussion of attacks/mitigations to this narrow threat model and resume discussion of the threat model itself in #274.",
          "createdAt": "2020-09-04T01:17:51Z",
          "updatedAt": "2020-09-04T01:21:20Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think what @davidben is suggesting is that we address @huitema's attack by computing SH.Random as follows:\r\n\r\n```\r\nSH.Random = R || HMAC(CH.Random, R)\r\n```\r\n\r\nHowever, as he says, there seem to be a lot of active attacks to determine if ECH was used on a single connection.\r\n\r\n\r\n",
          "createdAt": "2020-09-08T02:14:33Z",
          "updatedAt": "2020-09-08T02:14:33Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr, I do not think that the fix suggested by @bemasc and @davidben solves the problem. The only change in the attack would be:\r\n```\r\n                         <--- Server sends packet in QUIC Initial Packet\r\n              MITM creates its own MITM-SH, with 8 bytes of server random copied from real SH\r\n                                                 ^\r\n                                                 +-- with 32 bytes...\r\n```\r\nCan we keep this discussion in issue #274?",
          "createdAt": "2020-09-08T04:10:38Z",
          "updatedAt": "2020-09-08T04:11:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "From the interim: merge this, and address \"extended\" trial HMAC variants in a followup PR (or extension in the ECHConfig).",
          "createdAt": "2020-09-21T15:12:30Z",
          "updatedAt": "2020-09-21T15:12:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTE2NzA0",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-01T21:08:19Z",
          "updatedAt": "2020-09-01T21:08:20Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Very minor nitpick: Looks like most other TLS extensions are left unabbreviated. It does mean we lose the nice parallel between `ech_nonce` and `ech_outer_extension`, though if we pick up https://github.com/tlswg/draft-ietf-tls-esni/pull/292, the former will go away. Dunno how important a prefixed `ech_outer_extension` is.",
              "createdAt": "2020-09-01T21:08:19Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTEwMjMx",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for writing this up!",
          "createdAt": "2020-09-01T20:58:11Z",
          "updatedAt": "2020-09-01T21:51:57Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Perhaps add a sentence explaining the purpose of these 8 bytes?\r\n\r\nAlso, can we consider defining the 8-byte payload variant in `ClientECH`'s definition above? I feel like this is a gotcha for implementers.\r\n\r\n\\<digression> The variants wouldn't even need a tag, since we can distinguish based on the length. The smallest normal `ClientECH` is 10 bytes. However, I don't think the TLS presentation language can express C-style unions.",
              "createdAt": "2020-09-01T20:58:12Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 173,
              "body": "Nit: s/which/which ClientHello/",
              "createdAt": "2020-09-01T21:19:39Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 174,
              "body": "Nit: I would refactor the sentence beginning with \"To do so\". Something like this?\r\n\r\n> The client presumes acceptance if the last 8 bytes of the ServerHello.random are equal to the ClientHelloInner's \"ech\" extension payload. Otherwise, it presumes rejection.",
              "createdAt": "2020-09-01T21:24:38Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 355,
              "body": "Style nit: so far, the spec has been hyphenating \"randomly-generated\".",
              "createdAt": "2020-09-01T21:28:29Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 394,
              "body": "(I lied, here's the one place we did not hyphenate \"randomly generated\".)",
              "createdAt": "2020-09-01T21:29:29Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 421,
              "body": "s/thatthe/that the/",
              "createdAt": "2020-09-01T21:33:25Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDM4NzE2",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T17:20:15Z",
          "updatedAt": "2020-09-02T17:20:16Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I'll revert to the old name and we can revisit extension naming once the dust settles.",
              "createdAt": "2020-09-02T17:20:15Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTMxNzg1",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:09:38Z",
          "updatedAt": "2020-09-02T18:09:38Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Good idea! Done.\r\n\r\nRe \"digression\": The tag is only a byte, so the minimum ClientECH is 9 bytes.",
              "createdAt": "2020-09-02T18:09:38Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTM3Nzc3",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:12:27Z",
          "updatedAt": "2020-09-02T18:12:27Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Did s/which/which value/. I don't think we should be calling ClientHelloInner a \"ClientHello\", since ClientHelloInner isn't a handshake message on the wire.",
              "createdAt": "2020-09-02T18:12:27Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTQxOTY2",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:14:20Z",
          "updatedAt": "2020-09-02T18:14:20Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "Good idea! Done.",
              "createdAt": "2020-09-02T18:14:20Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTQzNjU2",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:15:05Z",
          "updatedAt": "2020-09-02T18:15:05Z",
          "comments": [
            {
              "originalPosition": 355,
              "body": "Done.",
              "createdAt": "2020-09-02T18:15:05Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTQ1MDc1",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:15:43Z",
          "updatedAt": "2020-09-02T18:15:43Z",
          "comments": [
            {
              "originalPosition": 421,
              "body": "Done.",
              "createdAt": "2020-09-02T18:15:43Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTQ3NjQ3",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:16:53Z",
          "updatedAt": "2020-09-02T18:16:53Z",
          "comments": [
            {
              "originalPosition": 394,
              "body": "Ack. \"randomly generated\" only appears at one point in the text, which is not related to this change.",
              "createdAt": "2020-09-02T18:16:53Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTY5MTUy",
          "commit": {
            "abbreviatedOid": "8e0668c"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good modulo one comment",
          "createdAt": "2020-09-02T18:45:40Z",
          "updatedAt": "2020-09-02T19:14:01Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Thanks for spelling this out!\r\n\r\nI just realized the \"encrypted_client_hello\" extension is also reused to send `retry_configs` in the ServerHello.  Based on context, we know that the payload is a `ServerECH` rather than a `ClientECH`.\r\n\r\nPerhaps it's fine to use context to distinguish between the ClientHelloOuter's `ClientECH` and the ClientHelloInner's `uint8 accept_confirmation [8]` payload.  You could define a new struct or a type alias.\r\n\r\nSorry to go back on forth on this point. I'm not sure what the better choice is.",
              "createdAt": "2020-09-02T18:45:40Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMjMwOTEw",
          "commit": {
            "abbreviatedOid": "8e0668c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T19:24:09Z",
          "updatedAt": "2020-09-02T19:24:09Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I think it's fine as is. To summarize:\r\n\r\n| Message | Payload |\r\n|--------------|------------|\r\n| ClientHelloOuter | ClientECH (outer variant) |\r\n| ClientHelloInner | ClientECH (inner variant) |\r\n| EncryptedExtensions | ServerECH |",
              "createdAt": "2020-09-02T19:24:09Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxOTc2Mzk0",
          "commit": {
            "abbreviatedOid": "a2672d2"
          },
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-03T15:50:18Z",
          "updatedAt": "2020-09-03T15:50:23Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "Does this design variant ever send the ECH extension in the ServerHello?  Or is it only in the Encrypted Extensions?",
              "createdAt": "2020-09-03T15:50:18Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxOTkyMjM3",
          "commit": {
            "abbreviatedOid": "a2672d2"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-03T16:06:32Z",
          "updatedAt": "2020-09-03T16:06:32Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "Only in EE. ",
              "createdAt": "2020-09-03T16:06:32Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMDU0OTEx",
          "commit": {
            "abbreviatedOid": "a2672d2"
          },
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-03T17:27:52Z",
          "updatedAt": "2020-09-03T17:27:53Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "```suggestion\r\n   \"CH, EE\", and \"Recommended\" column being set to \"Yes\".\r\n```",
              "createdAt": "2020-09-03T17:27:52Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNzczMjA2",
          "commit": {
            "abbreviatedOid": "a2672d2"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T03:30:36Z",
          "updatedAt": "2020-09-08T03:31:57Z",
          "comments": [
            {
              "originalPosition": 316,
              "body": "```suggestion\r\nserver terminates the connection, but does not process the ech extension: if the last 8 bytes of its ServerHello.random\r\n```",
              "createdAt": "2020-09-08T03:30:36Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzM2MDAx",
          "commit": {
            "abbreviatedOid": "a2672d2"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T17:07:01Z",
          "updatedAt": "2020-09-08T17:07:01Z",
          "comments": [
            {
              "originalPosition": 316,
              "body": "Changed to \"i.e., ECH is rejected or ignored\"",
              "createdAt": "2020-09-08T17:07:01Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MDM2OTk3",
          "commit": {
            "abbreviatedOid": "2d88f7b"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-15T20:15:59Z",
          "updatedAt": "2020-09-15T20:15:59Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "s/SrverHello/ServerHello/",
              "createdAt": "2020-09-15T20:15:59Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5OTQ3MTA2",
          "commit": {
            "abbreviatedOid": "2d88f7b"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T19:14:29Z",
          "updatedAt": "2020-09-16T19:14:30Z",
          "comments": [
            {
              "originalPosition": 279,
              "body": "s/for/or",
              "createdAt": "2020-09-16T19:14:30Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNzI0MzUz",
          "commit": {
            "abbreviatedOid": "44b9d41"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T15:17:54Z",
          "updatedAt": "2020-09-21T15:17:54Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "Did we decide that HKDF-Extract was OK? We never use raw HKDF-Extract anywhere else in TLS 1.3.",
              "createdAt": "2020-09-21T15:17:54Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNzYyODc3",
          "commit": {
            "abbreviatedOid": "44b9d41"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T15:59:44Z",
          "updatedAt": "2020-09-21T15:59:45Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "It seems fine to me, since the ClientHelloInner.random is secret and we need is a pseudorandom string. I'll take another look at the HKDF paper and get back to you. (Also, it would be great to hear from others on this.)",
              "createdAt": "2020-09-21T15:59:44Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODA4MjU4",
          "commit": {
            "abbreviatedOid": "c870041"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T16:56:43Z",
          "updatedAt": "2020-09-21T16:56:44Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "Judging from [1, Section 6], just using HKDF-Extract might be fine, but it seems rather \"hacky\". I think we should err on the conservative side and use HKDF-Extract-then-Expand. Will update the PR to reflect this.",
              "createdAt": "2020-09-21T16:56:44Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMzc5NzU4",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Very succinct! I have a couple of requests to clarify things, but other than that this should be good to go.",
          "createdAt": "2020-09-22T11:53:45Z",
          "updatedAt": "2020-09-22T12:10:06Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "(As on the nonce PR)\r\n\r\n```suggestion\r\n- It MUST include the \"encrypted_client_hello\" extension in its\r\n```",
              "createdAt": "2020-09-22T11:53:46Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 209,
              "body": "```suggestion\r\nvalue of ServerHello.random[0:24] is generated as usual by invoking a secure\r\nrandom number generator (see {{RFC8446}}, Section 4.1.2).\r\n```",
              "createdAt": "2020-09-22T11:56:30Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 281,
              "body": "```suggestion\r\nNote that the same bytes of the ServerHello.random are used to implement\r\ndowngrade protection for TLS 1.3 (see {{RFC8446}}, Section\r\n4.1.3). The backend server's signal of acceptance does not interfere with this\r\nmechanism because ECH is only supported in TLS 1.3 or higher.\r\n```",
              "createdAt": "2020-09-22T12:01:07Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 276,
              "body": "Can we be explicit with the collision probability? (RFC8446 reserves two sentinel values for the downgrade signals.) We might also note that this probability is equivalent to that of network or transport failures, so in practice it's not much of a concern.",
              "createdAt": "2020-09-22T12:04:35Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 261,
              "body": "Why is this Abuse? \"ECH Acceptance Signal Collisions\" seems to better capture the text below.",
              "createdAt": "2020-09-22T12:05:23Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 266,
              "body": "I understand that technically the active adversary can try to exploit this to find matching sessions, but I think the notion might just confuse readers.\r\n\r\n```suggestion\r\n{{backend-server-behavior}} for details.) This behavior increases the likelihood of the ServerHello.random\r\n```",
              "createdAt": "2020-09-22T12:06:39Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTQzNTEx",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T14:48:06Z",
          "updatedAt": "2020-09-22T14:48:06Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "Is MUST appropriate here? SHOULD should suffice, since the client would regard ECH as \"securely disabled\".",
              "createdAt": "2020-09-22T14:48:06Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTQ0MDcw",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T14:48:39Z",
          "updatedAt": "2020-09-22T14:48:39Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "Done.",
              "createdAt": "2020-09-22T14:48:39Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTQ1MjM0",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T14:49:43Z",
          "updatedAt": "2020-09-22T14:49:44Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "Done.",
              "createdAt": "2020-09-22T14:49:44Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTUxMDM1",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T14:54:59Z",
          "updatedAt": "2020-09-22T14:54:59Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "> Can we be explicit with the collision probability?\r\n\r\nDone.\r\n\r\n> (RFC8446 reserves two sentinel values for the downgrade signals.)\r\n\r\nNot sure what this comment is about.\r\n\r\n> We might also note that this probability is equivalent to that of network or transport failures, so in practice it's not much of a concern.\r\n\r\nWould you mind suggesting text for this? I'm not sure I know enough about TCP to be accurate about this.",
              "createdAt": "2020-09-22T14:54:59Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTUyNDc1",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T14:56:20Z",
          "updatedAt": "2020-09-22T14:56:21Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "The title is meant to encompass all possible attacks that exploit the acceptance confirmation signal. How about \"Attacks Exploiting Acceptance Confirmation\"?",
              "createdAt": "2020-09-22T14:56:21Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTUzNjI4",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T14:57:23Z",
          "updatedAt": "2020-09-22T14:57:23Z",
          "comments": [
            {
              "originalPosition": 266,
              "body": "Agreed. Done.",
              "createdAt": "2020-09-22T14:57:23Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTY1MTE3",
          "commit": {
            "abbreviatedOid": "72a029b"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:08:16Z",
          "updatedAt": "2020-09-22T15:08:17Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "Done, in light of your comment on #292.",
              "createdAt": "2020-09-22T15:08:17Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODMxOTM1",
          "commit": {
            "abbreviatedOid": "72a029b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T20:44:13Z",
          "updatedAt": "2020-09-22T20:44:14Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "```suggestion\r\n## Attacks Exploiting Acceptance Confirmation\r\n```",
              "createdAt": "2020-09-22T20:44:13Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODMyMDg4",
          "commit": {
            "abbreviatedOid": "213766c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T20:44:27Z",
          "updatedAt": "2020-09-22T20:44:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODMyNDU4",
          "commit": {
            "abbreviatedOid": "213766c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T20:44:59Z",
          "updatedAt": "2020-09-22T20:44:59Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "Ah, missed this. I'll file an issue to add it! ",
              "createdAt": "2020-09-22T20:44:59Z",
              "updatedAt": "2020-09-22T20:44:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 291,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc3MjYzMjcz",
      "title": "Clarify distinction between rejection and decryption failure",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/291",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In places, the current draft doesn't make a clear distinction between rejection and decryption failure. In particular \"cannot decrypt\" can be interpreted either:\r\n\r\n* \"the client-facing server doesn't recognize the configuration specified by the client\"; \r\n* or \"the client-facing server recognizes the configuration but decryption fails\".\r\n\r\nThis change resolves this ambiguity. Addresses issue #290.\r\n",
      "createdAt": "2020-09-01T18:42:52Z",
      "updatedAt": "2020-09-18T21:19:23Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3426cfbf3f25bd2aa23a13e8700702717c05a42f",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "cannot_decrypt",
      "headRefOid": "629e5ba15ff1bf55d90e79e6c08b962fc788472a",
      "closedAt": "2020-09-18T21:19:23Z",
      "mergedAt": "2020-09-18T21:19:23Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2a56d1fdac5b80376554cb14b9089f7acb8f1d47"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzg3MTA1",
          "commit": {
            "abbreviatedOid": "629e5ba"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T21:19:18Z",
          "updatedAt": "2020-09-18T21:19:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 292,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc3MzMwMjI0",
      "title": "Remove \"ech_nonce\" extension and clarify client behavior",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/292",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The purpose of \"ech_nonce\" is to mitigate the \"client reaction\" attack described in security considerations. It is redundant, however, since the ClientHelloInner.random serves the same function. This change removes the \"ech_nonce\" extension and clarifies the client behavior so that securely generating ClientHelloInner.random is an explicit requirement.\r\n\r\nThis addresses #253.\r\n\r\nBased on #287.",
      "createdAt": "2020-09-01T20:56:09Z",
      "updatedAt": "2020-09-22T21:10:01Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "723af1d0f30c1461902716bfda10e050c25b3511",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "remove_ech_nonce",
      "headRefOid": "4995044192c4a3688faa1b3cb53098cd7c9bdbe5",
      "closedAt": "2020-09-22T21:10:01Z",
      "mergedAt": "2020-09-22T21:10:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "32ca8ad76a8f2c1ae6e8e29cdacff462664afcb7"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2020-09-21T15:27:09Z",
          "updatedAt": "2020-09-21T15:27:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNjM3NDgw",
          "commit": {
            "abbreviatedOid": "a54e79b"
          },
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T14:06:11Z",
          "updatedAt": "2020-09-21T14:12:06Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "TLS 1.3 or above.",
              "createdAt": "2020-09-21T14:06:11Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNTQ3NTAx",
          "commit": {
            "abbreviatedOid": "a54e79b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-21T12:29:42Z",
          "updatedAt": "2020-09-21T14:27:50Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "How about \"MUST NOT include a PSK or PSK binder\"?",
              "createdAt": "2020-09-21T12:29:42Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 77,
              "body": "Server's don't enforce this padding, and in some situations clients may wish to use a padding scheme that's different from what's in {{padding}}, so I think a MUST a bit too strong here.\r\n\r\n```suggestion\r\n1. It SHOULD contain TLS padding {{!RFC7685}} as described in {{padding}}.\r\n```",
              "createdAt": "2020-09-21T12:32:03Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 60,
              "body": "Hmm, without some designation for what's sensitive and what's not, this seems to be hard to interpret as a client. Maybe we move this to a sentence after list, and just say something like, \"Clients can also offer dummy values for extensions deemed sensitive\"?",
              "createdAt": "2020-09-21T12:34:33Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n1. It MUST offer to negotiate TLS 1.3 or above.\r\n```",
              "createdAt": "2020-09-21T14:27:35Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODQ0NjI4",
          "commit": {
            "abbreviatedOid": "3074162"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T17:45:27Z",
          "updatedAt": "2020-09-21T17:45:27Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Done.",
              "createdAt": "2020-09-21T17:45:27Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODQ4NDM2",
          "commit": {
            "abbreviatedOid": "3074162"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T17:50:48Z",
          "updatedAt": "2020-09-21T17:50:48Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Done. The text needs to be updated to reflect this new rule, so I'm adding an \"OPEN ISSUE\" for this here. I'd be happy to do this as part of this PR, but the change will require additional review.",
              "createdAt": "2020-09-21T17:50:48Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODU2OTIx",
          "commit": {
            "abbreviatedOid": "3074162"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T18:02:16Z",
          "updatedAt": "2020-09-21T18:02:16Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Done. I also think we should offer this guidance. I'm leaving doing so as an \"OPEN ISSUE\".",
              "createdAt": "2020-09-21T18:02:16Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODU3Mzc0",
          "commit": {
            "abbreviatedOid": "3074162"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T18:02:56Z",
          "updatedAt": "2020-09-21T18:02:57Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Done.",
              "createdAt": "2020-09-21T18:02:56Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMzczNjM0",
          "commit": {
            "abbreviatedOid": "d1ff96c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "LGTM with some minor changes and reversions requested. (There's also some content from #287 that seems to have bled over here?)",
          "createdAt": "2020-09-22T11:44:38Z",
          "updatedAt": "2020-09-22T11:51:59Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "```suggestion\r\n1. It MUST NOT include a \"pre_shared_key\" extension. [[OPEN ISSUE: The text needs to be\r\n   updated to reflect this rule.]]\r\n```",
              "createdAt": "2020-09-22T11:44:38Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 134,
              "body": "Why substitutes? Why not just drop them from ClientHelloOuter entirely?",
              "createdAt": "2020-09-22T11:46:07Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 133,
              "body": "```suggestion\r\noffered in the ClientHelloOuter. [[OPEN ISSUE: We should provide guidance on\r\n```",
              "createdAt": "2020-09-22T11:46:13Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 292,
              "body": "Please revert this change -- this MUST was there so clients could rely on this particular version of ECH being deployable. (We can discuss it in a separate issue.)\r\n\r\n```suggestion\r\n- It MUST include the \"encrypted_client_hello\" extension in its\r\n```",
              "createdAt": "2020-09-22T11:48:05Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 347,
              "body": "Should the server also assert that the random values are different? ",
              "createdAt": "2020-09-22T11:49:20Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 371,
              "body": "This doesn't seem part of this PR?",
              "createdAt": "2020-09-22T11:49:54Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 443,
              "body": "Ditto here on this being unrelated to the nonce?",
              "createdAt": "2020-09-22T11:50:31Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 501,
              "body": "Let's move this to 0xff04.",
              "createdAt": "2020-09-22T11:51:00Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 488,
              "body": "```suggestion\r\nClientHelloInner.random prevents this attack. In particular, since the\r\n```",
              "createdAt": "2020-09-22T11:51:08Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTU4NTYy",
          "commit": {
            "abbreviatedOid": "d1ff96c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:01:59Z",
          "updatedAt": "2020-09-22T15:01:59Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "Excellent! Done.",
              "createdAt": "2020-09-22T15:01:59Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTU5NTAx",
          "commit": {
            "abbreviatedOid": "d1ff96c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:02:53Z",
          "updatedAt": "2020-09-22T15:02:53Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "\"substitutes\" = \"innocuous values for sensitive extensions\". Is that more clear?",
              "createdAt": "2020-09-22T15:02:53Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTYwMjc0",
          "commit": {
            "abbreviatedOid": "d1ff96c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:03:39Z",
          "updatedAt": "2020-09-22T15:03:39Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Duh. Done.",
              "createdAt": "2020-09-22T15:03:39Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTYxMjMw",
          "commit": {
            "abbreviatedOid": "d1ff96c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:04:32Z",
          "updatedAt": "2020-09-22T15:04:32Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "Ack. Fixing in #287, then rebasing here.",
              "createdAt": "2020-09-22T15:04:32Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTY2NTg4",
          "commit": {
            "abbreviatedOid": "8f8b6c4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:09:41Z",
          "updatedAt": "2020-09-22T15:09:41Z",
          "comments": [
            {
              "originalPosition": 371,
              "body": "This PR is based on #287, which is why this text appears here. If you focus your review on the last commit, it should be clear what the changes are.",
              "createdAt": "2020-09-22T15:09:41Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTY3OTI1",
          "commit": {
            "abbreviatedOid": "8f8b6c4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:10:31Z",
          "updatedAt": "2020-09-22T15:10:31Z",
          "comments": [
            {
              "originalPosition": 501,
              "body": "What should we do about \"outer_extension\" (currently 0xff04)?",
              "createdAt": "2020-09-22T15:10:31Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTY5MzA4",
          "commit": {
            "abbreviatedOid": "8f8b6c4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:11:03Z",
          "updatedAt": "2020-09-22T15:11:04Z",
          "comments": [
            {
              "originalPosition": 488,
              "body": "Done.",
              "createdAt": "2020-09-22T15:11:03Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODQxNzg2",
          "commit": {
            "abbreviatedOid": "4995044"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T20:58:39Z",
          "updatedAt": "2020-09-22T20:58:39Z",
          "comments": [
            {
              "originalPosition": 501,
              "body": "Oops, I meant 0xff03. Heh. Let's just revisit these values in a followup PR.",
              "createdAt": "2020-09-22T20:58:39Z",
              "updatedAt": "2020-09-22T20:58:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODQxOTU5",
          "commit": {
            "abbreviatedOid": "4995044"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T20:58:54Z",
          "updatedAt": "2020-09-22T20:58:55Z",
          "comments": [
            {
              "originalPosition": 347,
              "body": "What would be the purpose?",
              "createdAt": "2020-09-22T20:58:55Z",
              "updatedAt": "2020-09-22T20:58:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODQ4NzAx",
          "commit": {
            "abbreviatedOid": "4995044"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T21:09:12Z",
          "updatedAt": "2020-09-22T21:09:13Z",
          "comments": [
            {
              "originalPosition": 347,
              "body": "(Chatted offline -- maybe not now!)",
              "createdAt": "2020-09-22T21:09:12Z",
              "updatedAt": "2020-09-22T21:09:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODQ4ODQw",
          "commit": {
            "abbreviatedOid": "4995044"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T21:09:23Z",
          "updatedAt": "2020-09-22T21:09:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 293,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc3NTA3OTAz",
      "title": "Revise \"outer_extension\" (postponed until after -08)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/293",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The \"outer_extension\" mechanism doesn't preserve the order of extensions in the ClientHelloInner. This change replaces it with a mechanism that does.\r\n\r\nThis addresses #262 and might impact #263.",
      "createdAt": "2020-09-02T01:30:33Z",
      "updatedAt": "2020-10-14T23:29:29Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3426cfbf3f25bd2aa23a13e8700702717c05a42f",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "outer_extensions_compression",
      "headRefOid": "67c93eea32548a8bd170fd82e98539a0b70acbc8",
      "closedAt": "2020-10-14T23:29:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson \r\n\r\n> This is going to be the opposite of compression in many cases. This only compresses if an extension payload is greater than Nh + 4, which will severely limit applicability.\r\n\r\nWell, the benefit can be amortized across multiple extensions. So as long as the compressed data exceeds Nh + 2*L, where L is the number of compressed extensions, you've succeeded.\r\n\r\n> How about an alternative design where you list all the compressed extensions in order and then provide a bit list to indicate how tointerleave them with other extensions:\r\n\r\nI had a similar idea ... I think it can work, but it's a bit more complex. Moreover, the current PR is closer to the proposal discussed in #262. But I'm happy to change it if that's where people want to go.",
          "createdAt": "2020-09-02T17:12:33Z",
          "updatedAt": "2020-09-02T18:57:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "To recap my comments at the mic: I think we should go back and ask what extensions will actually benefit from this treatment in typical client hello. The only example I am aware of is KeyShare (and principally only PQ). And so my put would be to go with the simplest thing that covers most of these cases. If all we have is KeyShare, then I think requiring things to be contiguous is good enough, in that if we end up with CompressibleExtension2 in future people can just serialize it next to KeyShare.\r\n",
          "createdAt": "2020-09-03T17:54:20Z",
          "updatedAt": "2020-09-03T17:57:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this in favor of @davidben's suggestion in this issue: #323.",
          "createdAt": "2020-10-09T00:20:14Z",
          "updatedAt": "2020-10-09T00:20:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, brain fart. This isn't closed by a solution to #323.",
          "createdAt": "2020-10-09T00:22:08Z",
          "updatedAt": "2020-10-09T00:22:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think we should go back and ask what extensions will actually benefit from this treatment in typical client hello.\r\n\r\nI'd actually argue the opposite. Most extensions don't actually benefit from being sent twice because they're the same across every connection made by that client. Even an empty extension costs four bytes normally and (marginally) costs two bytes compressed. Shrinking the ciphertext not only saves bytes for ECH ClientHellos, but it makes it cheaper to add GREASE to non-ECH ClientHellos.\r\n\r\nRegardless, I agree with your conclusion:\r\n\r\n>  If all we have is KeyShare, then I think requiring things to be contiguous is good enough, in that if we end up with CompressibleExtension2 in future people can just serialize it next to KeyShare.\r\n\r\nThe only extension with an ordering constraint is PSK, which would never be compressed anyway. The client can fiddle with the order as needed to compress the extensions it wants to compress.\r\n\r\n> Sorry, brain fart. This isn't closed by a solution to #323.\r\n\r\n#323 might open up a few more options by removing inner_digest, like including multiple outer_extensions if you want to compress multiple runs of extensions. (I think that was an earlier design?) That said, I agree with @ekr that the ordering thing isn't a big deal.",
          "createdAt": "2020-10-09T02:16:35Z",
          "updatedAt": "2020-10-09T02:17:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ordering is no longer an issue if we're authenticating ClientHelloOuter as described in #323. It does matter to an extent if we're binding outer extensions by hashing the fully formed ClientHelloInner. In particular, the client needs to ensure that inner_digest is the hash of whatever ClientHelloInner is decompressed by the server.\r\n\r\nIn any case, a solution to #323 would make the motivation for this PR largely irrelevant.",
          "createdAt": "2020-10-09T15:19:46Z",
          "updatedAt": "2020-10-09T15:19:46Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#323 doesn't save you from matching the order. It is a requirement in the handshake itself that the client and server act on a byte-for-byte identical ClientHelloInner. It goes in the handshake transcript.",
          "createdAt": "2020-10-09T15:27:26Z",
          "updatedAt": "2020-10-09T15:29:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this for now. We could revisit it, but my guess is that we're well on our way to squeezing sufficiently many bytes out of the ClientHelloInner.",
          "createdAt": "2020-10-14T23:29:29Z",
          "updatedAt": "2020-10-14T23:29:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMzQ0MTk5",
          "commit": {
            "abbreviatedOid": "4eb8c24"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This is going to be the opposite of compression in many cases.  This only compresses if an extension payload is greater than Nh + 4, which will severely limit applicability.\r\n\r\nHow about an alternative design where you list all the compressed extensions in order and then provide a bit list to indicate how to interleave them with other extensions:\r\n\r\n0 = use one extension from inner\r\n1 = use one extension from outer\r\n\r\nThen you can bind to the uncompressed expansion.  The only constraint here is that compressed extensions in the outer need to appear in the same order as the inner for this to work.\r\n\r\n(That's just an offhand design; I'm sure that something better can be constructed.)",
          "createdAt": "2020-09-02T02:09:08Z",
          "updatedAt": "2020-09-02T02:15:02Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nthe client and server MUST NOT offer these extensions in any handshake message;\r\n```\r\n\r\n\"MAY NOT\" is not an acceptable form.",
              "createdAt": "2020-09-02T02:09:08Z",
              "updatedAt": "2020-09-03T01:26:30Z"
            },
            {
              "originalPosition": 80,
              "body": "```suggestion\r\n   The payload is set to `inner_digest = Expand(Extract(\"\", inner),\r\n```",
              "createdAt": "2020-09-02T02:09:54Z",
              "updatedAt": "2020-09-03T01:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDMzNTQ2",
          "commit": {
            "abbreviatedOid": "4eb8c24"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T17:13:27Z",
          "updatedAt": "2020-09-02T17:13:28Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Done.",
              "createdAt": "2020-09-02T17:13:27Z",
              "updatedAt": "2020-09-03T01:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDM0MTYy",
          "commit": {
            "abbreviatedOid": "0e291dc"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T17:14:14Z",
          "updatedAt": "2020-09-02T17:14:15Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Done.",
              "createdAt": "2020-09-02T17:14:15Z",
              "updatedAt": "2020-09-03T01:26:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 296,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc3OTIwODA5",
      "title": "s/Unmarshal/Deserialize/ to align with HPKE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/296",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "draft-irtf-cfrg-hpke-05 switched from Unmarshal to Deserialize. Switch\r\nECH to match. See #294.",
      "createdAt": "2020-09-02T15:55:34Z",
      "updatedAt": "2020-09-02T18:56:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3ee7678e12c49cd6015899e675bf227bbb50835b",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "deserialize",
      "headRefOid": "fb3904dbe36236014bed67161ad359d74521d7e1",
      "closedAt": "2020-09-02T18:56:57Z",
      "mergedAt": "2020-09-02T18:56:57Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "317652d989f30f8315ed18feddc60b744d27d1ca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDI4ODY4",
          "commit": {
            "abbreviatedOid": "1e11a44"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T17:07:16Z",
          "updatedAt": "2020-09-02T17:07:16Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I think we should also drop the \"HPKE.KEM.\" prefix, here and below. This isn't defined in the HPKE spec: instead, \"Deserialize()\" is a method associated with the KEM algorithm.",
              "createdAt": "2020-09-02T17:07:16Z",
              "updatedAt": "2020-09-02T18:49:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTcyMTMw",
          "commit": {
            "abbreviatedOid": "fb3904d"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:49:49Z",
          "updatedAt": "2020-09-02T18:49:49Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done. I agree with you HPKE.KEM isn't defined, though I'm a little worried that Deserialize is too generic. I adjusted the paragraph below in hopes of helping that.",
              "createdAt": "2020-09-02T18:49:49Z",
              "updatedAt": "2020-09-02T18:49:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTc3MDcx",
          "commit": {
            "abbreviatedOid": "fb3904d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-02T18:56:48Z",
          "updatedAt": "2020-09-02T18:56:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTc3MTc0",
          "commit": {
            "abbreviatedOid": "fb3904d"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:56:56Z",
          "updatedAt": "2020-09-02T18:56:57Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Looks good.",
              "createdAt": "2020-09-02T18:56:56Z",
              "updatedAt": "2020-09-02T18:56:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 298,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc4MTI0MTEz",
      "title": "Narrow the size of possible configuration identifiers.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/298",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also, rename config_digest to config_id to avoid confusion with cryptographic hash digests.\r\n\r\nCloses #288. cc @cjpatton, @davidben, @martinthomson ",
      "createdAt": "2020-09-02T19:42:30Z",
      "updatedAt": "2020-09-02T20:48:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "317652d989f30f8315ed18feddc60b744d27d1ca",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/config-id-and-size",
      "headRefOid": "3069de421aa76234e34782d4f530f1bd8ab74575",
      "closedAt": "2020-09-02T20:48:24Z",
      "mergedAt": "2020-09-02T20:48:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3426cfbf3f25bd2aa23a13e8700702717c05a42f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMjQ5MjM3",
          "commit": {
            "abbreviatedOid": "00db98f"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-02T19:50:40Z",
          "updatedAt": "2020-09-02T19:50:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMjc0MTY3",
          "commit": {
            "abbreviatedOid": "00db98f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-02T20:27:34Z",
          "updatedAt": "2020-09-02T20:28:58Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "nit: s/0..2^-1/0..255/ for consistency with the rest of the spec.",
              "createdAt": "2020-09-02T20:27:34Z",
              "updatedAt": "2020-09-02T20:46:20Z"
            },
            {
              "originalPosition": 25,
              "body": "This section doesn't exist, which is why CI is failing.",
              "createdAt": "2020-09-02T20:28:51Z",
              "updatedAt": "2020-09-02T20:46:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 299,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc4MjQ5NzU5",
      "title": "Fix the alerts reference.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/299",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "{#alerts} is cited over in {#encrypted-client-hello} but points to the wrong section.",
      "createdAt": "2020-09-02T23:53:01Z",
      "updatedAt": "2020-09-18T21:12:00Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3426cfbf3f25bd2aa23a13e8700702717c05a42f",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "alerts-ref",
      "headRefOid": "35328efc3656e2c8d88b8b4d504655ff32df4126",
      "closedAt": "2020-09-18T21:12:00Z",
      "mergedAt": "2020-09-18T21:12:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "141a7bef46cb506e0e69e70e9a9278c38550f34b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzgzNzc1",
          "commit": {
            "abbreviatedOid": "35328ef"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T21:11:55Z",
          "updatedAt": "2020-09-18T21:11:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 302,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg5NTQyMTI4",
      "title": "Fix a misrepresentation of \"encrypted_ch\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/302",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #301.",
      "createdAt": "2020-09-18T21:09:31Z",
      "updatedAt": "2020-09-18T21:11:14Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3426cfbf3f25bd2aa23a13e8700702717c05a42f",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "nit1",
      "headRefOid": "a7fa0ec1b76d998b7e50400a5e9f1db35bf3138b",
      "closedAt": "2020-09-18T21:11:14Z",
      "mergedAt": "2020-09-18T21:11:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "61062036c9551392d1c15068d513dd36058e227a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzgzNDE1",
          "commit": {
            "abbreviatedOid": "a7fa0ec"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T21:11:10Z",
          "updatedAt": "2020-09-18T21:11:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 303,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg5NTQ1NzY1",
      "title": "Lock ECHConfig.version to the codepoint and advance to 0xff08.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/303",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses https://github.com/tlswg/draft-ietf-tls-esni/issues/297.",
      "createdAt": "2020-09-18T21:19:36Z",
      "updatedAt": "2020-09-18T21:30:46Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2a56d1fdac5b80376554cb14b9089f7acb8f1d47",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "lock_version_to_codepoint",
      "headRefOid": "597c1cd4f7657e8f14a434c8094a8b26520c78bf",
      "closedAt": "2020-09-18T21:30:46Z",
      "mergedAt": "2020-09-18T21:30:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "60572fbaec969b520288e997347af81981b000ad"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzkxOTc3",
          "commit": {
            "abbreviatedOid": "597c1cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T21:30:42Z",
          "updatedAt": "2020-09-18T21:30:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 304,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg5NTQ4MjIy",
      "title": "Remove reference to \"'ech_accept' response type\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/304",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #267.",
      "createdAt": "2020-09-18T21:27:00Z",
      "updatedAt": "2020-09-18T21:31:04Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2a56d1fdac5b80376554cb14b9089f7acb8f1d47",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "nit2",
      "headRefOid": "84f75756bfd7990773d1e647dd05bea4625dc8a1",
      "closedAt": "2020-09-18T21:31:04Z",
      "mergedAt": "2020-09-18T21:31:04Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "375b4587f2981c414b5a737d3e98823c6ce1cba9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzkyMDk0",
          "commit": {
            "abbreviatedOid": "84f7575"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T21:30:57Z",
          "updatedAt": "2020-09-18T21:30:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 305,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkwOTExODcz",
      "title": "Rewrite security and privacy goals",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/305",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #260.\r\n\r\ncc @cjpatton ",
      "createdAt": "2020-09-22T12:41:17Z",
      "updatedAt": "2020-09-22T21:25:44Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "573dc6af51be3c633022bae6ae31f1b2b31646db",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/goals",
      "headRefOid": "7203bc0fe956e6e85762886ec483b8c2f4d109da",
      "closedAt": "2020-09-22T21:25:43Z",
      "mergedAt": "2020-09-22T21:25:43Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "044792db0b118e41089b05c6b1f2f9c641376114"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTA2ODk4",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-22T14:14:53Z",
          "updatedAt": "2020-09-22T14:43:42Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\"form\" -> \"comprise\"",
              "createdAt": "2020-09-22T14:14:53Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 12,
              "body": "\"that protects SNIs\" -> \"sensitive ClientHello parameters, including the SNI,\"\r\n",
              "createdAt": "2020-09-22T14:19:49Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 12,
              "body": "\"for all of the domains\" -> \"on behalf of all domains\"",
              "createdAt": "2020-09-22T14:20:07Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 30,
              "body": "\"a\" -> \"the\"\r\n\"is ensuring\" -> \"is to ensure\"",
              "createdAt": "2020-09-22T14:24:19Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 19,
              "body": "\"SNI protection\" -> \"Usage of this mechanism\" ",
              "createdAt": "2020-09-22T14:26:35Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 20,
              "body": "\"a particular service provider without revealing the specific private serer from the anonymity set\" -> \"a particular service provider, but does not reveal which server terminates the connection\".",
              "createdAt": "2020-09-22T14:28:36Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 32,
              "body": "\"modulo traffic analysis\": I would suggest cutting this and leaving it to Security Considerations. It's a matter that a sophisticated service provider might try to address, so we don't want to exclude this here.",
              "createdAt": "2020-09-22T14:30:20Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 5,
              "body": "I think the term \"anonymity set\" needs to be more clearly defined here. It warrants a short paragraph.",
              "createdAt": "2020-09-22T14:31:01Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 52,
              "body": "A more important example of an active attacker is the one that tries to break the primary security goal of ECH. A cesnor is an example of a \"don't stick out\" attacker. I suggest replacing the last line with something like this: \r\n\r\n> In short, an active attacker corresponds to the conventional threat model for TLS ({{RFC8446}}, Section ??).",
              "createdAt": "2020-09-22T14:34:30Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 70,
              "body": "\"a specific uses or negotiates ECH\" -> \"ECH was accepted in a particular connection\".",
              "createdAt": "2020-09-22T14:35:42Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 72,
              "body": "I would replace this enum list with a one-liner at the end of the preceding paragraph. E.g.,:\r\n\r\n> This protocol aims to achieve both properties, assuming the attacker is passive and does not know the set of ECH configurations offered by the server. It does not achieve these goals for active attackers.",
              "createdAt": "2020-09-22T14:38:55Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 79,
              "body": "Add reference to {{grease-extensions}}",
              "createdAt": "2020-09-22T14:39:43Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 68,
              "body": "The text below should have a reference to the \"don't stick out\" doc.",
              "createdAt": "2020-09-22T14:42:03Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 87,
              "body": "I think we should elaborate on this a bit more. Readers might take issue with the claim that ECH is not suitable for censorship circumvention. In particular, there may be deployment scenarios in which keeping the ECH configuration a secret is feasible, and \"don't stick out\" security against active adversaries might be possible in that setting.",
              "createdAt": "2020-09-22T14:43:34Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTg4MDIy",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:28:38Z",
          "updatedAt": "2020-09-22T15:28:39Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "We can, but I don't think we need to do that here (in this PR).",
              "createdAt": "2020-09-22T15:28:39Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTkwNDEx",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:31:02Z",
          "updatedAt": "2020-09-22T15:31:02Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "At a minimum, I would suggest removing this line. We can have a new PR for language around censorship circumvention.",
              "createdAt": "2020-09-22T15:31:02Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTkzMjUw",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:34:02Z",
          "updatedAt": "2020-09-22T15:34:02Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "That works for me!",
              "createdAt": "2020-09-22T15:34:02Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTkzNDc3",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:34:16Z",
          "updatedAt": "2020-09-22T15:34:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It's defined where it's used, no?",
              "createdAt": "2020-09-22T15:34:16Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTk1MDY5",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:35:54Z",
          "updatedAt": "2020-09-22T15:35:54Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I'll add that, instead of replace the censor example.",
              "createdAt": "2020-09-22T15:35:54Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTk3Mzk0",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:38:17Z",
          "updatedAt": "2020-09-22T15:38:18Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Wouldn't hurt!",
              "createdAt": "2020-09-22T15:38:18Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTk5MTEz",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:40:04Z",
          "updatedAt": "2020-09-22T15:40:04Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Nice! I'll do that.",
              "createdAt": "2020-09-22T15:40:04Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjAwMzA2",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:41:17Z",
          "updatedAt": "2020-09-22T15:41:17Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "We also have not done the analysis to know if it is possible in that setting. So, for now, I'd prefer we just be up front about this.",
              "createdAt": "2020-09-22T15:41:17Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjAwMzIx",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:41:17Z",
          "updatedAt": "2020-09-22T15:41:17Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Yeah, better to put it where it's first defined. I guess my issue is how it's defined. It's not that they have the same configuration ... what matters is simply that the ClientHello protection service is provided on their behalf. Maybe replace \"wherein all elements have a consistent configuration...\" with \"of servers for which the service is provided\".",
              "createdAt": "2020-09-22T15:41:17Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjAxNjQ3",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:42:39Z",
          "updatedAt": "2020-09-22T15:42:39Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Ack.",
              "createdAt": "2020-09-22T15:42:39Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjkzMjMw",
          "commit": {
            "abbreviatedOid": "7fdcc97"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T17:31:20Z",
          "updatedAt": "2020-09-22T17:31:20Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Chatted offline -- will improve the definition in a separate issue!",
              "createdAt": "2020-09-22T17:31:20Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODUxMTA4",
          "commit": {
            "abbreviatedOid": "7fdcc97"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-22T21:13:06Z",
          "updatedAt": "2020-09-22T21:18:52Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\ne.g., the set of supported application protocols, ciphersuites, TLS versions, and\r\n```",
              "createdAt": "2020-09-22T21:13:06Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nsame anonymity set are indistinguishable from one another without affecting any existing security properties of TLS 1.3. See\r\n{{goals}} for more details about the ECH security and privacy goals.\r\n```",
              "createdAt": "2020-09-22T21:13:58Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 36,
              "body": "No need to say what kind of attacker if it's both.",
              "createdAt": "2020-09-22T21:14:09Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nTLS 1.3 {{RFC8446}}.\r\n```\r\nI would just stay out of censorship. I think some censors are maybe passive?\r\n",
              "createdAt": "2020-09-22T21:16:48Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 80,
              "body": "```suggestion\r\nbecause the latter used a GREASE \"encrypted_client_hello\" extension (as\r\n```\r\n\r\nI don't think i.e., is adding much here.",
              "createdAt": "2020-09-22T21:17:55Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 84,
              "body": "Well, sort of. If they have connection memory they can see that everyone is using different config hashes.\r\n\r\nActually, I wonder if we should salt the hash.",
              "createdAt": "2020-09-22T21:18:30Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 89,
              "body": "I would also not say \"censor\" here.",
              "createdAt": "2020-09-22T21:18:47Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODU2MTk3",
          "commit": {
            "abbreviatedOid": "3772499"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T21:21:33Z",
          "updatedAt": "2020-09-22T21:21:33Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "We can, yeah, but let's do that in a separate PR. (I'm assuming \"without the ECH configuration\" means it doesn't keep state.)",
              "createdAt": "2020-09-22T21:21:33Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODU2NTgz",
          "commit": {
            "abbreviatedOid": "3772499"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T21:22:15Z",
          "updatedAt": "2020-09-22T21:22:16Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "OK",
              "createdAt": "2020-09-22T21:22:15Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 306,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkwOTE2MTY3",
      "title": "Add MTI cipher suite based on x25519, HKDF-SHA256, and AES-128-GCM.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/306",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #251.\r\n\r\ncc @cjpatton @ekr @fredericjacobs",
      "createdAt": "2020-09-22T12:48:49Z",
      "updatedAt": "2020-09-22T21:11:30Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "375b4587f2981c414b5a737d3e98823c6ce1cba9",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/mti",
      "headRefOid": "ad06b45a92d68d49ed327385f7ff9b23266b6262",
      "closedAt": "2020-09-22T21:11:30Z",
      "mergedAt": "2020-09-22T21:11:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "573dc6af51be3c633022bae6ae31f1b2b31646db"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good, presuming the HPKE draft is stable and the section numbers won't change.",
          "createdAt": "2020-09-22T14:13:58Z",
          "updatedAt": "2020-09-22T14:13:58Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 308,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkxOTQ2NjYz",
      "title": "Address minor spec issues",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/308",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Based on my experience implementing this extension (see https://github.com/cloudflare/go/pull/30), I'd like to recommend a few changes to the spec. Most notably:\r\n1. Change the constants so that they're consistent.\r\n1. Specify the client/server behavior in a few failure scenarios.\r\n\r\nThere are also some editorial changes:\r\n1. Rename \"HpkeCipherSuite\" to \"ECHCipherSuite\". (An HPKE cipher suite consists of a KEM, KDF, and AEAD, but here a cipher suite is a KDF and an AEAD.)\r\n1. Rename \"OuterExtensions.hash\" to \"OuterExtensions.inner_digest\".\r\n1. Rename \"ClientECH.encrypted_ch\" to \"ClientECH.payload\".\r\n\r\nPartially addresses https://github.com/tlswg/draft-ietf-tls-esni/issues/285.",
      "createdAt": "2020-09-23T18:00:27Z",
      "updatedAt": "2020-09-24T18:07:54Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "044792db0b118e41089b05c6b1f2f9c641376114",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "nits",
      "headRefOid": "46073397b27d9bbe1f8d356e2406d0f053a30619",
      "closedAt": "2020-09-24T18:07:54Z",
      "mergedAt": "2020-09-24T18:07:54Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4b6f0d7079813fd8f109e38fea77846ece4c666a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MDYxODEz",
          "commit": {
            "abbreviatedOid": "a22e235"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Couple of very small nits!",
          "createdAt": "2020-09-23T21:28:23Z",
          "updatedAt": "2020-09-23T23:19:31Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Good catch. We can remove this entire rule!",
              "createdAt": "2020-09-23T21:28:23Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            },
            {
              "originalPosition": 180,
              "body": "Assuming this is what was meant:\r\n\r\n```suggestion\r\nClientHello but not the first, then the client MUST abort the handshake with an\r\n```",
              "createdAt": "2020-09-23T21:29:10Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            },
            {
              "originalPosition": 229,
              "body": "+1 -- let's drop it!",
              "createdAt": "2020-09-23T23:17:20Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            },
            {
              "originalPosition": 275,
              "body": "Perhaps this can say that servers MUST NOT use this PSK if ECH is rejected?",
              "createdAt": "2020-09-23T23:19:09Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NjMyODM0",
          "commit": {
            "abbreviatedOid": "a22e235"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T14:27:34Z",
          "updatedAt": "2020-09-24T14:27:34Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "I'm revising it to: \"If offered, the server MUST ignore the \"pre_shared_key\" extension sent in the ClientHello.\"",
              "createdAt": "2020-09-24T14:27:34Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NjM1NTM1",
          "commit": {
            "abbreviatedOid": "a22e235"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T14:30:03Z",
          "updatedAt": "2020-09-24T14:30:04Z",
          "comments": [
            {
              "originalPosition": 275,
              "body": "That's ensured by the rule change above, correct? If so, then the server won't send a NewSessionTicket message.",
              "createdAt": "2020-09-24T14:30:04Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1Njc5Njc0",
          "commit": {
            "abbreviatedOid": "30ce5bb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-24T15:13:09Z",
          "updatedAt": "2020-09-24T15:13:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1Njc5OTM1",
          "commit": {
            "abbreviatedOid": "30ce5bb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T15:13:24Z",
          "updatedAt": "2020-09-24T15:13:25Z",
          "comments": [
            {
              "originalPosition": 275,
              "body": "Yep!",
              "createdAt": "2020-09-24T15:13:24Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NzMxNjU2",
          "commit": {
            "abbreviatedOid": "30ce5bb"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T16:08:21Z",
          "updatedAt": "2020-09-24T16:08:21Z",
          "comments": [
            {
              "originalPosition": 275,
              "body": "I dropped the TODO and left the text as-is for now.",
              "createdAt": "2020-09-24T16:08:21Z",
              "updatedAt": "2020-09-24T16:08:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 311,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk0MzQyNTM3",
      "title": "Clarify HRR behavior",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/311",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It is an error for the client to offer ECH after HRR but not before. Likewise, it is an error for the client to offer ECH before HRR but not after. This change ensures the server aborts in this case.",
      "createdAt": "2020-09-28T19:04:03Z",
      "updatedAt": "2020-09-30T22:47:14Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4b6f0d7079813fd8f109e38fea77846ece4c666a",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hrr_behavior",
      "headRefOid": "97f86ab349e5fff45bce6245352ed762e27b5e30",
      "closedAt": "2020-09-30T22:47:14Z",
      "mergedAt": "2020-09-30T22:47:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2ae8aca2a4ffb48d550cbe713e98951ef7a0919a"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Suppose we hit one of the messy HRR cases (https://github.com/tlswg/draft-ietf-tls-esni/issues/233#issuecomment-697949177), where the HRR is valid for the outer ClientHello, but not the inner ClientHello. The client then cannot construct a valid inner ClientHello. How would that square with this text? Are you envisioning the client just generates a random ECH extension, or...?",
          "createdAt": "2020-09-28T20:23:21Z",
          "updatedAt": "2020-09-28T20:23:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ">  How would that square with this text? Are you envisioning the client just generates a random ECH extension, or...?\r\n\r\nI don't think this is a *new* problem. I see the PR as clarifying existing behavior. \r\n\r\nCan you please propose text for the HRR nightmare in #233? :-)",
          "createdAt": "2020-09-28T20:26:58Z",
          "updatedAt": "2020-09-28T20:26:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, you're right. Sorry, I misread this PR as introducing this requirement. In principle, we only need the server to require ECH in CH2 if it decided to accept ECH on CH1. That would allow the client to not send ECH the second time, but maybe we don't want to do that, depending on what we do for #233...\r\n\r\nDo we know what we want to do for #233? Simplest seems to be saying clients MUST align them. (Though how does that work with later HRR-sensitive extensions? Are funny ECH-adding proxies a thing?) Or maybe it's just a SHOULD? Or maybe we come up with some other protocol trick so ECH acceptance is visible at HRR (which would probably reopen the don't-stick-out can of worms yet again). Of these, only the MUST avoids collision with this PR's (existing) client requirement.",
          "createdAt": "2020-09-28T21:00:31Z",
          "updatedAt": "2020-09-28T21:00:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Do we know what we want to do for #233? Simplest seems to be saying clients MUST align them.\r\n\r\nYeah, that's my preference. This logic is already complicated enough. The primary pain point I see is enumerating (and prescribing) what is a HRR-sensitive field. ",
          "createdAt": "2020-09-28T21:08:03Z",
          "updatedAt": "2020-09-28T21:08:03Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Same, with that pain point being the big question in my head. Whether an HRR is valid for a ClientHello isn't an implementation decision, so in theory it's enumerable. But more extensions may come in later.\r\n\r\nAnd in the other direction, even a very strong SHOULD means we need to pick a client behavior for the weird case and allow for it in server behavior.",
          "createdAt": "2020-09-28T21:23:05Z",
          "updatedAt": "2020-09-28T21:23:05Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regardless of where we land on #233, this PR seems appropriate to me.",
          "createdAt": "2020-09-29T18:50:49Z",
          "updatedAt": "2020-09-29T18:50:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3ODI3MjAz",
          "commit": {
            "abbreviatedOid": "1c5800a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-28T19:21:32Z",
          "updatedAt": "2020-09-28T19:23:27Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nIf the client offered ECH in the first ClientHello, then it MUST offer ECH in the\r\n```",
              "createdAt": "2020-09-28T19:21:32Z",
              "updatedAt": "2020-09-28T19:24:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 312,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk0Mzk2MzE4",
      "title": "Match legacy_session_id values.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/312",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #310.",
      "createdAt": "2020-09-28T20:54:11Z",
      "updatedAt": "2020-09-29T00:46:14Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4b6f0d7079813fd8f109e38fea77846ece4c666a",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "compat-mode",
      "headRefOid": "550b5c66f2fa2db9cebf9bcaee935c3fc0d53e9b",
      "closedAt": "2020-09-29T00:46:06Z",
      "mergedAt": "2020-09-29T00:46:06Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b58aa3af62cc7e9eb9b9292e0500fa13aef19413"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2020-09-29T00:46:14Z",
          "updatedAt": "2020-09-29T00:46:14Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3OTg4ODc4",
          "commit": {
            "abbreviatedOid": "550b5c6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-29T00:46:02Z",
          "updatedAt": "2020-09-29T00:46:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 313,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1NzEzMzE2",
      "title": "Replace record-level padding with handshake-level padding",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/313",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #264.",
      "createdAt": "2020-09-30T18:51:06Z",
      "updatedAt": "2021-02-15T21:02:17Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "c1a3d71f20f6fa69da00fa5ee7fa1a11abc291de",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "server_side_padding",
      "headRefOid": "0a8c536aec9bd4844c33339d4f13c24704f4e66d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> How does handshake_padding differ from RFC 7685, less this one sentence: \"The server MUST NOT echo the extension.\" and some clarification about EE/CR/C/?\r\n\r\nThat's basically it. ",
          "createdAt": "2020-10-06T01:49:27Z",
          "updatedAt": "2020-10-06T01:49:27Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And the concern is that clients will enforce that MUST, so that you can't use extension 21 here?",
          "createdAt": "2020-10-06T05:15:15Z",
          "updatedAt": "2020-10-06T05:15:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> And the concern is that clients will enforce that MUST, so that you can't use extension 21 here?\r\n\r\nFrom discussion in #264, it seems overall simpler to just burn an extension code point rather than change existing behavior in code and text.",
          "createdAt": "2020-10-06T12:32:15Z",
          "updatedAt": "2020-10-06T12:32:15Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "BoringSSL clients enforce that MUST. Dunno about others. (In general, we don't allow server extensions we don't expect, and we don't expect server padding extensions.)",
          "createdAt": "2020-10-08T19:03:41Z",
          "updatedAt": "2020-10-08T19:03:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased.",
          "createdAt": "2021-02-15T20:56:49Z",
          "updatedAt": "2021-02-15T20:56:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODI0MzEy",
          "commit": {
            "abbreviatedOid": "c070516"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Only did a cursory pass over it since it's late in the day here.",
          "createdAt": "2020-09-30T21:26:29Z",
          "updatedAt": "2020-09-30T21:47:52Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Nit: I think this should be `{{?RFC7685}}` to mark it as an informational reference rather than a normative reference.",
              "createdAt": "2020-09-30T21:26:29Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 31,
              "body": "Meh. I'd drop that second sentence. The extension is perfectly compatible with TLS 1.2. The server will just ignore it as with any other unknown extension.",
              "createdAt": "2020-09-30T21:27:33Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 21,
              "body": "This should go in IANA Considerations, with a suitable TLS 1.3 column (all the messages).",
              "createdAt": "2020-09-30T21:28:39Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 41,
              "body": "I was going to suggest we go ahead and stick it into the other messages too for the client Finished, but maybe that's better deferred until later. Though we'd have to explicitly say it's not allowed in any other \"request\" messages but we may define what it means later, whereas any \"response\" messages we forbid it from now will be stuck. So that's just a mess.\r\n\r\nIn particular, if we believe in compressed certificates staying as-is, any client certificates story will need client EncryptedExtensions. That said, at least in the client EncryptedExtensions formulation we're pondering for ALPS, the signal would be in the wrong place so it's a mess all around. (https://github.com/vasilvv/tls-alps/pull/5. It's possible we came up with the wrong formulation---I still need to email the about it.)\r\n\r\n@ekr, do you have thoughts?\r\n\r\n(FWIW, a Padding message would avoid all this because it wouldn't need to interact with how each message fits into extension request/response patterns. ;-) We'd need to communicate a single boolean in either direction and then everyone is free to pad to their heart's content anywhere.)",
              "createdAt": "2020-09-30T21:46:38Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 132,
              "body": "This should probably be clear this is going in EncryptedExtensions, not Certificate, as they both carry padding.",
              "createdAt": "2020-09-30T21:47:32Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODUxNTMy",
          "commit": {
            "abbreviatedOid": "c070516"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-30T22:18:43Z",
          "updatedAt": "2020-09-30T22:18:43Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Hmm, the server's reply appears in the EncryptedExtensions message, so the server behavior is ill-defined in TLS<=1.2. I suppose the answer is \"who cares\"?",
              "createdAt": "2020-09-30T22:18:43Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODUyMjY4",
          "commit": {
            "abbreviatedOid": "c070516"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-30T22:20:23Z",
          "updatedAt": "2020-09-30T22:20:24Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": " Good catch, thanks!",
              "createdAt": "2020-09-30T22:20:23Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDg0ODE2",
          "commit": {
            "abbreviatedOid": "4afb7a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T22:49:25Z",
          "updatedAt": "2020-10-02T22:54:34Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Given that the client-side piece is orthogonal to ECH, I think it's probably best to defer that until we figure out the client EE/ALPS story. ",
              "createdAt": "2020-10-02T22:49:25Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 143,
              "body": "Is this the Certificate message after compression, or before? I assume the former, though it would be good to clarify.",
              "createdAt": "2020-10-02T22:51:25Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 134,
              "body": "What about `CertificateVerify`?",
              "createdAt": "2020-10-02T22:51:46Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 128,
              "body": "I'd recommend pulling this out into a separate issue entirely. The client-side padding policy took a while to get consensus, so trying to spell the server-side story here might delay landing of the general mechanism. Can we do that?",
              "createdAt": "2020-10-02T22:53:12Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 126,
              "body": "I'd recommend pulling this out into a separate issue entirely. The client-side padding policy took a while to get consensus, so trying to spell the server-side story here might delay landing of the general mechanism. Can we do that and replace this with an open issue?\r\n\r\n```suggestion\r\n[[OPEN ISSUE: provide server-side padding policy based on Certificate, CertificateVerify(?), ALPN list, and\r\npossibly other (future) parameters.]]\r\n```",
              "createdAt": "2020-10-02T22:54:30Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDkxMjU4",
          "commit": {
            "abbreviatedOid": "fd1b2ad"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:15:24Z",
          "updatedAt": "2020-10-02T23:15:24Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Removed. I also removed \"the server MUST ignore [the] extension if it negotiates TLS 1.2 or below\".",
              "createdAt": "2020-10-02T23:15:24Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDkxODMy",
          "commit": {
            "abbreviatedOid": "fd1b2ad"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:18:02Z",
          "updatedAt": "2020-10-02T23:18:02Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "The former. More precisely, what's intended is the Certificate message as it appears on the wire. I'll clarify this. Can you provide me a reference for certificate compression? I'm unfamiliar with that spec.",
              "createdAt": "2020-10-02T23:18:02Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDkyODIy",
          "commit": {
            "abbreviatedOid": "fd1b2ad"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:23:04Z",
          "updatedAt": "2020-10-02T23:23:05Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "Sure -- [here you go](https://datatracker.ietf.org/doc/draft-ietf-tls-certificate-compression/)! The reference {{?I-D.ietf-tls-certificate-compression}} should work.",
              "createdAt": "2020-10-02T23:23:05Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDkzMTIx",
          "commit": {
            "abbreviatedOid": "fd1b2ad"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:24:22Z",
          "updatedAt": "2020-10-02T23:24:23Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I'm not sure we should RECOMMEND that. On the one hand, the length of CertificateVerify would leak is the (parameters of the) signature algorithm, On the other hand, an RSA signature is much longer than ECDSA-P256. Hence, the downside is lots of extra padding to protect clients/servers that need to support RSA.",
              "createdAt": "2020-10-02T23:24:23Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDkzNDEw",
          "commit": {
            "abbreviatedOid": "fd1b2ad"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:25:39Z",
          "updatedAt": "2020-10-02T23:25:40Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "In that case, I think we should postpone this change until affter -08.",
              "createdAt": "2020-10-02T23:25:40Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDkzOTY3",
          "commit": {
            "abbreviatedOid": "fd1b2ad"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:28:08Z",
          "updatedAt": "2020-10-02T23:28:08Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "I think it's fine to RECOMMEND something that is obsoleted by a better idea later on. But as I mentioned above, if this change is likely to be controversial, then we should take it to the list. In addition, I think we should consider publishing -08 beforehand. There's already substantial changes.",
              "createdAt": "2020-10-02T23:28:08Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDk1NjQw",
          "commit": {
            "abbreviatedOid": "45fa615"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:36:27Z",
          "updatedAt": "2020-10-02T23:36:28Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "Yeah, that seems reasonable. Do you want to flag the issue (and PR) as such?",
              "createdAt": "2020-10-02T23:36:27Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDk1ODAy",
          "commit": {
            "abbreviatedOid": "45fa615"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:37:21Z",
          "updatedAt": "2020-10-02T23:37:21Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Eh, true, but I don't think the cost is that great.",
              "createdAt": "2020-10-02T23:37:21Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDk4MTEx",
          "commit": {
            "abbreviatedOid": "45fa615"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:50:10Z",
          "updatedAt": "2020-10-02T23:50:10Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "This PR already has an associated issue (https://github.com/tlswg/draft-ietf-tls-esni/issues/264). Why don't I just add a comment there?",
              "createdAt": "2020-10-02T23:50:10Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMDk1MzM3",
          "commit": {
            "abbreviatedOid": "45fa615"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-05T14:09:46Z",
          "updatedAt": "2020-10-05T14:09:46Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Yeah, I expect this to be controversial. I'd take it to the list.",
              "createdAt": "2020-10-05T14:09:46Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMDk1NjAy",
          "commit": {
            "abbreviatedOid": "45fa615"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-05T14:10:03Z",
          "updatedAt": "2020-10-05T14:10:03Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "That's what I was thinking, yeah. ",
              "createdAt": "2020-10-05T14:10:03Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNTI5OTM2",
          "commit": {
            "abbreviatedOid": "45fa615"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "How does handshake_padding differ from RFC 7685, less this one sentence: \"The server MUST NOT echo the extension.\" and some clarification about EE/CR/C/?",
          "createdAt": "2020-10-06T01:44:54Z",
          "updatedAt": "2020-10-06T01:46:18Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "```suggestion\r\n(ECHConfig.maximum_name_length) when computing the padding length as follows:\r\n```",
              "createdAt": "2020-10-06T01:44:54Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTc0NTI3",
          "commit": {
            "abbreviatedOid": "8ca7de2"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T19:47:38Z",
          "updatedAt": "2020-12-08T19:47:39Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Should this be ClientHelIoInner?",
              "createdAt": "2020-12-08T19:47:38Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTc1OTQ1",
          "commit": {
            "abbreviatedOid": "8ca7de2"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T19:49:38Z",
          "updatedAt": "2020-12-08T19:49:38Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "s/zeros bytes/zero bytes/?",
              "createdAt": "2020-12-08T19:49:38Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTc3MDY1",
          "commit": {
            "abbreviatedOid": "8ca7de2"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T19:51:09Z",
          "updatedAt": "2020-12-08T19:51:09Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "When *and only when* solicited by the client? If so, why?",
              "createdAt": "2020-12-08T19:51:09Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTc3NTU0",
          "commit": {
            "abbreviatedOid": "8ca7de2"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T19:51:48Z",
          "updatedAt": "2020-12-08T19:51:49Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Why not SHOULD?",
              "createdAt": "2020-12-08T19:51:48Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzQ5NjI0",
          "commit": {
            "abbreviatedOid": "6586841"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T20:59:31Z",
          "updatedAt": "2021-02-15T20:59:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yes, due to the rule in TLS !.3 that the server not send unsolicited extensions (with a few, well-specified exceptions). There'd be no need to allow this behavior anyway: if the client failing to pad leads to a confidentiality breach, it's unlikely that the server can mitigate this much by padding unilaterally.",
              "createdAt": "2021-02-15T20:59:31Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzUwMjAw",
          "commit": {
            "abbreviatedOid": "6586841"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T21:01:04Z",
          "updatedAt": "2021-02-15T21:01:04Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "IIRC the intent is for the the \"handshake_padding\" to be general purpose, i.e., not specific to ECH.",
              "createdAt": "2021-02-15T21:01:04Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzUwNDg3",
          "commit": {
            "abbreviatedOid": "6586841"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T21:01:55Z",
          "updatedAt": "2021-02-15T21:01:55Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I think MAY is more appropriate given the intended generality of the extension.",
              "createdAt": "2021-02-15T21:01:55Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 314,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODMxMTEx",
      "title": "Fix a line break (and make CI happy)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/314",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-09-30T22:50:19Z",
      "updatedAt": "2020-09-30T22:51:08Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2ae8aca2a4ffb48d550cbe713e98951ef7a0919a",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "nit/ci",
      "headRefOid": "6e0491f66b1f43ac1e0aaafec8441f1cb7bb40b9",
      "closedAt": "2020-09-30T22:51:08Z",
      "mergedAt": "2020-09-30T22:51:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0403ebf7200b700d9c455437947328f1bed7915e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 315,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODM2MTQx",
      "title": "Bump ech_hrr_key length to 32 bytes to align with latest HPKE changes.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/315",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/159, and the related [CFRG thread](https://mailarchive.ietf.org/arch/msg/cfrg/mxBzZq85ijSMNMUwyI3gA3B0U4U/).\r\n\r\ncc @cjpatton ",
      "createdAt": "2020-09-30T23:06:28Z",
      "updatedAt": "2020-10-08T18:04:25Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e9c1bbd1acd13f1683f34fe0a51752da2c55cb6c",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/ech-hrr-key",
      "headRefOid": "dd2e5aad2eb6cec18afc20f3b856bc42c54bb894",
      "closedAt": "2020-10-08T18:04:25Z",
      "mergedAt": "2020-10-08T18:04:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "28c02428ce2e46dad0106a93eeb98655608bf29f"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "~Looks good to me.~ There are two places you need to change the length. This PR just changes it in one.",
          "createdAt": "2020-09-30T23:44:25Z",
          "updatedAt": "2020-09-30T23:45:53Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good!",
          "createdAt": "2020-10-01T00:12:44Z",
          "updatedAt": "2020-10-01T00:12:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODkwNjQ2",
          "commit": {
            "abbreviatedOid": "05798ce"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-30T23:46:43Z",
          "updatedAt": "2020-09-30T23:46:48Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "You also need to change this above.\r\n\r\ns/context.Export(\"tls13 ech hrr key\", 16)/context.Export(\"tls13 ech hrr key\", 32)",
              "createdAt": "2020-09-30T23:46:43Z",
              "updatedAt": "2020-10-01T00:00:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTEzOTgx",
          "commit": {
            "abbreviatedOid": "dd2e5aa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:01:00Z",
          "updatedAt": "2020-10-01T00:01:01Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Grr, I thought caught them all. Thanks!",
              "createdAt": "2020-10-01T00:01:01Z",
              "updatedAt": "2020-10-01T00:01:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 316,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODQzMzg5",
      "title": "Require HRR-sensitive parameters match in ClientHello(Outer|Inner).",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/316",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #233.\r\n\r\nThis is limited to parameters applicable to TLS 1.3 and beyond. For example,\r\nTLS 1.2 ciphersuites may appear in ClientHelloOuter, so long as all TLS 1.3\r\nciphersuites in ClientHelloOuter match that in ClientHelloInner.\r\n\r\ncc @davidben, @cjpatton",
      "createdAt": "2020-09-30T23:25:50Z",
      "updatedAt": "2020-11-19T00:10:06Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9f485e939b99814f9a73c1e94ec5e44f0a8d4806",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/require-hrr-match",
      "headRefOid": "d6408d375c3073b9f7d8b9a3b46ea91fb13bc9ec",
      "closedAt": "2020-11-19T00:10:06Z",
      "mergedAt": "2020-11-19T00:10:06Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f5e18954a19565611c86a817e4414b0d282062b5"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton, @davidben, @martinthomson: this is ready for another look.",
          "createdAt": "2020-10-22T00:53:18Z",
          "updatedAt": "2020-10-22T00:53:18Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not totally sure this is the right outcome. I can imagine situations where you might want CHOuter and CHInner to be different. I wonder if we can use a similar PRF() trick for HRR to tell which one it was, though I appreciate that this is in conflict with folding the secret into random.\r\n\r\n",
          "createdAt": "2020-11-03T21:14:41Z",
          "updatedAt": "2020-11-03T21:14:41Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there're three issues we'd want to sort out, to allow a mismatch.\r\n1. Without an ECH acceptance signal in HRR, the error gets deferred and that seems like a huge mess. I think this is the issue you have in mind with the PRF trick?\r\n2. If the HRR matches CHInner and is inconsistent with CHOuter, we still need to construct *some* CHOuter. The current draft says you don't follow the RFC8446 rules, but that can't be right because we need the cookie to appear in CHOuter even if CHOuter can't be constructed.\r\n3. Even if a mismatch is allowed, I think we should have text encouraging a match, so implementers know to avoid a complexity cliff if they don't need it.\r\n\r\n(It's also possible this would interact with #333, if we want some goofy HRRInner vs HRROuter scheme...)",
          "createdAt": "2020-11-03T21:22:10Z",
          "updatedAt": "2020-11-03T21:22:36Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I am trying to fix #1 with the PRF trick.\r\n\r\nAnd yes, there is some possibility of a goofy HRRInner/HRROuter\r\n\r\n",
          "createdAt": "2020-11-03T22:30:23Z",
          "updatedAt": "2020-11-03T22:30:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTM2MDgw",
          "commit": {
            "abbreviatedOid": "7bf7979"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-01T00:15:09Z",
          "updatedAt": "2020-10-01T00:15:18Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "An editorial suggestion: I would have the bullet simply read \"It MUST ensure that all HelloRetryRequest-sensitive parameters applicable to TLS 1.3 and higher versions in ClientHelloInner match that in ClientHelloOuter. See {{hrr}} for the list of these parameters.\" and I would enumerate the HRR-sensitive parameters in {{hrr}}. Moreover, this change likely impacts the text in {{hrr}}.",
              "createdAt": "2020-10-01T00:15:09Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTQzMzA4",
          "commit": {
            "abbreviatedOid": "9e244c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:55:46Z",
          "updatedAt": "2020-10-01T16:55:47Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Should be done!",
              "createdAt": "2020-10-01T16:55:46Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTUyMDIy",
          "commit": {
            "abbreviatedOid": "9e244c8"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T17:07:13Z",
          "updatedAt": "2020-10-01T17:07:13Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "s/and/or",
              "createdAt": "2020-10-01T17:07:13Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTQ1NzU5",
          "commit": {
            "abbreviatedOid": "9e244c8"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:58:51Z",
          "updatedAt": "2020-10-01T17:10:18Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "supported_versions itself is also HRR-sensitive, but the matching rule is a little weird. The HRR specifies the TLS version (suppose 1.4, 1.5, and 1.6 exist and all have HRR), so if the client preferences are different between the two, things will break.",
              "createdAt": "2020-10-01T16:58:51Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 17,
              "body": "Suppose a server decrypts ClientHelloOuter and sees that its parameters differ from ClientHelloInner. Should it reject the connection or continue because we don't want the server to bother looking at the other ClientHello very much?\r\n\r\nI ask because it occurred to me we might want to extend this in the future where the client doesn't care about the ClientHelloOuter and retry case. This is disastrous from a recoverability perspective, but if it's a predictive connection or has some other fallback available already, maybe that's fine. In that case, the ClientHelloOuter only needs to be the bare minimum to pass syntactically.\r\n\r\nI think we can freely specify that later, so it doesn't really matter whether this is a SHOULD or MUST on the client, but the server behavior would constrain this.",
              "createdAt": "2020-10-01T17:10:10Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzUwNjM2",
          "commit": {
            "abbreviatedOid": "9e244c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T22:07:07Z",
          "updatedAt": "2020-10-01T22:07:07Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Yeah, I think leaving this as a MUST for now and possibly relaxing later is fine, provided we don't constrain ourselves by forcing a server-side check here. So, let's leave this as is?",
              "createdAt": "2020-10-01T22:07:07Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzUxNzk5",
          "commit": {
            "abbreviatedOid": "07589cf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T22:09:38Z",
          "updatedAt": "2020-10-01T22:09:38Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I added \"supported_versions\" to the list!",
              "createdAt": "2020-10-01T22:09:38Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDQzMzM5",
          "commit": {
            "abbreviatedOid": "07589cf"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T20:57:43Z",
          "updatedAt": "2020-10-02T20:57:43Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Sorry, I should have been clearer. So the reason supported_versions is a huge headache is that it *doesn't* match between the inner and outer. The inner ClientHello is forbidden from offering TLS 1.2, while the outer one may still offer it. I think the rule is something like they need to match, after you drop 1.0-1.2 from the outer list, which is weird.",
              "createdAt": "2020-10-02T20:57:43Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDQ2MDM5",
          "commit": {
            "abbreviatedOid": "07589cf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T21:03:00Z",
          "updatedAt": "2020-10-02T21:03:01Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Yeah, I figured this was covered by saying these are \"parameters applicable to TLS 1.3 or higher\". Do you not think that's enough? If not, would you mind proposing text to clarify?",
              "createdAt": "2020-10-02T21:03:00Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDYwNTg1",
          "commit": {
            "abbreviatedOid": "07589cf"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T21:34:57Z",
          "updatedAt": "2020-10-02T21:34:57Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Ah I see. Yeah, I didn't interpret that to apply to the individual details like that. Do you think this would be clearer?\r\n\r\n> 1. TLS 1.3 {{!RFC8446}} ciphersuites in the ClientHello.cipher_suites list\r\n> 1. The \"key_share\" and \"supported_groups\" extensions\r\n{{RFC8446}}. (These extensions may be copied from ClientHelloOuter into\r\nClientHelloInner as described in {{send-ech}}.)\r\n> 1. Versions in the \"supported_versions\" extension, excluding TLS 1.2 and earlier. Note the ClientHelloOuter MAY include these older versions, while the ClientHelloInner MUST omit them.",
              "createdAt": "2020-10-02T21:34:57Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDc5NDky",
          "commit": {
            "abbreviatedOid": "07589cf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T22:29:40Z",
          "updatedAt": "2020-10-02T22:29:40Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Yep, that is more clear! ",
              "createdAt": "2020-10-02T22:29:40Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDk0ODYw",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:32:22Z",
          "updatedAt": "2020-10-02T23:32:22Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "\"non-ECH PSK\": does this term still exist? I know we talked about this already but I forgot where we landed :)",
              "createdAt": "2020-10-02T23:32:22Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDk2MzE2",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:40:01Z",
          "updatedAt": "2020-10-02T23:40:01Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "It's addressed in another PR.",
              "createdAt": "2020-10-02T23:40:01Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNTY0Mzcz",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "More evidence that we don't have a good shared understanding of what HRR is for, sadly.\r\n\r\nThe primary thing of concern here is the ability for HRR to cause a client to change their expressed preferences or how those preferences are expressed (specifically for key shares).  This pull request is phrased differently in terms of what might cause a server to send HRR, which isn't that.  The HRR is the only thing that a client should allow to change its preferences, but focus on HRR seems wrong.\r\n\r\nTo avoid problems we have two options: the preference cannot change (which is the ideal choice if we can manage it), or the preference can change, but any change is authenticated.  To that end, this is a reasonable design choice, I just would prefer we concentrate on the critical property.\r\n\r\nAlso, I'm fairly sure that this means that 8446 needs to be updated by this.",
          "createdAt": "2020-10-06T03:48:39Z",
          "updatedAt": "2020-10-06T04:07:27Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Does HRR-sensitive mean \"all extensions or parameters that might change in response to receiving HRR\"?  If it does, then maybe say that.",
              "createdAt": "2020-10-06T03:48:40Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 28,
              "body": "Isn't the primary consideration whether they might change between subsequent ClientHellos?  That these might cause a server to send HelloRetryRequest is merely consequential.",
              "createdAt": "2020-10-06T03:51:05Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 17,
              "body": "This connects parameters that might change in response to HRR to whether they appear inside or outside.  This assumes that they appear in both places (and that they are the same).\r\n\r\nThere's an implicit constraint here that probably needs to be explicit: HelloRetryRequest can only be sent to affect a change in a ClientHello that affects key negotiation.  This is recognizing a new constraint on the design that was essentially always true, but not mandatory.  In principle, prior to this, HRR could affect a new extension that didn't affect key negotiation.\r\n\r\nConveniently, we already have a proxy for that.  Extensions that are CH/SH (as opposed to CH/EE) are those that HRR can change.  In theory there could be some that appear in CH alone, but that is unlikely to be true for a new extension given our systemic rejection of trial decryption.\r\n\r\nThis should probably be reflected somewhere, probably by updating RFC 8446.",
              "createdAt": "2020-10-06T04:01:35Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyOTY2MTcx",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-06T13:33:32Z",
          "updatedAt": "2020-10-06T13:33:32Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "We could rewrite this as, \"Future extensions that might change across first and second ClientHello messages in response to a HelloRetryRequest MUST match,\" as you suggest.",
              "createdAt": "2020-10-06T13:33:32Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyOTY2NDgy",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-06T13:33:48Z",
          "updatedAt": "2020-10-06T13:33:48Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "That seems like an improvement, yeah. I'll take it.",
              "createdAt": "2020-10-06T13:33:48Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyOTcyNTI2",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-06T13:39:25Z",
          "updatedAt": "2020-10-06T13:39:26Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I agree with the above, but it's not clear to me what specifically you're suggesting. The *intent* of this change is to encompass any CH/SH extension that might change due to HRR, and we refer to those as \"HRR-sensitive\" parameters. \r\n\r\nCan you please clarify what specifically what you're looking for, ideally with suggested text?\r\n\r\n> This should probably be reflected somewhere, probably by updating RFC 8446.\r\n\r\nI don't think this needs to update RFC8446. The HRR language in that document is somewhat unclear as-is, so it probably makes more sense to tackle this in rfc8446-bis.",
              "createdAt": "2020-10-06T13:39:25Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NzczOTU4",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T19:47:36Z",
          "updatedAt": "2020-10-13T19:55:51Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Is it parameters that would change in response to HRR, or parameters that would change which HRRs you accept? The latter captures the issue a bit more directly, since the issue is a goofy mechanical one of needing to process an HRR for two ClientHellos concurrently, and the error cases being a mess. (If the HRR matches inner but not outer, how do you construct a new outer ClientHello?)\r\n\r\nAlso a strict reading of \"parameters that might change in response to receiving HRR\" would include PSKs, which isn't what we want. RFC8446 has this odd corner case:\r\nhttps://tools.ietf.org/html/rfc8446#section-4.1.2\r\n\r\n>  -  Updating the \"pre_shared_key\" extension if present by recomputing\r\n>      the \"obfuscated_ticket_age\" and binder values and (optionally)\r\n>      removing any PSKs which are incompatible with the server's\r\n>      indicated cipher suite.\r\n\r\n(This was to save clients from recomputing binders for a hash they aren't using. Something something crypto agility is a headache.)\r\n\r\nA strict reading would also exclude cipher suite preferences, since the client doesn't change them on HRR, even though the server has already committed to one.",
              "createdAt": "2020-10-13T19:47:37Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 28,
              "body": "Per comment above, perhaps \"Future extensions that influence the set of HelloRetryRequest values that the clients would accept\"? Though that is definitely kinda weird to say. :-/",
              "createdAt": "2020-10-13T19:55:43Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNTkzOTYz",
          "commit": {
            "abbreviatedOid": "ef01697"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think this PR is close to what we want. Perhaps we could be more upfront about the fact that future changes to HRR need to be reconciled with ECH.",
          "createdAt": "2020-10-16T15:48:30Z",
          "updatedAt": "2020-10-16T16:28:48Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n   ClientHelloOuter. See {{client-hrr}} for the list of these parameters.\r\n```",
              "createdAt": "2020-10-16T15:48:30Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 16,
              "body": "Grammar suggestion: \"parameters of the ClientHelloInner that are applicable to TLS 1.3 or higher match those of the ClientHelloOuter.\"",
              "createdAt": "2020-10-16T15:51:50Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 17,
              "body": "The server doesn't enforce this MUST, as far as I can tell. For context, note that #339 merely requires that the server checks ECH usage doesn't change across HRR.",
              "createdAt": "2020-10-16T16:10:35Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 21,
              "body": "Does this text allow implementations to use different DH key shares? E.g., `g^x` in ClientHelloInner and `g^y` in ClientHelloOuter, where `g` is the generator of the group?",
              "createdAt": "2020-10-16T16:22:21Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 28,
              "body": "Maybe we should be more upfront about this? In particular, we could mention this prior to listing the known HRR-senstive parameters. That would prompt the reader to realize that ECH interacts with future changes to HRR.",
              "createdAt": "2020-10-16T16:27:00Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 17,
              "body": "I think @martinthomson's point is that this PR is overly prescriptive about the semantics of HRR? If so, I disagree. It aims to address HRR-sensitive parameters that are known today, but there's line about how to address future changes to the HRR code path. Maybe we should be more upfront about this.",
              "createdAt": "2020-10-16T16:27:04Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0Mjg3MzAx",
          "commit": {
            "abbreviatedOid": "99e2965"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T00:50:44Z",
          "updatedAt": "2020-10-22T00:50:44Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "No, I think that's the point. ",
              "createdAt": "2020-10-22T00:50:44Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0Mjg3ODEx",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T00:52:13Z",
          "updatedAt": "2020-10-22T00:52:13Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I rewrote per my suggestion above, based on MT's comment. Please have a look, @martinthomson!",
              "createdAt": "2020-10-22T00:52:13Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0Mjg4MDcy",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T00:52:57Z",
          "updatedAt": "2020-10-22T00:52:58Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I applied the suggestion above!",
              "createdAt": "2020-10-22T00:52:58Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MzU5MTI2",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Much better \ud83d\udc4d \r\nI have some more suggestions, but hopefully these are more concrete here.",
          "createdAt": "2020-10-22T04:57:17Z",
          "updatedAt": "2020-10-22T05:01:08Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nextensions or parameters that might change in response to receiving a\r\nHelloRetryRequest have the same values in ClientHelloInner and \r\nClientHelloOuter. These parameters include:\r\n```\r\n\r\nI'm using \"same values\" rather than \"match\", which I think works if you allow the value to be filled in by following a reference.\r\n\r\nDo you really need to call out anything from earlier versions?  None of those change.  By definition you are implementing TLS 1.3 already, so mentioning earlier versions seems unnecessary.\r\n\r\nI wonder if it is worth adding:\r\n\r\n> That is, if a HelloRetryRequest causes a value to be changed, the same change is applied to both ClientHelloInner and ClientHelloOuter.",
              "createdAt": "2020-10-22T04:57:17Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 19,
              "body": "Do we really need to say this?  My understanding is that you don't change the ciphersuite list in response to HRR, so calling this out might be confusing.",
              "createdAt": "2020-10-22T04:58:03Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NzMwMjUy",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T13:33:23Z",
          "updatedAt": "2020-10-22T13:33:23Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I think this is where \"parameters that change in response to HRR\" isn't quite the right criteria.\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/316#discussion_r504213701\r\n\r\nIf the client has different inner vs. outer cipher suites, then the set of HRRs that it will accept between the two is different. That means we need to describe what happens if the HRR is valid for the inner CH but not the outer and vice versa. TLS doesn't say how you construct a CH in response to an invalid HRR. (It's also just generally annoying to implement on the client because you need to defer reacting to an error in one of two parallel handshakes.)",
              "createdAt": "2020-10-22T13:33:23Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODA4NzEz",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T14:45:11Z",
          "updatedAt": "2020-10-22T14:45:11Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I don't get this.  I can see why you might filter out cipher suites from TLS 1.2 and earlier, but to say that the set of ciphersuites is different is strange.\r\n\r\nAlso, you aren't allowed to change the set of ciphersuites you offer in response to HRR.",
              "createdAt": "2020-10-22T14:45:11Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODMxOTA1",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T15:06:11Z",
          "updatedAt": "2020-10-22T15:06:12Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I think maybe we're not on the same page as to the problem being solved. The one I have in mind is this:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/issues/233#issuecomment-697949177\r\n\r\nHelloRetryRequest contains the cipher suite. If, as a client, you have different cipher suite preferences in ClientHelloOuter and ClientHelloInner, the set of valid HRR messages varies. The same is true if you have different supported_groups or key_shares preferences. That means it is possible to receive a HelloRetryRequest that is valid for ClientHelloInner, but not ClientHelloOuter, and vice versa. The client needs to do something coherent in that case. Specifically...\r\n\r\n* It needs to note that one of the parallel handshake flows has an error, but not act on it yet.\r\n* When it sees ServerHello, if the server picked the ClientHello with a deferred error, it needs to retroactively act on that error.\r\n* If HRR was good for inner but bad for outer, the client needs to send a second ClientHello with an updated ClientHelloInner (easy), but contained in *some* ClientHelloOuter. What ClientHelloOuter does it construct? This gets especially thorny given HRR cookies, though note #333.\r\n* If the HRR was good for the outer but bad for the inner, the client I guess can stop offering ECH in the second CH, but that contradicts [this text](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-7.1.1-2.1). Or the client can, as above, construct some dummy ClientHelloInner. (What does it construct?)\r\n\r\nOr the client can avoid all this disaster by matching the inner and outer preferences wherever it would affect HRR *acceptance*. Having an invisible complexity cliff in the spec is bad, so we should either:\r\n* Write down how to avoid this problem as a MUST and leave it at that -or-\r\n* Write down how to avoid this problem as a SHOULD and *also* write down what you do if you want to do the hard thing anyway.\r\n\r\n(We could partially simplify this by working an ECH acceptance signal into HRR somehow, but it wouldn't solve the dummy ClientHello problem, just the deferred error problem.)",
              "createdAt": "2020-10-22T15:06:11Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTIwMDA0",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T21:07:55Z",
          "updatedAt": "2020-10-22T21:07:56Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "My point is far narrower.\r\n\r\nThe rules for cipher suites are restrictive: CHOuter can include many cipher suites.  CHInner can only include the subset of those cipher suites that are supported in TLS 1.3 (or higher).  Furthermore, the rules for HRR don't permit changing the set of offered cipher suites in the second ClientHello (either!).",
              "createdAt": "2020-10-22T21:07:56Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNzk1MzY0",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T16:33:04Z",
          "updatedAt": "2020-11-02T16:33:04Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Hrm, I get the feeling we're still not talking about the same thing, but maybe I'm woefully confused. :-)\r\n\r\nI agree we want CHInner to only include the TLS 1.3+ cipher suites in CHOuter. I claim, to avoid the half-error HRR problem, we also want it to include all of those cipher suites.\r\n\r\nIn the draft as-is, I don't think either rule is in there. The spec allows for your CHInner and CHOuter cipher suites to be totally unrelated, thus the half-error HRR problem. My understanding was this PR was meant to fix this.\r\n\r\nI agree that cipher suites don't change in response to HRR and so including cipher suites in such a list is incorrect. But I think the problem isn't in the list itself (which is correct to avoid the half-HRR problem), but in the description of the list. I.e. \"extensions or parameters [...] that might change in response to receiving HelloRetryRequest\" isn't actually the criteria we want for this PR.",
              "createdAt": "2020-11-02T16:33:04Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODgwNjg4",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Just one minor nit, plus an endorsement of a couple of @martinthomson's suggestions. It seems like this PR will leave an OPEN ISSUE, which we need to note.",
          "createdAt": "2020-11-17T22:54:13Z",
          "updatedAt": "2020-11-17T23:00:48Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nin response to a HelloRetryRequest MUST have the same value.\r\n```",
              "createdAt": "2020-11-17T22:54:14Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 17,
              "body": "> I'm using \"same values\" rather than \"match\", which I think works if you allow the value to be filled in by following a reference.\r\n\r\nI like this idea.\r\n\r\n> I wonder if it is worth adding:\r\n> \r\n> > That is, if a HelloRetryRequest causes a value to be changed, the same change is applied to both ClientHelloInner and ClientHelloOuter.\r\n\r\nI also like this idea.\r\n\r\n",
              "createdAt": "2020-11-17T22:55:51Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTEwMzU0",
          "commit": {
            "abbreviatedOid": "d6408d3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-18T05:16:34Z",
          "updatedAt": "2020-11-18T05:16:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 317,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODYzNTg3",
      "title": "Simplify session resumption logic.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/317",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #285.\r\n\r\nWe need to decide if we want to allow a GREASE+ticket distinguisher, and if not, how we GREASE the \"pre_shared_key\" extension in a meaningful way. The latter seems like somewhat of a cat and mouse game, so I'm not really enthusiastic about trying to specify that behavior, but I'd like to hear what others think.\r\n\r\ncc @davidben, @cjpatton, @martinthomson ",
      "createdAt": "2020-09-30T23:55:46Z",
      "updatedAt": "2020-10-07T23:00:44Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "856b7fe98915102ceb7796dfec41cb1b627b8b9e",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/simpler-resumption",
      "headRefOid": "df683d4c0730ebab2e9a757664cd5e6ce9de274b",
      "closedAt": "2020-10-07T23:00:44Z",
      "mergedAt": "2020-10-07T23:00:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e3a6b583b47c0907774bdb04d45df881270df17e"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks good. I still feel that there are a lot of ways that ECH usage might stick out, even to passive observers. \"pre_shared_key\" is one of many. If anything I would change the \"OPEN ISSUE\" to encompass top-to-bottom \"don't stick out\" review.",
          "createdAt": "2020-10-07T17:07:12Z",
          "updatedAt": "2020-10-07T17:07:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTI3MTM0",
          "commit": {
            "abbreviatedOid": "700bfc6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:09:18Z",
          "updatedAt": "2020-10-01T00:09:18Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I suggest leaving this OPEN ISSUE open and address it post -08. This is one way that real ECH sticks out from covertext, but there are likely others. What is needed is a big picture \"don't stick out\" review of ECH.",
              "createdAt": "2020-10-01T00:09:18Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTI4OTQ3",
          "commit": {
            "abbreviatedOid": "700bfc6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:10:28Z",
          "updatedAt": "2020-10-01T00:10:28Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "nit: \"outer ClientHello\" -> \"the ClientHelloOuter\". Here and below.",
              "createdAt": "2020-10-01T00:10:28Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTI5OTYx",
          "commit": {
            "abbreviatedOid": "700bfc6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:11:07Z",
          "updatedAt": "2020-10-01T00:11:07Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Is \"ECH PSK\" an obsolete term?",
              "createdAt": "2020-10-01T00:11:07Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTM3OTUx",
          "commit": {
            "abbreviatedOid": "42ba0a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:21:54Z",
          "updatedAt": "2020-10-01T00:21:55Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "We use it when noting tickets/PSKs associated with an ECH accepted connection.",
              "createdAt": "2020-10-01T00:21:54Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTM3OTkw",
          "commit": {
            "abbreviatedOid": "42ba0a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:22:03Z",
          "updatedAt": "2020-10-01T00:22:04Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "I made this change more broadly.",
              "createdAt": "2020-10-01T00:22:04Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTM4MDk3",
          "commit": {
            "abbreviatedOid": "42ba0a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:22:28Z",
          "updatedAt": "2020-10-01T00:22:29Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I'm fine with that, I think, though we may want to reconsider it before the GREASE experiments commence.",
              "createdAt": "2020-10-01T00:22:28Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNDk4ODcy",
          "commit": {
            "abbreviatedOid": "42ba0a7"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:01:04Z",
          "updatedAt": "2020-10-01T16:01:04Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "(Noticed this while looking at the text for something else: the list below also has a reference to \"non-ECK PSK\" that should be dropped here.)",
              "createdAt": "2020-10-01T16:01:04Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTAxODAw",
          "commit": {
            "abbreviatedOid": "d8efb6e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:04:31Z",
          "updatedAt": "2020-10-01T16:04:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I explicitly kept that, but I don't really feel strongly about keeping it. So I just removed it. ",
              "createdAt": "2020-10-01T16:04:31Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTMwNDY1",
          "commit": {
            "abbreviatedOid": "d8efb6e"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:39:04Z",
          "updatedAt": "2020-10-01T16:39:04Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Hehe, I mean this PR removes the definition of \"ECH PSK\" and \"non-ECH PSK\" so we probably shouldn't reference them. :-) I was hoping we'd no longer have to associate this extra boolean with each session.",
              "createdAt": "2020-10-01T16:39:04Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Mjc5MjYz",
          "commit": {
            "abbreviatedOid": "df683d4"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I think this looks good modulo the PSK oracle section seeming kinda odd to begin with.",
          "createdAt": "2020-10-07T21:25:46Z",
          "updatedAt": "2020-10-07T21:29:25Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "I think this section might be anchoring too much on PSKs. I think it's actually a general attack mitigated by a more general fix.\r\n\r\nBack when it was ESNI, the final ClientHello was malleable. An attacker could change some parameters while carrying over the secret server name. If the server interprets the influenced parameters differently based on the secret server name, the attacker can use that as an oracle. The most natural vector is the PSK, because resumptions may be SNI-partitioned. But if you have, say, different ALPN preferences by hostname, that would also equally be a vector.\r\n\r\nWe've fixed this by:\r\n1. Encrypting the entire ClientHello gives us a convenient way to bundle all parameters together, so it's natural that servers don't look at the outer CH. (The section talks about a server that mixes the two CHs up, which is totally bizarre.)\r\n2. Everything that goes into the final ClientHello is directly or indirectly authenticated by the AEAD. (OuterExtensions.inner_digest or #323.)\r\n\r\nI'll take a stab at a replacement for this section...",
              "createdAt": "2020-10-07T21:25:46Z",
              "updatedAt": "2020-10-07T22:24:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Mjk5MTUx",
          "commit": {
            "abbreviatedOid": "df683d4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T22:02:30Z",
          "updatedAt": "2020-10-07T22:02:31Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "> (The section talks about a server that mixes the two CHs up, which is totally bizarre.)\r\n\r\nIMO, this is why we kept the section. I agree that it's bizarre, but not much of a stretch from the original attack vector. I'd like to keep some mention of this mix-and-match problem for historical reasons, though I'm definitely happy to look at simpler text!",
              "createdAt": "2020-10-07T22:02:30Z",
              "updatedAt": "2020-10-07T22:02:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzAxNTE2",
          "commit": {
            "abbreviatedOid": "df683d4"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T22:07:18Z",
          "updatedAt": "2020-10-07T22:07:19Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "Dunno if it's simpler, but it's hopefully more general. I think the description of the mitigation should touch on OuterExtensions.inner_digest's role in authenticating the inner ClientHello, which would have answered #263. That is, if we allowed you to compress pre_shared_keys for whatever reason, this attack would still be impossible because of that hash.\r\n\r\n(Not that you'd want to compress pre_shared_key since a compressed is public and leaking the actual ticket gives you a different kind of oracle. That falls under \"things that depend on secret things are also secret\".)",
              "createdAt": "2020-10-07T22:07:19Z",
              "updatedAt": "2020-10-07T22:07:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzA0NjUz",
          "commit": {
            "abbreviatedOid": "df683d4"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T22:13:47Z",
          "updatedAt": "2020-10-07T22:13:47Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "https://github.com/tlswg/draft-ietf-tls-esni/pull/327",
              "createdAt": "2020-10-07T22:13:47Z",
              "updatedAt": "2020-10-07T22:13:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 318,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODY3ODM4",
      "title": "Clarify our lack of concern around 2^{-64} acceptance signal collision probabilities",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/318",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #307.\r\n\r\ncc @tfpauly, @martinthomson ",
      "createdAt": "2020-10-01T00:10:48Z",
      "updatedAt": "2020-10-07T14:35:46Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e9c1bbd1acd13f1683f34fe0a51752da2c55cb6c",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/negligible",
      "headRefOid": "278603817d14ff6391058ae76e88063d366834cd",
      "closedAt": "2020-10-07T14:35:46Z",
      "mergedAt": "2020-10-07T14:35:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "856b7fe98915102ceb7796dfec41cb1b627b8b9e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzOTQ4OTUz",
          "commit": {
            "abbreviatedOid": "2786038"
          },
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-07T14:35:20Z",
          "updatedAt": "2020-10-07T14:35:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 319,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODg3NTIz",
      "title": "Clarify client-facing server GREASE behavior",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/319",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This change resolves a couple points of friction around GREASE.\r\n\r\n1. Remove the client-facing server's mandate to abort the connection if it receives the ECH extension but cannot negotiate 1.3 or higher. Presuming that a client MAY send a dummy (i.e., GREASEd) ECH extension without indicating support for 1.3, this mandate doesn't make much sense.\r\n1. Mandate that the client-facing server ignore the ECH extension if the SNI does not match the public name of any known ECH configuration. It is safe to presume GREASE in this case, since the client MUST set the outer SNI to the public name of its selected ECH config (see {{client-behavior}}).\r\n\r\nThis addresses https://github.com/tlswg/draft-ietf-tls-esni/issues/295.\r\n",
      "createdAt": "2020-10-01T01:20:53Z",
      "updatedAt": "2020-10-01T17:13:44Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e9c1bbd1acd13f1683f34fe0a51752da2c55cb6c",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "client_facing_behavior",
      "headRefOid": "04e27550933ad6d129151bb05ed82b71affbe8fa",
      "closedAt": "2020-10-01T17:13:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Instead, I think all we need is to clarify the client behavior.\r\n\r\nI think https://github.com/tlswg/draft-ietf-tls-esni/pull/321 should resolve the problem.",
          "createdAt": "2020-10-01T16:37:39Z",
          "updatedAt": "2020-10-01T16:37:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is the idea with this PR that the server wouldn't send retry keys based on the public name match?\r\n\r\nThe reason for this change is to allow the server to disambiguate between the following cases:\r\n1. Client sends GREASE ECH; want bypass (ignore the extension and continue as usual).\r\n2. Client sends real but stale ECH; want rejection.\r\n\r\nAs far as I can tell, there's currently no way for the server to disambiguate these, other than by using the public name. In particular, for (1.) it's true that SNI == public_name, and for (2.) it's true that SNI != public_name. I could be wrong about this, though :)\r\n\r\n> It doesn't cover if you're actually trying to visit the public name.\r\n\r\nIf you visit the public name with GREASE, then you'll get ECH rejection. If you want ECH to bypassed, then you MUST NOT send GREASE. For what it's worth, it's not clear to me why one would want to visit the client-facing server. It's sole purpose is to terminate the connection on the ECH rejection path.\r\n\r\n> And it closes off more specialized clients being more flexible in the public name in the future.\r\n\r\nThe spec is already inflexible about this. From 6.1, construction of CHOuter: 'The value of \"ECHConfig.public_name\" MUST be placed in the \"server_name\" extension.' Though I agree that if we want to relax this MUST to a SHOULD, then this PR needs to be changed.\r\n\r\n> Instead, I think all we need is to clarify the client behavior.\r\n> \r\n>     1. Retain the current text which says servers send retry keys, GREASE or no. Don't try to detect if it's GREASE vs. key mismatch.\r\n\r\nI believe detecting this is necessary on the part of the server, since the server takes needs to take a different action. In the first case, it wants to bypass ECH, and in the second it wants to reject it.",
          "createdAt": "2020-10-01T16:38:12Z",
          "updatedAt": "2020-10-01T16:38:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think the public name necessarily needs to be a throwaway domain. Indeed, it's better for sticking out purposes if it isn't. ECH rejection isn't fatal, precisely to support GREASE. The server handshakes with the public name however it would have. If it gets an HTTP request over that connection, great. Go respond to those.\r\n\r\nThe retry keys are a non-fatal \"hey, by the way, if you actually wanted that inner ClientHello, use these instead\". If the client wanted ECH, it will then terminate the connection with ech_required. If not, it just happily uses the connection and continues. That's why this sentence is there:\r\n\r\n> Note that an unrecognized ClientECH.config_id value may be a GREASE ECH extension (see {{grease-extensions}}), so it is necessary for servers to proceed with the connection and rely on the client to abort if ECH was required. In particular, the unrecognized value alone does not indicate a misconfigured ECH advertisement ({{misconfiguration}}). Instead, servers can measure occurrences of the \"ech_required\" alert to detect this case.",
          "createdAt": "2020-10-01T16:43:50Z",
          "updatedAt": "2020-10-01T16:43:50Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think the public name necessarily needs to be a throwaway domain. Indeed, it's better for sticking out purposes if it isn't. ECH rejection isn't fatal, precisely to support GREASE. The server handshakes with the public name however it would have. If it gets an HTTP request over that connection, great. Go respond to those.\r\n\r\nGood point.\r\n\r\n> The retry keys are a non-fatal \"hey, by the way, if you actually wanted that inner ClientHello, use these instead\". If the client wanted ECH, it will then terminate the connection with ech_required.\r\n\r\nHrm, I guess I was envisioning a much clearer signal of ECH rejection. As is, it can only be known that ECH was rejected once the client sends the \"ech_required\" alert. I suppose this is doable, if a little annoying on the server side. In any case, the points you raise outweigh the benefits of this PR, so let's drop it.\r\n\r\nOne thing I would like to emphasizes is that we currently mandate that the client MUST set the outer SNI to the public_name when offering ECH. If we want to support future implementations that are flexible about the public name, then we'll need to relax this.\r\n",
          "createdAt": "2020-10-01T16:57:53Z",
          "updatedAt": "2020-10-01T16:57:53Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed in favor of #321.",
          "createdAt": "2020-10-01T17:13:43Z",
          "updatedAt": "2020-10-01T17:13:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNDQ5MzEy",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "> This addresses #295.\r\n\r\nIs the idea with this PR that the server wouldn't send retry keys based on the public name match? The PR is unclear on that but, more importantly, that doesn't seem a good solution. It doesn't cover if you're actually trying to visit the public name. And it closes off more specialized clients being more flexible in the public name in the future.\r\n\r\nInstead, I think all we need is to clarify the client behavior.\r\n1. Retain the current text which says servers send retry keys, GREASE or no. Don't try to detect if it's GREASE vs. key mismatch.\r\n2. Clarify that clients don't process retry keys if they're sending GREASE. That was the intent. I agree the text isn't clear, but we should fix that rather than workaround at the server.",
          "createdAt": "2020-10-01T15:09:17Z",
          "updatedAt": "2020-10-01T15:25:35Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "What's the reason for checking the public name? It seems the server can just ignore it.",
              "createdAt": "2020-10-01T15:09:17Z",
              "updatedAt": "2020-10-01T15:25:35Z"
            },
            {
              "originalPosition": 12,
              "body": "That's not true. We may also just have a key mismatch, which was the original reason all this stuff was added. For instance, maybe the client picked up a very stale key from the DNS, or this server didn't get a new key config despite it being published in the DNS already.",
              "createdAt": "2020-10-01T15:11:19Z",
              "updatedAt": "2020-10-01T15:25:35Z"
            },
            {
              "originalPosition": 11,
              "body": "Seems this new text is redundant with the text right below it. \"If the ClientECH value does not match any known ECHConfig structure, it [...]\".",
              "createdAt": "2020-10-01T15:12:02Z",
              "updatedAt": "2020-10-01T15:25:35Z"
            },
            {
              "originalPosition": 25,
              "body": "\"First\" is plausible in the case below I guess, but if you've got a config_id, there should be just the one match.",
              "createdAt": "2020-10-01T15:12:58Z",
              "updatedAt": "2020-10-01T15:25:35Z"
            },
            {
              "originalPosition": 7,
              "body": "Hrm. Actually this whole bit is kind of odd now, because the inner and outer ClientHellos no longer have the same version list. I think it's something that wasn't updated in the ESNI to ECH change.\r\n\r\nFWIW, I don't think it needed changes for GREASE. A client greasing ECH presumably supports TLS 1.3, and any server that implements this specification would also support TLS 1.3. But it might need some tweaks on account of ECH. It seems the version check should happen after you've chosen to use the inner ClientHello, and ECH wants to get resolved extremely early, before you've actually locked in a version.",
              "createdAt": "2020-10-01T15:21:55Z",
              "updatedAt": "2020-10-01T15:25:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTA0ODMy",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:08:03Z",
          "updatedAt": "2020-10-01T16:08:03Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "If the outer SNI doesn't match the public name, then the server presumes GREASE and ignores the ECH extension. If it does match, then the server presumes real ECH. ",
              "createdAt": "2020-10-01T16:08:03Z",
              "updatedAt": "2020-10-01T16:08:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTA5MjAx",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:13:10Z",
          "updatedAt": "2020-10-01T16:13:10Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "What's your proposal? If the we add a rule that says the client MUST NOT (or at least SHOULD NOT) offer GREASE in TLS 1.2 or below, then I'm happy to revert to aborting the handshake here.",
              "createdAt": "2020-10-01T16:13:10Z",
              "updatedAt": "2020-10-01T16:13:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTEyOTg3",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:17:34Z",
          "updatedAt": "2020-10-01T16:17:34Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I don't think the public key being stale is at issue here. Is your point that the the public_name of the ECH config might be stale? ",
              "createdAt": "2020-10-01T16:17:34Z",
              "updatedAt": "2020-10-01T16:17:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTEzNjI4",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:18:23Z",
          "updatedAt": "2020-10-01T16:18:23Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "The public name not matching is not the same as the ClientECH not matching a known ECHConfig. In particular, the former does not imply the latter.",
              "createdAt": "2020-10-01T16:18:23Z",
              "updatedAt": "2020-10-01T16:18:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTE4NTMy",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:24:21Z",
          "updatedAt": "2020-10-01T16:24:21Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I'll upload a PR for this. I don't think either the old or new text is right. (See https://github.com/tlswg/draft-ietf-tls-esni/issues/309#issuecomment-702233855)",
              "createdAt": "2020-10-01T16:24:21Z",
              "updatedAt": "2020-10-01T16:24:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTIyMTE3",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:28:42Z",
          "updatedAt": "2020-10-01T16:28:43Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "See top-level comment. I don't think that works in general and we can resolve #295 much more simply. (The intent was already for this not to be an issue. I just did a bad job of describing the client behavior.)",
              "createdAt": "2020-10-01T16:28:42Z",
              "updatedAt": "2020-10-01T16:28:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTIzOTg4",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:30:55Z",
          "updatedAt": "2020-10-01T16:30:56Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "https://github.com/tlswg/draft-ietf-tls-esni/pull/320",
              "createdAt": "2020-10-01T16:30:55Z",
              "updatedAt": "2020-10-01T16:30:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 320,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk2MzkwOTE2",
      "title": "Fix ECH and version negotiation order.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/320",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The version check on the outer ClientHello doesn't make much sense\r\nsince, when ECH is accepted, the version is based on the inner\r\nClientHello anyway. See\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/issues/309#issuecomment-702233855.\r\n\r\nI've left a TODO since it seems weird to have a client requirement like\r\nthat be so load-bearing without a corresponding server check. Not sure\r\nwhere we should go there.",
      "createdAt": "2020-10-01T16:30:47Z",
      "updatedAt": "2020-10-07T14:32:47Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e9c1bbd1acd13f1683f34fe0a51752da2c55cb6c",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "versions",
      "headRefOid": "74ac381fc96ff4982b1d4ea74146589fddec2f77",
      "closedAt": "2020-10-07T14:32:47Z",
      "mergedAt": "2020-10-07T14:32:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f19f56700c3b8e3a3e7fb2f7d8b04f36585f15d1"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this change, but it might be worth resolving the TODO.",
          "createdAt": "2020-10-01T22:13:55Z",
          "updatedAt": "2020-10-01T22:13:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm fine with omitting a check on the server. \r\n\r\nRemoved the TODO in favor of some clarifying text on the client side.",
          "createdAt": "2020-10-02T20:55:17Z",
          "updatedAt": "2020-10-02T20:55:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzQxMTEz",
          "commit": {
            "abbreviatedOid": "b873b9f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T21:47:05Z",
          "updatedAt": "2020-10-01T21:47:05Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Which ClientHello?",
              "createdAt": "2020-10-01T21:47:05Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzQyNjQ4",
          "commit": {
            "abbreviatedOid": "b873b9f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T21:50:06Z",
          "updatedAt": "2020-10-01T21:50:06Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "s/can decrypt it/can accept ECH/, since \"accept ECH\" is a well-defined term.",
              "createdAt": "2020-10-01T21:50:06Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzQ1OTMw",
          "commit": {
            "abbreviatedOid": "b873b9f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T21:56:49Z",
          "updatedAt": "2020-10-01T21:56:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Why is this hard in Split Mode? Couldn't we mandate that if the backend server observes the empty ECH extension (sent in the ClientHelloInner in order to signal the backend server to confirm acceptance), it aborts unless it can negotiate 1.3 or higher?",
              "createdAt": "2020-10-01T21:56:49Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMDk2MjUy",
          "commit": {
            "abbreviatedOid": "b873b9f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "> I've left a TODO since it seems weird to have a client requirement like that be so load-bearing without a corresponding server check. Not sure where we should go there.\r\n\r\nI'm fine with omitting a check on the server. I don't see much difference between a client implementation choosing to ignore the MUST in generating its ClientHelloInner supported_versions list, and a client implementation not supporting ECH at all. Plus, I could see future extensions or variants of ECH where we allow TLS 1.2 for the backend, and the server's handshake traffic is tunneled between the client and client-facing-server, and a check might make that difficult to do. ",
          "createdAt": "2020-10-02T12:37:13Z",
          "updatedAt": "2020-10-02T12:53:00Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\ndetermines if it will accept ECH, prior to negotiating any other TLS parameters.\r\n```",
              "createdAt": "2020-10-02T12:37:13Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            },
            {
              "originalPosition": 17,
              "body": "Presumably the inner, given below.",
              "createdAt": "2020-10-02T12:44:42Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMzk2MDky",
          "commit": {
            "abbreviatedOid": "b873b9f"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T19:31:48Z",
          "updatedAt": "2020-10-02T19:31:49Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Yeah, the backend server doesn't see the outer one.",
              "createdAt": "2020-10-02T19:31:48Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMzk2NTg0",
          "commit": {
            "abbreviatedOid": "f130e9d"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T19:32:37Z",
          "updatedAt": "2020-10-02T19:32:38Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "(Resolved by committing @chris-wood's suggestion.)",
              "createdAt": "2020-10-02T19:32:38Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzOTQ1OTkz",
          "commit": {
            "abbreviatedOid": "74ac381"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-07T14:32:36Z",
          "updatedAt": "2020-10-07T14:32:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 321,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk2Mzk0NTM5",
      "title": "Clarify client handling of retry keys with GREASE.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/321",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The intent was that the server always sends the retry keys (it cannot\r\ndistinguish stale keys from GREASE when the client is actually trying to\r\nconnect to the public name), while the client just ignores them, but I\r\ndid a poor job of describing this, so add a key sentence.\r\n\r\nThis addresses #295.",
      "createdAt": "2020-10-01T16:37:06Z",
      "updatedAt": "2020-10-01T17:10:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e9c1bbd1acd13f1683f34fe0a51752da2c55cb6c",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "clarify-grease",
      "headRefOid": "01b53b3366e2e52796df186581b2ab6ceddd536f",
      "closedAt": "2020-10-01T17:10:22Z",
      "mergedAt": "2020-10-01T17:10:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "32ce20a4a0e256733d03ec56cd8081df1d794012"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(_EDITED._) To recap the discussion on #319, your point is that the client-facing server needn't attempt to distinguish GREASE from non-GREASE based on outer SNI, because if the outer SNI != public name, then the client knows to ignore the retry config and continue as usual. \r\n\r\nI think this is weird because if rejection was the intent, then the client is supposed to abort with \"ech_required\". So the server only knows that non-GREASE was intended once it receives this signal.",
          "createdAt": "2020-10-01T16:45:33Z",
          "updatedAt": "2020-10-01T16:49:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I mean, yeah, that's how this was designed and is what we merged to the spec. :-)\r\n\r\nThis formulation, in particular, does not break if the client tries to connect to the public name (it's a perfectly valid URL) without knowing the ECH config (maybe it the HTTPS record didn't get through Do53) but still sends GREASE (because the intent is that every client can GREASE). It seems to me #319 breaks this. Do you have an alternate formulation which keeps this working?\r\n\r\nConnecting to the public name is especially important if the public name is a non-throwaway domain. The only requirement on the public name is that it's some name which knows about and serves the client-facing server's config. (I.e. this particular backend server is the same entity as the client-facing server.) #319 doesn't relax this requirement, since the public name continues to be the entity trusted to replace, and possibly disable, ECH on config mismatch.",
          "createdAt": "2020-10-01T16:57:09Z",
          "updatedAt": "2020-10-01T16:57:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think this is weird because if rejection was the intent, then the client is supposed to abort with \"ech_required\". So the server only knows that non-GREASE was intended once it receives this signal.\r\n\r\nI don't see this as an issue. If the client sends GREASE, it doesn't expect to use ECH, so it won't abort. The text here only requires that the client check the extension if present, and ignore it if absent.",
          "createdAt": "2020-10-01T17:06:00Z",
          "updatedAt": "2020-10-01T17:06:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't have an alternative formulation. I was evnisioning the public name only being verified on the ECH rejection path, or when neither real nor dummy ECH was offered to the client-facing server.\r\n\r\nI'm fine with rejection not being known until \"ech_required\". I support this PR as the resolution to #295.",
          "createdAt": "2020-10-01T17:06:31Z",
          "updatedAt": "2020-10-01T17:06:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 327,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk5NTQ1NDg5",
      "title": "Rewrite \"Resumption PSK Oracle Mitigation\".",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/327",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think this is a more general attack and deserves a more general description of the mitigation. See https://github.com/tlswg/draft-ietf-tls-esni/pull/317#discussion_r501319277 and #263.\r\n\r\n@chris-wood ",
      "createdAt": "2020-10-07T22:13:35Z",
      "updatedAt": "2020-10-07T23:03:41Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e3a6b583b47c0907774bdb04d45df881270df17e",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "ch-malleability",
      "headRefOid": "b7533f478742cf91b0002ffbfbbc88633aa9b842",
      "closedAt": "2020-10-07T23:03:41Z",
      "mergedAt": "2020-10-07T23:03:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "61b11b92583f170bcd348f3c09bbb927aa56d19c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzI2MTI4",
          "commit": {
            "abbreviatedOid": "d558a7a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-07T23:02:52Z",
          "updatedAt": "2020-10-07T23:02:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 328,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwMjk3NjEy",
      "title": "Define error-handling for missing outer extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/328",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Looks like this was missing.",
      "createdAt": "2020-10-09T02:04:08Z",
      "updatedAt": "2020-10-11T11:23:12Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "172ab91cc20dc5e3046d946ddad28a951673f2e7",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "missing-outer-extension",
      "headRefOid": "67431a639f1f9d65569db4503c81fd53d53d2bc8",
      "closedAt": "2020-10-11T11:23:12Z",
      "mergedAt": "2020-10-11T11:23:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f38a6100acfc1f46f820db2eadfe614bd61afcb3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1OTc0MzQ1",
          "commit": {
            "abbreviatedOid": "67431a6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-09T20:36:35Z",
          "updatedAt": "2020-10-09T20:36:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MTY5NzM1",
          "commit": {
            "abbreviatedOid": "67431a6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-11T11:23:06Z",
          "updatedAt": "2020-10-11T11:23:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 330,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwMzEwODQ4",
      "title": "Consistently construct ClientHelloInner before ClientHelloOuter.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/330",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #329.",
      "createdAt": "2020-10-09T02:58:34Z",
      "updatedAt": "2020-10-11T11:22:43Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "172ab91cc20dc5e3046d946ddad28a951673f2e7",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "inner-before-outer",
      "headRefOid": "5d8096db40b58804eadf10692f7e3f7357768668",
      "closedAt": "2020-10-11T11:22:43Z",
      "mergedAt": "2020-10-11T11:22:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8eea39d2ea732c534a6344fde12cf504011dced9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODExODI5",
          "commit": {
            "abbreviatedOid": "0759a65"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T16:09:44Z",
          "updatedAt": "2020-10-09T16:09:45Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "This rule could be made more clear. Suggestion:\r\n> Any extension that appears in the payload of the \"outer_extensions\" extension of the ClientHelloInner MUST appear in the ClientHelloOuter.",
              "createdAt": "2020-10-09T16:09:45Z",
              "updatedAt": "2020-10-09T18:59:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODU3MDk1",
          "commit": {
            "abbreviatedOid": "0759a65"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T17:16:50Z",
          "updatedAt": "2020-10-09T17:16:50Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I didn't want to talk about outer_extensions specifically appearing in ClientHelloInner because of #331. The ClientHelloInner doesn't really have outer_extensions, only the payload of the ECH extension. We haven't settled yet on text there, or a processing order of actually encrypting things (I'll need to fiddle with that as part of #323), so for now I figure citing the actual process was the least ambiguous.\r\n\r\nThe distinction is important because of which is actually used in the handshake. (Transcript and whatnot.)",
              "createdAt": "2020-10-09T17:16:50Z",
              "updatedAt": "2020-10-09T18:59:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODU4ODQw",
          "commit": {
            "abbreviatedOid": "0759a65"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T17:19:33Z",
          "updatedAt": "2020-10-09T17:19:33Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Then I would just leave an \"OPEN ISSUE\" so we know to fix this later. ",
              "createdAt": "2020-10-09T17:19:33Z",
              "updatedAt": "2020-10-09T18:59:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1OTIxMjM2",
          "commit": {
            "abbreviatedOid": "5d8096d"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T18:59:41Z",
          "updatedAt": "2020-10-09T18:59:41Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Done.",
              "createdAt": "2020-10-09T18:59:41Z",
              "updatedAt": "2020-10-09T18:59:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1OTc0MTMy",
          "commit": {
            "abbreviatedOid": "5d8096d"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-09T20:36:08Z",
          "updatedAt": "2020-10-09T20:36:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MTY5NzAy",
          "commit": {
            "abbreviatedOid": "5d8096d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-11T11:22:38Z",
          "updatedAt": "2020-10-11T11:22:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 332,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwNjg0NzA5",
      "title": "Note -05 of HPKE for this version of ECH.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/332",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @cjpatton, @davidben ",
      "createdAt": "2020-10-09T16:00:03Z",
      "updatedAt": "2020-10-09T17:18:15Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "172ab91cc20dc5e3046d946ddad28a951673f2e7",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/note-05",
      "headRefOid": "dd583361acb0cc9d0e1097a225f22267d1d109e8",
      "closedAt": "2020-10-09T17:18:14Z",
      "mergedAt": "2020-10-09T17:18:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "066dc0a46a4a56adb84169504b4e24b8f77007f6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODA1OTE3",
          "commit": {
            "abbreviatedOid": "ea5b749"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T16:01:42Z",
          "updatedAt": "2020-10-09T16:01:42Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nECH uses draft-05 of HPKE for public key encryption {{!I-D.irtf-cfrg-hpke}}.\r\n```",
              "createdAt": "2020-10-09T16:01:42Z",
              "updatedAt": "2020-10-09T16:03:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODMxMjE1",
          "commit": {
            "abbreviatedOid": "dd58336"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-09T16:37:26Z",
          "updatedAt": "2020-10-09T16:37:26Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODU3NTc5",
          "commit": {
            "abbreviatedOid": "dd58336"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-09T17:17:37Z",
          "updatedAt": "2020-10-09T17:17:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 334,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAxMTY3NTM3",
      "title": "Resolve missing outer ClientHello guidance.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/334",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I noticed there's an OPEN ISSUE to add ClientHelloOuter guidance, but there's already a section for it. Link to it and flesh it out a little more.\r\n\r\nSadly, in doing so, I've traded one OPEN ISSUE for another OPEN ISSUE, but hopefully that'll be closed shortly.",
      "createdAt": "2020-10-11T16:40:21Z",
      "updatedAt": "2020-10-14T20:09:54Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f38a6100acfc1f46f820db2eadfe614bd61afcb3",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "outer-ch-guidance",
      "headRefOid": "3ce7475acccb160c1796d18a7dde1ae2a2153779",
      "closedAt": "2020-10-14T20:09:54Z",
      "mergedAt": "2020-10-14T20:09:54Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f9eb1a5b40b3c5770b2350b499623e659286f251"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTM2OTY0",
          "commit": {
            "abbreviatedOid": "3ce7475"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-12T21:45:32Z",
          "updatedAt": "2020-10-12T21:45:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NjkwNzkz",
          "commit": {
            "abbreviatedOid": "3ce7475"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-14T20:09:45Z",
          "updatedAt": "2020-10-14T20:09:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 335,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAxMTc0MDA1",
      "title": "Disambiguate the encoded vs actual ClientHelloInner.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/335",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #331. Along the way, I've made two additional tweaks:\r\n\r\n- Renamed outer_extension to outer_extensions, now that it contains multiple extensions. One of the diagrams even already referred to \"outer_extensions\" because I didn't realize it was called \"outer_extension\".\r\n\r\n- Clarified in compression process and ClientHelloInner construction rules that the to-be-compressed extensions must be consecutive. Hopefully that helps with #262.",
      "createdAt": "2020-10-11T17:22:30Z",
      "updatedAt": "2020-10-14T20:07:50Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f38a6100acfc1f46f820db2eadfe614bd61afcb3",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "encoded-inner",
      "headRefOid": "caa2fa30c90f5f0ae7087e2e9076416929672c2d",
      "closedAt": "2020-10-14T20:07:50Z",
      "mergedAt": "2020-10-14T20:07:50Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "44aaa7e051ff27cf20b2adf8dcfd86ce7b3bd73e"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Clarified in compression process and ClientHelloInner construction rules that the to-be-compressed extensions must be consecutive. Hopefully that helps with #262.\r\n\r\n@cjpatton FYI. I'm hoping this will help clarify why the ordering thing isn't actually a big deal.",
          "createdAt": "2020-10-11T17:31:33Z",
          "updatedAt": "2020-10-11T17:31:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've updated the PR to include text to disambiguate the serialization.\r\n\r\nIt's ambiguous whether the encoding includes the 4-byte (12-byte in DTLS) header from the Handshake structure or is just the body, from the ClientHello structure. I've picked the smaller one. This also saves having to answer, in DTLS, what happens when the inner sequence number is wrong.",
          "createdAt": "2020-10-11T18:26:17Z",
          "updatedAt": "2020-10-11T18:26:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MTk5NzEw",
          "commit": {
            "abbreviatedOid": "d1cca1d"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-11T17:23:01Z",
          "updatedAt": "2020-10-11T17:23:01Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Should the TLS 1.3 column be \"\" instead of \"CH\"? It's not *really* a ClientHello extension.",
              "createdAt": "2020-10-11T17:23:01Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTM5OTYy",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T21:52:23Z",
          "updatedAt": "2020-10-12T21:52:24Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "I think so.",
              "createdAt": "2020-10-12T21:52:23Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQzMzE5",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T22:00:29Z",
          "updatedAt": "2020-10-12T22:00:30Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "It should be possible to relax this for the existing \"inner_digest\" mechanism. However, I suspect this is will be essential once #336 lands.",
              "createdAt": "2020-10-12T22:00:29Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQ0NDA4",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-12T22:03:20Z",
          "updatedAt": "2020-10-12T22:03:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTY4NzA1",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T23:09:19Z",
          "updatedAt": "2020-10-12T23:09:19Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Hrm, I'm not sure I follow. I was thinking less a security requirement and more a correctness/syntax one. The outer_extensions mechanism, inner digest or AAD, can't express more than one consecutive chunk of elided extensions. That means that when you assemble the ClientHello, you need to adjust the order to fit your intended compression.",
              "createdAt": "2020-10-12T23:09:19Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTcwOTc0",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T23:16:33Z",
          "updatedAt": "2020-10-12T23:16:34Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "My point is that the map from ClientHelloInner to EncodedClientHelloInner need not be invertible. To compute \"inner_digest\", the client just needs to be able to compute the same map from EncodedClientHelloInner to ClientHelloInner that the server does. I don't think it's not necessary that the extensions be consecutive, although it would be much easier to implement this correctly if they were.\r\n\r\nIn any case, I'm happy with this rule.",
              "createdAt": "2020-10-12T23:16:33Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTg5OTM5",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T00:12:39Z",
          "updatedAt": "2020-10-13T00:12:39Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "I'm still a little confused. Just double-checking that the text is clear enough and we're on the same page... (If we're both happy with the text, but because we interpreted it differently, that's not very helpful!)\r\n\r\nI am saying it *is* important that ClientHelloInner to EncodedClientHelloInner is invertible. This is true in the status quo, and it remains true after #336. Handshake correctness requires that the server reconstruct the *exact* same value, byte-for-byte. Even though the extension order isn't very meaningful semantically, it changes what goes in the transcript and binders, so both sides need to agree. So if the client first assembles:\r\n\r\n`ClientHelloInner = (key_share, supported_versions, supported_groups, pre_shared_keys)`\r\n\r\nthen it compresses key_share + supported_groups as:\r\n\r\n`EncodedClientHelloInner = (outer_extensions(key_share, supported_groups), supported_versions, pre_shared_keys)`\r\n\r\nThe server will reconstruct:\r\n\r\n`ClientHelloInner' = (key_share, supported_groups, supported_versions, pre_shared_keys)`\r\n\r\nThese don't match, so the handshake will fail, both at the transcript and at checking the PSK binders. This isn't a security question because we haven't gotten there yet. It's a basic correctness question.\r\n\r\nNow, the thing that went wrong here is that the entire process of swapping extensions out for outer_extensions *only works if the removed extensions are consecutive*. Thus, this PR adds \"Removed extensions MUST be ordered consecutively in ClientHelloInner\" to EncodedClientHelloInner construction. For that precondition to hold, the client must have ordered the extensions it wanted to compress, thus we add a matching rule, this sentence, to ClientHelloInner construction. Now everything works out and the compression process is correct.",
              "createdAt": "2020-10-13T00:12:39Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTkwNDgx",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T00:14:37Z",
          "updatedAt": "2020-10-13T00:14:38Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Oh, I think I might see the misunderstanding.\r\n\r\n> [...] the client just needs to be able to compute the same map from EncodedClientHelloInner to ClientHelloInner that the server does.\r\n\r\nThis does not work. The client does not compute EncodedClientHelloInner to ClientHelloInner at all. It cannot. By the time we've gotten this far, we've already generated all the PSK binders.",
              "createdAt": "2020-10-13T00:14:37Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MDAxMzc2",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T00:55:26Z",
          "updatedAt": "2020-10-13T00:55:27Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Oof, I forgot about the PSK binders :D Thanks for taking the time to clarify my misunderstanding.",
              "createdAt": "2020-10-13T00:55:26Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MDA1MjE0",
          "commit": {
            "abbreviatedOid": "caa2fa3"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T01:09:58Z",
          "updatedAt": "2020-10-13T01:09:58Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Switched to \"\"",
              "createdAt": "2020-10-13T01:09:58Z",
              "updatedAt": "2020-10-13T01:09:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4Njg5MDYy",
          "commit": {
            "abbreviatedOid": "caa2fa3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-14T20:07:18Z",
          "updatedAt": "2020-10-14T20:07:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 336,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAxMTg0NjM1",
      "title": "Replace inner_digest with ClientHelloOuterAAD",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/336",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #323. The first commit shaves 33 bytes (or 49 with SHA-384) from the ciphertext by replacing inner_digest with ClientHelloOuterAAD. This also allows for more compact ClientHelloInner encodings when non-extension fields are expected to match. The second commit shaves a further 32 bytes.\r\n\r\nWe could probably further optimize the encoding but I've left it alone here. In particular, if we merge #316, all non-extension fields may as well be implicit. We could then replace the encryption payload with a plain extensions block.",
      "createdAt": "2020-10-11T18:29:21Z",
      "updatedAt": "2020-10-16T18:57:53Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "17ac85d3a0a9c4a0bbb93060df0e360ede4dac3c",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "bind-outer-ch",
      "headRefOid": "5603439bbcc302addbaaac51b63639d71ca844b3",
      "closedAt": "2020-10-16T18:57:53Z",
      "mergedAt": "2020-10-16T18:57:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a643df2dc8921c5e089d5a7e64492aa5f92e7cf1"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We could then replace the encryption payload with a plain extensions block.\r\n\r\nI guess that doesn't quite work, but we could replace it with the new random value, and an extensions block. Something like:\r\n\r\n```\r\nstruct {\r\n  Random random;\r\n  Extension extensions<8..2^16-1>;\r\n} EncodedClientHelloInner;\r\n```\r\n\r\nAnyway, a topic for a later PR, depending on how strongly we want to match cipher suites for #316. The size savings are a bit more marginal beyond that.",
          "createdAt": "2020-10-12T20:55:36Z",
          "updatedAt": "2020-10-12T20:55:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this change a lot. At some point while implementing ECH, I noted that it would be nice to have an explicit binding of CHOuter to the handshake in case of ECH acceptance. This provides that.",
          "createdAt": "2020-10-12T22:24:13Z",
          "updatedAt": "2020-10-12T22:24:13Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased and review comments addressed. The PR should also no longer be in a confusing state if you look at the diff.",
          "createdAt": "2020-10-14T20:36:32Z",
          "updatedAt": "2020-10-14T20:36:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQ2MTAx",
          "commit": {
            "abbreviatedOid": "2bc7c8f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T22:07:44Z",
          "updatedAt": "2020-10-12T22:07:44Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "s/to the encryption/for AEAD encryption.",
              "createdAt": "2020-10-12T22:07:44Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQ4MTc2",
          "commit": {
            "abbreviatedOid": "2bc7c8f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T22:12:48Z",
          "updatedAt": "2020-10-12T22:12:49Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "`ClientHelloOuterAAD` is a bit different than we discussed in #323. In particular, I thought it was decided that we should predict the length of the \"encrypted_client_hello\" extension and authenticate as many zeros. What changed your mind? For the record, the approach is here seems a lot simpler to me :)",
              "createdAt": "2020-10-12T22:12:48Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQ4NTgx",
          "commit": {
            "abbreviatedOid": "2bc7c8f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T22:13:53Z",
          "updatedAt": "2020-10-12T22:13:53Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Suggestion: s/Outer ClientHello/ClientHelloOuter.",
              "createdAt": "2020-10-12T22:13:53Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQ5MTAz",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T22:15:09Z",
          "updatedAt": "2020-10-12T22:15:10Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Suggestion: s/Inner ClientHello/ClientHelloInner.",
              "createdAt": "2020-10-12T22:15:09Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQ5NjMx",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T22:16:33Z",
          "updatedAt": "2020-10-12T22:16:34Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Does this mean to send a 0-length `legacy_session_id`, or does this mean to send a `legacy_session_id` with the same length, but with all zeros? Presumably you mean the former?",
              "createdAt": "2020-10-12T22:16:33Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTY5NTIz",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T23:11:46Z",
          "updatedAt": "2020-10-12T23:11:47Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Oh I probably was just unclear in that discussion. I never preferred the zeros formulation. :-) That was more me musing on how annoying it would be if there were another reason to prefer it. I like this better because, as you say, it's simpler.",
              "createdAt": "2020-10-12T23:11:47Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NjEwOTM0",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T16:17:12Z",
          "updatedAt": "2020-10-13T16:17:13Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "(Will deal with uploading a new revision after base PRs go through, since Github makes a mess of these.)\r\n\r\nWorks for me, though it's unclear to me how much we like sticking identifiers in section titles, which is why I used the words instead. E.g. RFC8446's section titles say things like \"Supported Versions\" and this document had \"Incorporating Outer Extensions\" rather than \"outer_extensions\". Although, admittedly, \"ClientHello\" is itself an identifier, but I figured it was a more established one (elsewhere we have \"Sending an encrypted ClientHello\").\r\n\r\n\u00af\\\\\\_(\u30c4)_/\u00af",
              "createdAt": "2020-10-13T16:17:13Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NjExOTAw",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T16:18:17Z",
          "updatedAt": "2020-10-13T16:18:17Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Oh, and we have \"Outer ClientHello\" as a section title down in Security Considerations, though I suppose that too is my fault. :-)",
              "createdAt": "2020-10-13T16:18:17Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NjkxOTc4",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:11:28Z",
          "updatedAt": "2020-10-14T20:11:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n## Encoding ClientHelloInner {#encoding-inner-clienthello}\r\n```",
              "createdAt": "2020-10-14T20:11:29Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NjkyNTM4",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:12:15Z",
          "updatedAt": "2020-10-14T20:12:15Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "```suggestion\r\n## Authenticating ClientHelloOuter {#authenticating-outer-clienthello}\r\n```",
              "createdAt": "2020-10-14T20:12:15Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzA3NjMy",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:34:38Z",
          "updatedAt": "2020-10-14T20:34:39Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Done. Though I used HPKE encryption since it looks like the rest of the document mostly refers to HPKE rather than the internal AEAD.",
              "createdAt": "2020-10-14T20:34:39Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzA3ODQ2",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:34:57Z",
          "updatedAt": "2020-10-14T20:34:57Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Done.",
              "createdAt": "2020-10-14T20:34:57Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzA3OTE5",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:35:03Z",
          "updatedAt": "2020-10-14T20:35:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done.",
              "createdAt": "2020-10-14T20:35:03Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzA4MDg3",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:35:18Z",
          "updatedAt": "2020-10-14T20:35:19Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Reworded to be clearer.",
              "createdAt": "2020-10-14T20:35:19Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzA4NDcw",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:35:51Z",
          "updatedAt": "2020-10-14T20:35:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Applied manually since I needed to rebase.",
              "createdAt": "2020-10-14T20:35:51Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzA4NTU3",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:35:58Z",
          "updatedAt": "2020-10-14T20:35:59Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Applied manually since I needed to rebase.",
              "createdAt": "2020-10-14T20:35:58Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4ODA5OTE3",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-14T22:19:37Z",
          "updatedAt": "2020-10-14T22:19:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNTg0NjQ2",
          "commit": {
            "abbreviatedOid": "bd3f76b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T15:36:50Z",
          "updatedAt": "2020-10-16T17:05:32Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "What is an empty value?",
              "createdAt": "2020-10-16T15:36:51Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\nderiving a ClientHelloOuterAAD value. This is computed by serializing ClientHelloOuter\r\nwith the \"encrypted_client_hello\" extension removed.\r\n```",
              "createdAt": "2020-10-16T15:39:47Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nfirst making a copy of ClientHelloInner. It then replaces the legacy\\_session\\_id\r\n```",
              "createdAt": "2020-10-16T15:40:58Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            },
            {
              "originalPosition": 134,
              "body": "```suggestion\r\nforbidden in ClientHelloOuter.\r\n```",
              "createdAt": "2020-10-16T17:04:42Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjcwMjQ2",
          "commit": {
            "abbreviatedOid": "bd3f76b"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:32:06Z",
          "updatedAt": "2020-10-16T17:32:06Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "The empty string. I previously wrote \"clears the value\", but @cjpatton objected to that one. :-P How about s/empty value/empty string/? We haven't introduced a new encoded structure yet (https://github.com/tlswg/draft-ietf-tls-esni/pull/336#issuecomment-707341408), so we need to put *something* in there.",
              "createdAt": "2020-10-16T17:32:06Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjcyMTQ3",
          "commit": {
            "abbreviatedOid": "c286376"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:34:03Z",
          "updatedAt": "2020-10-16T17:34:03Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "So a zero-length string, as opposed to a 32 byte string of zeroes? (Whatever makes that more clear is fine by me.)",
              "createdAt": "2020-10-16T17:34:03Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjc2MzEw",
          "commit": {
            "abbreviatedOid": "c286376"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:38:15Z",
          "updatedAt": "2020-10-16T17:38:15Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I mean the point is to encode fewer bytes, so yeah. I feel like, given the field is defined by `opaque legacy_session_id<0..32>`, it would be unreasonable to interpret \"empty value\" or \"empty string\" as a 32-byte string of zeros. :-P\r\n\r\nI dunno, I think all the options so far have been pretty clear, so I'm not the best judge here. The intent is to stick the zero-length string in there. Which one do you prefer?\r\n* clears the legacy_session_id field\r\n* replaces the legacy_session_id field with an empty value\r\n* replaces the legacy_session_id field with a zero-length value\r\n* replaces the legacy_session_id field with an empty string\r\n* replaces the legacy_session_id field with a zero-length string",
              "createdAt": "2020-10-16T17:38:15Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjgxNTEx",
          "commit": {
            "abbreviatedOid": "c286376"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:45:22Z",
          "updatedAt": "2020-10-16T17:45:23Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "+1 \"replaces the legacy_session_id field with an empty string\"",
              "createdAt": "2020-10-16T17:45:23Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjgyMTkw",
          "commit": {
            "abbreviatedOid": "c286376"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:46:25Z",
          "updatedAt": "2020-10-16T17:46:26Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "nit: Adjust margins in this paragraph so each line breaks at 80 characters.",
              "createdAt": "2020-10-16T17:46:26Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjg0MjQz",
          "commit": {
            "abbreviatedOid": "c286376"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:49:34Z",
          "updatedAt": "2020-10-16T17:49:34Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Okay, empty string it is. I don't care, just pick one. :-)",
              "createdAt": "2020-10-16T17:49:34Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjg0NjE0",
          "commit": {
            "abbreviatedOid": "5603439"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:50:10Z",
          "updatedAt": "2020-10-16T17:50:10Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done.",
              "createdAt": "2020-10-16T17:50:10Z",
              "updatedAt": "2020-10-16T17:50:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjg0Njk0",
          "commit": {
            "abbreviatedOid": "5603439"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:50:17Z",
          "updatedAt": "2020-10-16T17:50:18Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Done.",
              "createdAt": "2020-10-16T17:50:18Z",
              "updatedAt": "2020-10-16T17:50:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjg5MDMx",
          "commit": {
            "abbreviatedOid": "5603439"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T17:56:37Z",
          "updatedAt": "2020-10-16T17:56:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 337,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAyNTQ3ODMw",
      "title": "Tweak section titles and comparison against criteria.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/337",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We use a mix of sentence case and title case in the document. The RFC style guide says to use title case. This PR aligns with that.\r\nhttps://tools.ietf.org/html/rfc7322#section-3.4\r\n\r\nAdditionally, the ESNI criteria document has changed slightly since the comparison against criteria section was written. I've aligned the titles with the final wording in RFC8744. RFC8744 has also merged \"Proper security context\" and \"Split server spoofing\", so I've done the same here. \"Support Multiple Protocols\" also now talks about transport protocols and ALPN, so I've added a few words about that.",
      "createdAt": "2020-10-13T16:34:02Z",
      "updatedAt": "2020-10-14T20:04:56Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b58478b19d3ba85f6a386fdd7b8fea11e08ee4c2",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "section-titles",
      "headRefOid": "332b51f45bce91a8d5ca8078badeb543664354ee",
      "closedAt": "2020-10-14T20:04:56Z",
      "mergedAt": "2020-10-14T20:04:56Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "63e32c26407276842bb160633775993f8951f3d5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3ODQyMjcz",
          "commit": {
            "abbreviatedOid": "4cfe40c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T21:28:41Z",
          "updatedAt": "2020-10-13T21:28:42Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "s/party/Party/ ?",
              "createdAt": "2020-10-13T21:28:42Z",
              "updatedAt": "2020-10-14T20:04:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3ODQ0OTUx",
          "commit": {
            "abbreviatedOid": "4cfe40c"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T21:33:20Z",
          "updatedAt": "2020-10-13T21:33:20Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Yeah, I thought that too, but RFC8744 does it this way.\r\nhttps://www.rfc-editor.org/rfc/rfc8744.html#name-enable-multi-party-security\r\n\r\n\u00af\\\\\\_(\u30c4)_/\u00af",
              "createdAt": "2020-10-13T21:33:20Z",
              "updatedAt": "2020-10-14T20:04:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4Njg2OTg2",
          "commit": {
            "abbreviatedOid": "4cfe40c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-14T20:04:13Z",
          "updatedAt": "2020-10-14T20:04:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 338,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAyODMxNjY1",
      "title": "Add an OPEN ISSUE for stateless HRR and split mode.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/338",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Issue #333.",
      "createdAt": "2020-10-13T20:56:12Z",
      "updatedAt": "2020-10-14T20:03:31Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f38a6100acfc1f46f820db2eadfe614bd61afcb3",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "stateless-hrr-open-issue",
      "headRefOid": "4c4db5a95ad794ac23dc7dc99e31d0f4b16b258f",
      "closedAt": "2020-10-14T20:03:31Z",
      "mergedAt": "2020-10-14T20:03:31Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b58478b19d3ba85f6a386fdd7b8fea11e08ee4c2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3ODM2NDc0",
          "commit": {
            "abbreviatedOid": "4c4db5a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-13T21:18:58Z",
          "updatedAt": "2020-10-13T21:18:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4Njg2NDAz",
          "commit": {
            "abbreviatedOid": "4c4db5a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-14T20:03:24Z",
          "updatedAt": "2020-10-14T20:03:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 339,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAzNzA4MTI5",
      "title": "Clarify client-facing server HRR behavior",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/339",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #325.",
      "createdAt": "2020-10-14T23:22:28Z",
      "updatedAt": "2020-10-16T15:29:12Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f9eb1a5b40b3c5770b2350b499623e659286f251",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "more-hrr-behavior",
      "headRefOid": "418065c62ea780260f98d3296010f9f94b785b5a",
      "closedAt": "2020-10-16T15:29:12Z",
      "mergedAt": "2020-10-16T15:29:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a5bbe40119ebab9a12718811ba0c8120f22adc26"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A related PR that we probably should make sure flow together: https://github.com/tlswg/draft-ietf-tls-esni/pull/341",
          "createdAt": "2020-10-15T19:19:23Z",
          "updatedAt": "2020-10-15T19:19:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NjA0NzY1",
          "commit": {
            "abbreviatedOid": "5886956"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T17:21:11Z",
          "updatedAt": "2020-10-15T17:31:47Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I found this a little hard to interpret. It suggests equality of the ClientHellos themselves, which isn't what we want. It's also a little odd since CH1' and CH2' are functions of both what the client sent and what the server chose to do what in response. But it would be less enforcing an invariant on the latter and more maintaining it. WDYT about:\r\n\r\n> In case a HelloRetryRequest (HRR) is sent, the client-facing server MUST consistently accept or decline ECH between the two ClientHellos, using the same ECHConfig, and fail the handshake if this is not possible. This is achieved as follows.",
              "createdAt": "2020-10-15T17:21:11Z",
              "updatedAt": "2020-10-15T22:52:09Z"
            },
            {
              "originalPosition": 36,
              "body": "Nit: I don't think we need to add well-formed ClientECH structure to the precondition. The client-facing server is should already fail the connection with a decode_error if the extension doesn't parse.",
              "createdAt": "2020-10-15T17:22:24Z",
              "updatedAt": "2020-10-15T22:52:09Z"
            },
            {
              "originalPosition": 38,
              "body": "Does the server need to check the config identifier if it declines ECH, or just if it accepts ECH? What happens if the client and server use the trial decryption mode, where the config ID is empty and you only determine the config by using it? Perhaps this should be phrased in terms of the ECHConfig used. WDYT about:\r\n\r\n> If the client-facing server accepts ECH in response to CH1, it MUST check that the ClientECH.config_id parameter is the same between CH1 and CH2. If they differ, the server MUST abort the connection with an \"illegal_parameter\" alert. It then MUST decrypt the extension using the previously-selected ECHConfig and, if decryption fails, abort the connection with a \"decrypt_error\" alert. Note that, if the connection used the trial decryption mode with an empty ClientECH.config_id value, the server does not continue to try other configurations on decryption error.\r\n\r\nThough this means, if the server believes in trial decryption, you need to remember *both* the ECHConfig *and* whether to expect an empty or matching config_id value.\r\n\r\n(As an aside, this admits another GREASE-distinguishing active attack, and one I don't see any way of avoiding. But it only applies to connections that would naturally trip HRR.)",
              "createdAt": "2020-10-15T17:31:28Z",
              "updatedAt": "2020-10-15T22:52:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzAyMTU4",
          "commit": {
            "abbreviatedOid": "5886956"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T19:30:24Z",
          "updatedAt": "2020-10-15T19:30:25Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I like it. Replacing my paragraph with yours. (Changed \"fail the handshake\" to \"abort the handshake\".)",
              "createdAt": "2020-10-15T19:30:25Z",
              "updatedAt": "2020-10-15T22:52:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzA1MzI5",
          "commit": {
            "abbreviatedOid": "5886956"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T19:34:48Z",
          "updatedAt": "2020-10-15T19:34:48Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "A semi-related change that might make it easier to phrase this paragraph: https://github.com/davidben/draft-ietf-tls-esni/commit/f9b3aaf56b9c759c3ba3ab3dee4f99da34b2e460",
              "createdAt": "2020-10-15T19:34:48Z",
              "updatedAt": "2020-10-15T22:52:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzE4MzY0",
          "commit": {
            "abbreviatedOid": "5886956"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T19:47:57Z",
          "updatedAt": "2020-10-15T19:47:57Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "> Does the server need to check the config identifier if it declines ECH, or just if it accepts ECH?\r\n\r\nIt needs to check the config in both cases.\r\n\r\n> What happens if the client and server use the trial decryption mode, where the config ID is empty and you only determine the config by using it?\r\n\r\nI hadn't considered this case. \r\n\r\n> A semi-related change that might make it easier to phrase this paragraph: https://github.com/davidben/draft-ietf-tls-esni/commit/f9b3aaf56b9c759c3ba3ab3dee4f99da34b2e460\r\n\r\nI think this will help. Let's land that PR and then come back to this.\r\n",
              "createdAt": "2020-10-15T19:47:57Z",
              "updatedAt": "2020-10-15T22:52:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNTc4MDc5",
          "commit": {
            "abbreviatedOid": "418065c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T15:28:51Z",
          "updatedAt": "2020-10-16T15:28:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 340,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0MjkwMjQ5",
      "title": "Remove remnant of ECH PSKs and non-ECH PSKs.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/340",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This clause is a remnant of when we tried to partition the resumption space across ECH negotiation, which was simplified in #317.",
      "createdAt": "2020-10-15T18:16:38Z",
      "updatedAt": "2020-10-15T18:48:39Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f9eb1a5b40b3c5770b2350b499623e659286f251",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "psk-remnant",
      "headRefOid": "44a79be65b12a8ed2555dc93b7d6650b4ad11c08",
      "closedAt": "2020-10-15T18:48:39Z",
      "mergedAt": "2020-10-15T18:48:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "01674f4ac07fd532fd90634701d36db042235875"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NjczMDE2",
          "commit": {
            "abbreviatedOid": "44a79be"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-15T18:48:34Z",
          "updatedAt": "2020-10-15T18:48:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 341,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0MzIxNzMw",
      "title": "Fix up description of server message forwarding.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/341",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes a few issues with the  \"Upon determining the true SNI\"\r\nparagraph:\r\n\r\n- It talkes about determining the \"true SNI\", but we should probably\r\n  talk about the ClientHelloInner more generally.\r\n\r\n- It refers to behavior in \"the following section\" which no longer\r\n  matches. This is a remnant of before Shared Mode was described as a\r\n  special case of Split Mode, so remove it.\r\n\r\n- It says the server forwards messages unmodified, which isn't true. It\r\n  needs to forward the decrypted ClientHello. It also needs to process\r\n  HRR.\r\n\r\nI've cited the HRR section for the modified decryption procedure, which\r\ndoesn't really exist right now, but #339 is handling that.",
      "createdAt": "2020-10-15T19:17:49Z",
      "updatedAt": "2020-10-15T23:27:52Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "01674f4ac07fd532fd90634701d36db042235875",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "fix-forwarding",
      "headRefOid": "0f0e11b69c9ec3c16cd5c682a3d010845d2085e0",
      "closedAt": "2020-10-15T23:27:52Z",
      "mergedAt": "2020-10-15T23:27:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "17ac85d3a0a9c4a0bbb93060df0e360ede4dac3c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzI0NjMx",
          "commit": {
            "abbreviatedOid": "0f0e11b"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Yup, this aligns with my understanding!",
          "createdAt": "2020-10-15T19:51:28Z",
          "updatedAt": "2020-10-15T19:51:28Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODc2Mjcz",
          "commit": {
            "abbreviatedOid": "0f0e11b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-15T23:27:43Z",
          "updatedAt": "2020-10-15T23:27:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 343,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0OTg2OTU5",
      "title": "Pick from an unassigned range.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/343",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #322.\r\n\r\ncc @davidben, @cjpatton ",
      "createdAt": "2020-10-16T17:13:54Z",
      "updatedAt": "2020-10-16T18:57:12Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a5bbe40119ebab9a12718811ba0c8120f22adc26",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/codepoints",
      "headRefOid": "82e4c85d37e836fa82e7aaa09034694e4a586116",
      "closedAt": "2020-10-16T18:57:12Z",
      "mergedAt": "2020-10-16T18:57:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ce2cd200d039d782e60cf21e078521b273721631"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> What will be our policy if we need to add additional extension points, e.g., to address #264? Do we start incrementing from 0xfe00?\r\n\r\nYeah, that's what I figured. I doubt we'll need more than 8, but we can pick a different range if that works?",
          "createdAt": "2020-10-16T17:24:10Z",
          "updatedAt": "2020-10-16T17:24:10Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, this works for me. I don't see any reason why we should keep the code points dense.",
          "createdAt": "2020-10-16T17:27:16Z",
          "updatedAt": "2020-10-16T17:27:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjYxNDQ1",
          "commit": {
            "abbreviatedOid": "69239a2"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "What will be our policy if we need to add additional extension points, e.g., to address #264? Do we start incrementing from `0xfe00`?",
          "createdAt": "2020-10-16T17:19:23Z",
          "updatedAt": "2020-10-16T17:19:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjY5NDY5",
          "commit": {
            "abbreviatedOid": "82e4c85"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T17:31:10Z",
          "updatedAt": "2020-10-16T17:31:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjg2MzI0",
          "commit": {
            "abbreviatedOid": "82e4c85"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Sure, those work. I usually `random.randint(0, 0xffff)` to avoid thinking about it, but whatever. :-)",
          "createdAt": "2020-10-16T17:52:42Z",
          "updatedAt": "2020-10-16T17:52:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjg2NDc3",
          "commit": {
            "abbreviatedOid": "82e4c85"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T17:52:55Z",
          "updatedAt": "2020-10-16T17:52:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 344,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MDQ0NDQ5",
      "title": "Trial decryption and ECHConfig binding fixes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/344",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The spec describes an optional trial decryption mode, but most of the text contradicts it. This PR fixes the text up and tries to unify their processing models. In doing so, it flips the error handling from decrypt_error to fallback to be consistent. This, combined with the ClientHelloOuterAAD change, plugs an active sticking out attack for free. It also makes #342 easier because GREASE config_id collisions with real config_ids are now harmless.\r\n\r\nAlong the way, @chris-wood and @cjpatton observed that we're not authenticating the ECHConfig at all. (It used to be authenticated by way of the config_id, which was a digest.) Instead, just pass the ECHConfig into the info field of the HPKE context. They also noticed the server rule about PSKs on ClientHelloOuter didn't work with GREASE. Instead, we can simply remove it.",
      "createdAt": "2020-10-16T19:08:03Z",
      "updatedAt": "2020-10-16T21:39:03Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "eab2c685c1065dc6fd2b3ced5d3034f0615709f6",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "unify-trial-decrypt",
      "headRefOid": "58fa6832d95ab49505d0e65beb06530bfd385a37",
      "closedAt": "2020-10-16T21:39:03Z",
      "mergedAt": "2020-10-16T21:39:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2360040a6fdc182427d740f8a8971a255226020c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzM5MjYz",
          "commit": {
            "abbreviatedOid": "068c268"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is pretty close!",
          "createdAt": "2020-10-16T19:17:17Z",
          "updatedAt": "2020-10-16T19:36:12Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I wonder if `\\0` is the right way to right the null byte. (RFC8446 doesn't encode 0x00 in a string at all: see [RFC8446, 4.4.3](https://tools.ietf.org/html/rfc8446#section-4.4.3).) I'm fine with it as-is, since I think it's pretty clear what you mean ... I just wanted flag it in case there's a \"correct\" way to write this.",
              "createdAt": "2020-10-16T19:17:18Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            },
            {
              "originalPosition": 48,
              "body": "Let's drop \"randomly generated\"? I think this would be OK, given how client-facing server behavior is specified. But I don' think we want to put this idea in people's head as a viable option. (Yet.)",
              "createdAt": "2020-10-16T19:21:24Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            },
            {
              "originalPosition": 50,
              "body": "Suggest changing \"MUST NOT use this mode\" to \"MUST compute config_id as specified in {{whatever-section-describes-ClientECH}}\".",
              "createdAt": "2020-10-16T19:22:01Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            },
            {
              "originalPosition": 143,
              "body": "s/determined in/determined by/",
              "createdAt": "2020-10-16T19:25:51Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            },
            {
              "originalPosition": 230,
              "body": "This works for me. However, to align with the new text above, if decryption fails here then the server should ignore ECH and continue with ClientHelloOuter.",
              "createdAt": "2020-10-16T19:35:28Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA0MTE1",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:18:50Z",
          "updatedAt": "2020-10-16T21:18:50Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Tweaked the syntax a bit. I've also kept the prose at the bottom that clarifies it.",
              "createdAt": "2020-10-16T21:18:50Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA0MjE0",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:19:04Z",
          "updatedAt": "2020-10-16T21:19:04Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Oh? {{optional-configs}} has explicitly said it can be random for a while now. (GREASE prescribes a random one too.)",
              "createdAt": "2020-10-16T21:19:04Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA0MjUy",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:19:08Z",
          "updatedAt": "2020-10-16T21:19:08Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Done.",
              "createdAt": "2020-10-16T21:19:08Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA0MzA2",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:19:14Z",
          "updatedAt": "2020-10-16T21:19:15Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "Done.",
              "createdAt": "2020-10-16T21:19:15Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA0Nzc1",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:20:16Z",
          "updatedAt": "2020-10-16T21:20:17Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "I think this one needs to be a decrypt_error (which is why there's text here, to cancel the new text above). This is the second ClientHello, so the server can't switch to the outer one. Otherwise we break the invariant you set up. :-)",
              "createdAt": "2020-10-16T21:20:16Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA0OTA0",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:20:33Z",
          "updatedAt": "2020-10-16T21:20:33Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "You're right! My bad. No action needed here.",
              "createdAt": "2020-10-16T21:20:33Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA2NDAz",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:23:49Z",
          "updatedAt": "2020-10-16T21:23:49Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "s/ClientHelloOuter/ClientHelloInner/?",
              "createdAt": "2020-10-16T21:23:49Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA2NDE2",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:23:50Z",
          "updatedAt": "2020-10-16T21:23:51Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "Right again! ",
              "createdAt": "2020-10-16T21:23:50Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA2NTg1",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "One last thing to check.",
          "createdAt": "2020-10-16T21:24:13Z",
          "updatedAt": "2020-10-16T21:24:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA3OTY3",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:27:22Z",
          "updatedAt": "2020-10-16T21:27:23Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Hah! I meant to write \"decrypt the second ClientHelloOuter [into the second ClientHelloInner]\", but I guess you more naturally read it as \"decrypt the second ClientHelloInner [from the second ClientHelloOuter]\". Which means I should probably find a different wording all together. Will wordsmith.",
              "createdAt": "2020-10-16T21:27:22Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA5MDI5",
          "commit": {
            "abbreviatedOid": "58fa683"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:29:51Z",
          "updatedAt": "2020-10-16T21:29:51Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "How's this new version?",
              "createdAt": "2020-10-16T21:29:51Z",
              "updatedAt": "2020-10-16T21:29:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA5ODM4",
          "commit": {
            "abbreviatedOid": "58fa683"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:31:48Z",
          "updatedAt": "2020-10-16T21:31:48Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "LGTM!",
              "createdAt": "2020-10-16T21:31:48Z",
              "updatedAt": "2020-10-16T21:31:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODExMDU3",
          "commit": {
            "abbreviatedOid": "58fa683"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T21:34:38Z",
          "updatedAt": "2020-10-16T21:34:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODEyNzkw",
          "commit": {
            "abbreviatedOid": "58fa683"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T21:38:58Z",
          "updatedAt": "2020-10-16T21:38:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 345,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MDQ5NjQ3",
      "title": "Only extract 8 bytes for the config_id",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/345",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This doesn't bind anything, so no sense wasting bytes. Closes #342.\r\n\r\n(Note: this is orthogonal to #344, but it makes more sense with that PR.)",
      "createdAt": "2020-10-16T19:17:49Z",
      "updatedAt": "2020-11-03T20:52:43Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6e359b6dcf7e20511cf28052005151fc804037d2",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "truncate-config-id",
      "headRefOid": "0f181404a0769b8b1e24545343bc926b90d19bdd",
      "closedAt": "2020-11-03T20:52:43Z",
      "mergedAt": "2020-11-03T20:52:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7f7b61e4a7c5e1e403212e0c798de472c8b47e2a"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess this makes the text in #344 a little odd because \"Compare ClientECH.config_id against identifiers of known ECHConfigs and select *the* one that matches, if any, as a candidate.\", is a little less clear. If we want to do this, it maybe should say \"and select any that match\", even though there'll really just be one match.",
          "createdAt": "2020-10-16T19:24:24Z",
          "updatedAt": "2020-10-16T19:24:24Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Rebased and made the text talk about multiple potential matches.)",
          "createdAt": "2020-11-02T17:33:36Z",
          "updatedAt": "2020-11-02T17:33:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODU1MTM3",
          "commit": {
            "abbreviatedOid": "0f18140"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I agree this is fine.",
          "createdAt": "2020-11-03T20:35:31Z",
          "updatedAt": "2020-11-03T20:35:31Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODY1MzY2",
          "commit": {
            "abbreviatedOid": "0f18140"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-03T20:52:36Z",
          "updatedAt": "2020-11-03T20:52:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 346,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2MjQ1MzQ4",
      "title": "Fix some editorial issues",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/346",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A few editorial things that we missed before -08.",
      "createdAt": "2020-10-19T20:05:11Z",
      "updatedAt": "2020-10-20T22:15:07Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2360040a6fdc182427d740f8a8971a255226020c",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "editorial",
      "headRefOid": "c310e9677e48917034e5cedea5f46c06eaf9084a",
      "closedAt": "2020-10-20T22:15:07Z",
      "mergedAt": "2020-10-20T22:15:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "88c61a613c90090d402d8360491f95627d3a4031"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMTkxMzgx",
          "commit": {
            "abbreviatedOid": "0549ac5"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T22:01:45Z",
          "updatedAt": "2020-10-19T22:09:45Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Between #330 and #335, I spent a bit of time trying to make sure the order here was consistent throughout the document. I don't particularly care what the order is, just that it's consistent. If we change it, we'll need to adjust several things in tandem:\r\n\r\n* Line 462 (\"If it compressed any extensions in [...]\") is written assuming the other order. That'll want to read more like \"If it intends to compress any extensions [...]\" from line 455. \r\n\r\n* {{encoding-inner}} itself also needs to change. \"When sending ClientHello, the client first [...] It then computes a new value, the EncodedClientHelloInner, by [...]\" and \"The client then MAY substitute extensions which it knows will be duplicated in ClientHelloOuter\".",
              "createdAt": "2020-10-19T22:01:46Z",
              "updatedAt": "2020-10-20T22:14:39Z"
            },
            {
              "originalPosition": 48,
              "body": "\"at least one of the values\" doesn't work with the use of \"that value\" later on in the paragraph. The wording should probably align with the first paragraph of {{send-ech}}.",
              "createdAt": "2020-10-19T22:09:20Z",
              "updatedAt": "2020-10-20T22:14:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMTk5OTEy",
          "commit": {
            "abbreviatedOid": "0549ac5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T22:18:42Z",
          "updatedAt": "2020-10-19T22:18:43Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Reverted. (Apologies for stepping on your toes here, I had forgotten there was a particular order.)",
              "createdAt": "2020-10-19T22:18:42Z",
              "updatedAt": "2020-10-20T22:14:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjA3OTEy",
          "commit": {
            "abbreviatedOid": "0549ac5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T22:35:35Z",
          "updatedAt": "2020-10-19T22:35:35Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Updated the text here to clarify that the client is meant to retry with retry configurations supplied by the server. I also updated the first paragraph of {{send-ech}} to clarify that a \"supported configuration\" is one for which `ECHConfig.version` indicates a version of ECH known to the client.",
              "createdAt": "2020-10-19T22:35:35Z",
              "updatedAt": "2020-10-20T22:14:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTczMTAz",
          "commit": {
            "abbreviatedOid": "f86e1cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T22:11:53Z",
          "updatedAt": "2020-10-20T22:13:07Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nthe cipher suite it will use for encryption. It MUST NOT choose a cipher suite\r\nor version not advertised by the configuration.\r\n```",
              "createdAt": "2020-10-20T22:11:53Z",
              "updatedAt": "2020-10-20T22:14:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 347,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2Mjc0MDkw",
      "title": "Fix ServerHello.random behavior in older TLS versions.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/347",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As written, the backend server performs this ServerHello.random modification unconditionally when it sees an empty ECH extension. Although the client is required to only offer TLS 1.3, the backend server doesn't check this.\r\n\r\nHowever, as noted elsewhere in the document, these same 8 bytes are used for the TLS 1.3 downgrade protection mechanism. That mechanism only works if the server *never* produces a TLS 1.2 ServerKeyExchange signature without the signal, so it's important that the server *not* signal ECH acceptance. Write this down.",
      "createdAt": "2020-10-19T21:00:23Z",
      "updatedAt": "2020-10-20T22:15:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2360040a6fdc182427d740f8a8971a255226020c",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "server-random-clarify",
      "headRefOid": "d0deb8d3b4e3c25229a0ffb924de2aa2f32dde5e",
      "closedAt": "2020-10-20T22:15:22Z",
      "mergedAt": "2020-10-20T22:15:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6e359b6dcf7e20511cf28052005151fc804037d2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjEzMDkz",
          "commit": {
            "abbreviatedOid": "d0deb8d"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Yup, this is a good idea.",
          "createdAt": "2020-10-19T22:48:05Z",
          "updatedAt": "2020-10-19T22:48:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTc0Nzg2",
          "commit": {
            "abbreviatedOid": "d0deb8d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Oops. Good catch!",
          "createdAt": "2020-10-20T22:15:16Z",
          "updatedAt": "2020-10-20T22:15:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 350,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3NzAwODU3",
      "title": "Clarify client and server roles",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/350",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #348.\r\n\r\nWhether the client offers ECH or sends GREASE ECH depends on whether it\r\ncan find a suitable ECH config. Whether the server acts like the\r\nclient-facing server or the backend server depends on whether it has\r\ncustody of a set of ECH configs. This change clarifies these decision\r\nmaking processes.\r\n\r\nAs a bonus, this change also cleans up the section titles and levels a bit.",
      "createdAt": "2020-10-21T16:34:41Z",
      "updatedAt": "2020-11-03T21:03:42Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6e359b6dcf7e20511cf28052005151fc804037d2",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "client-server-roles",
      "headRefOid": "b9aa266c7531e0db9c82c25bce99ec59230925d8",
      "closedAt": "2020-11-03T21:03:42Z",
      "mergedAt": "2020-11-03T21:03:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "384dc60929a56d5f743e1345ac5438a6607a19fc"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "{{encrypted-client-hello}} now stipulates that the ECH payload may be empty.",
          "createdAt": "2020-10-21T19:01:42Z",
          "updatedAt": "2020-10-21T19:01:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben, can you please have another look?",
          "createdAt": "2020-10-27T23:20:08Z",
          "updatedAt": "2020-10-27T23:20:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDI4Njk2",
          "commit": {
            "abbreviatedOid": "32dc3ee"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This PR is good, but I don't think it fully addresses the issue. *Syntactically* the spec doesn't even support the behavior we want. I think we should say when defining the extension that it can be *either* empty or a ClientECH structure, and then define handling for both. Otherwise we'll trip decode_errors before we get far enough.",
          "createdAt": "2020-10-21T17:52:28Z",
          "updatedAt": "2020-10-21T18:00:32Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Nit: To be less opinionated as to purpose (I see it as a general anti-ossification strategy), perhaps:\r\n\r\nClients doing the latter do not offer to negotiate ECH. Instead, they send a dummy ECH extension to reduce ossification in the ecosystem.",
              "createdAt": "2020-10-21T17:52:28Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 109,
              "body": "s/If not/If no/",
              "createdAt": "2020-10-21T17:53:03Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 177,
              "body": "Not sure the last two sentences are right. Even if it has ECH configs, it might still act as a backend server if it sees an empty ECH extension (which we need text for).",
              "createdAt": "2020-10-21T17:58:26Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDg2MTU0",
          "commit": {
            "abbreviatedOid": "32dc3ee"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-21T18:56:22Z",
          "updatedAt": "2020-10-21T18:56:23Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Yours is also opinionated, I think. Changed to: \"Clients of the latter type do not negotiate ECH. Instead, they generate a dummy ECH extension that is ignored by the server.\"",
              "createdAt": "2020-10-21T18:56:22Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDg5NTg2",
          "commit": {
            "abbreviatedOid": "32dc3ee"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-21T19:00:06Z",
          "updatedAt": "2020-10-21T19:00:07Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "The first paragraph of {{client-facing-server}} says the client-facing server behaves as described in {{backend-server}} if the ECH extension is empty.",
              "createdAt": "2020-10-21T19:00:07Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MDkwODM1",
          "commit": {
            "abbreviatedOid": "1fb1045"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T19:54:58Z",
          "updatedAt": "2020-10-27T20:00:53Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "```suggestion\r\nif it is in possession of a compatible ECH configuration and sends GREASE ECH\r\n```",
              "createdAt": "2020-10-27T19:54:58Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nor version not advertised by the configuration. If no compatible configuration is\r\n```",
              "createdAt": "2020-10-27T19:55:53Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 177,
              "body": "Perhaps we can clarify?\r\n\r\n```suggestion\r\nOtherwise, if the server does not have a set of ECH configurations, or if the \r\n`ClientECH` extension is empty, the server plays the role of the backend server.\r\n```",
              "createdAt": "2020-10-27T19:58:21Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 203,
              "body": "```suggestion\r\nfollows.\r\n```",
              "createdAt": "2020-10-27T19:58:53Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 259,
              "body": "```suggestion\r\nfollows.\r\n```",
              "createdAt": "2020-10-27T19:59:35Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjE2NDYx",
          "commit": {
            "abbreviatedOid": "328c528"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T23:09:33Z",
          "updatedAt": "2020-10-27T23:09:33Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "Changed to \"as described in this section\".",
              "createdAt": "2020-10-27T23:09:33Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjE4MTE2",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T23:13:47Z",
          "updatedAt": "2020-10-27T23:13:48Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "Changed to \"as described in this section\".",
              "createdAt": "2020-10-27T23:13:48Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjIwMzk1",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This LGTM!",
          "createdAt": "2020-10-27T23:19:51Z",
          "updatedAt": "2020-10-27T23:19:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODk4ODk1",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T18:38:52Z",
          "updatedAt": "2020-11-02T19:01:58Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Maybe \"true server name\"? \"Backend server\" means something in the context of the server deployment, but I think we usually talk about the \"true server name\" elsewhere for the client. (Maybe want to check me on this, I just sampled a few bits of the text unscientifically.)",
              "createdAt": "2020-11-02T18:38:52Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 192,
              "body": "This paragraph still reads strangely. We're saying:\r\n\r\n- The server is a client-facing server if it has ECH configs\r\n- Otherwise [i.e. if it does not have ECH configs], if it does not have ECH configs or if the ClientECH extension is empty, the server is a backend server.\r\n\r\nThe use of \"Otherwise\" contradicts the text immediately after it.\r\n\r\nHow about keying it on the client extension instead? That way we don't need to restate all the decryption logic and include a jump between sections. Something like this...\r\n\r\n> Servers that that implement the ECH extension play one of two roles, depending on the form of the ECH extension in the ClientHello. If the extension value is non-empty, the server acts as a client-facing server and proceeds as described in {{client-facing-server}} to extract a ClientHelloInner if available.  If the extension value is empty, the server acts as a backend server and proceeds as described in {{backend-server}}.\r\n\r\nFrom there I think we can revert most of the changes at the start of {{client-facing-server}}, and just stick the adjective \"non-empty\" in the first sentence. {{backend-server}} probably wants to just use your second paragraph, and maybe clarify that the backend server just runs this logic unconditionally, so a potential client-facing server (the client may have just sent an empty ECH extension for no reason) and backend don't need to communicate much.",
              "createdAt": "2020-11-02T18:47:55Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 170,
              "body": "I don't particularly care which one we do, but we should be consistent about whether we're spelling out messages With Separate Words, or MatchingTheMessageName. In particular, I think you requested {{encoding-inner}} and {{authenticating-outer}} be written as \"Encoding the ClientHelloInner\" and \"Authenticating the ClientHelloOuter\". Whatever we do, those  should match.\r\n\r\n(FWIW, I think MatchingTheMessageName is the tidiest, though RFC8446 does it With Separate Words.)",
              "createdAt": "2020-11-02T18:59:29Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 249,
              "body": "Point 1 in this section also doesn't really account for empty vs non-empty extensions. (Which is why I was pondering if we should just use a separate codepoint. Although #352 simplifies this anyway, so we could also leave it alone and fix it separately. But in that case maybe we should leave #348 open. This PR is currently set to close it.)",
              "createdAt": "2020-11-02T19:01:42Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTI4MjQ0",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:23:44Z",
          "updatedAt": "2020-11-02T19:23:45Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Good catch. We're kinda inconsistent about this, I think, but I'll change it to \"true server name\".",
              "createdAt": "2020-11-02T19:23:44Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTM1Njg2",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:35:07Z",
          "updatedAt": "2020-11-02T19:35:07Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Changed to \"Handling HelloRetryRequest\", here and below.",
              "createdAt": "2020-11-02T19:35:07Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTM4NDEy",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:39:19Z",
          "updatedAt": "2020-11-02T19:39:19Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "Let's leave the issue open. (I changed the top comment above to reflect this.)",
              "createdAt": "2020-11-02T19:39:19Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTQxMTY2",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:43:48Z",
          "updatedAt": "2020-11-02T19:43:48Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Good idea. Although I'm not sure what you mean here:\r\n> {{backend-server}} probably wants to just use your second paragraph, and maybe clarify that the backend server just runs this logic unconditionally, so a potential client-facing server (the client may have just sent an empty ECH extension for no reason) and backend don't need to communicate much.\r\n\r\nI updated the first paragraph of {{server-behavior}} with your suggestion and revised {{client-facing-server}} and {{backend-server}} so that the former applies only to non-empty values and the latter applies only to empty values.",
              "createdAt": "2020-11-02T19:43:48Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTUxMTMw",
          "commit": {
            "abbreviatedOid": "b9aa266"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:59:05Z",
          "updatedAt": "2020-11-02T19:59:05Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "SGTM.",
              "createdAt": "2020-11-02T19:59:05Z",
              "updatedAt": "2020-11-02T19:59:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTUxMzc1",
          "commit": {
            "abbreviatedOid": "b9aa266"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:59:26Z",
          "updatedAt": "2020-11-02T19:59:27Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "(Oh, apparently I can't mark threads as resolved. Feel free to close this out.)",
              "createdAt": "2020-11-02T19:59:26Z",
              "updatedAt": "2020-11-02T19:59:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMDEwNDcz",
          "commit": {
            "abbreviatedOid": "b9aa266"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T21:36:48Z",
          "updatedAt": "2020-11-02T21:36:49Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Oh, that was a far too complicated suggestion on my part as to how to revise that text. Yours works too. :-)\r\n\r\nThe bit about \"maybe clarify that [...]\" was that we could optionally add something to the effect of:\r\n\r\n> The backend server confirms acceptance based solely on the presence of an empty \"encrypted_client_hello\" extension. This allows the ECH negotiation to complete in Split Mode with minimal coordination between the client-facing server and backend server. Note, however, if the backend server is directly accessible to clients, it is possible for a client to send an empty \"encrypted_client_hello\" extension without a client-facing server decrypting a ClientHelloInner. The backend server will confirm acceptance in this case too.\r\n\r\n(@dmcardle since we were talking about this odd implication of the ECH acceptance signal today.)",
              "createdAt": "2020-11-02T21:36:49Z",
              "updatedAt": "2020-11-02T21:36:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMDEwOTY4",
          "commit": {
            "abbreviatedOid": "b9aa266"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-02T21:37:43Z",
          "updatedAt": "2020-11-02T21:37:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODcwMDA0",
          "commit": {
            "abbreviatedOid": "b9aa266"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-03T20:59:45Z",
          "updatedAt": "2020-11-03T20:59:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 351,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyNzMyMDgx",
      "title": "Rearrange the server HRR text.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/351",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Now that we have separate client HRR and server HRR sections, move some\r\nserver text to the server section. Also clarify that the second\r\nClientHelloOuterAAD is computed from the second ClientHelloOuter, not\r\nreusing the first value.\r\n\r\n(Some cleanup in advance of writing up the HPKE context reuse version.)",
      "createdAt": "2020-10-30T03:23:49Z",
      "updatedAt": "2020-11-03T20:53:55Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6e359b6dcf7e20511cf28052005151fc804037d2",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "hrr-server-fixup",
      "headRefOid": "f4808ac2f3e75eff57fa5c9e300a438d4ff7d964",
      "closedAt": "2020-11-03T20:53:55Z",
      "mergedAt": "2020-11-03T20:53:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "30ee958bfeb419cf8dffc1d3849c206d40ec6c2b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODUzNjc2",
          "commit": {
            "abbreviatedOid": "f4808ac"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Can we merge this? The number of PRs is getting confusing.\r\n\r\n@chris-wood ",
          "createdAt": "2020-11-03T20:33:11Z",
          "updatedAt": "2020-11-03T20:33:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODY2MTU4",
          "commit": {
            "abbreviatedOid": "f4808ac"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-03T20:53:51Z",
          "updatedAt": "2020-11-03T20:53:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 352,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyNzUyNTg0",
      "title": "Use the same HPKE context between the two ClientHellos",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/352",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(Note: this PR sits on top of #351, though hopefully the combined diff is also readable enough.)\r\n\r\nCloses #349. This achieves the same security properties of ech_hrr_key, but gives us a few improvements:\r\n\r\n- Client-facing servers that offload their HPKE operations to RPCs do not need to worry about race conditions with rotation between the two ClientHellos. (See #325.)\r\n\r\n- We only perform one addition asymmetric operation with ECH, rather than sometimes two. For servers with offloaded ECH keys, this also avoids an extra RPC call.\r\n\r\n- HPKE implementations for ECH only need SetupBase* and not SetupPSK*.\r\n\r\n- The description of HRR handling in general can be greatly simplified. Rather than running the server's CH1 algorithm with various modifications, we can just write a straightforward, simpler algorithm.\r\n\r\nThis PR also adds some missing text for GREASE on HRR, which closes #356. (Although it's worth noting that HRR connections can be easily distinguished by an active attacker anyway. This PR doesn't change this, but makes it much clearer.)",
      "createdAt": "2020-10-30T04:39:21Z",
      "updatedAt": "2020-11-17T23:21:01Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3b2b8cd7e8c10fadcd79e087238d67e44048584f",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "hrr-reuse-context",
      "headRefOid": "c2b52617755b87ec401f67d68d9d2d6cc44f0d2b",
      "closedAt": "2020-11-17T23:21:00Z",
      "mergedAt": "2020-11-17T23:21:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9f485e939b99814f9a73c1e94ec5e44f0a8d4806"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is much simpler, but, if I understand it correctly, I think it *might* be a little bit of a regression. The previous export-then-inject design forced the server to process both ECH configs and encapsulated keys in both CH1 and CH2, whereas here the server just ignores those in CH2 and uses the values from CH1. That lets clients change these fields in CH2 without any effect. Now, I don't really know of anything that *could* go wrong here, but it smells like the sort of \"insufficient binding\" problem we've continually run into before. (For example, I think an on-path attacker could modify the `enc` or `config_id` fields in CH2, without touching anything else. Decryption would succeed, as the server used CH1's `enc` value, and the transcript is unaffected since the server would choose the CH inner value. Is that a way for an on-path attacker to quickly check if the connection is real or fake ECH?)\r\n\r\nChris asked if we should require servers to verify these match, and as you pointed out, that's a mess. (We also acknowledged that servers missing these checks is something we should expect to happen in the wild, which is somewhat why we are concerned about this re-binding attack in the first place.)\r\n\r\nI wonder if we can solve this in a different way: [put these ECH extension fields in the AAD](https://github.com/tlswg/draft-ietf-tls-esni/issues/326). That would prevent the modification above, I think, and shouldn't be *too* bad in terms of additional complexity.",
          "createdAt": "2020-11-04T01:08:50Z",
          "updatedAt": "2020-11-04T01:08:50Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This is much simpler, but, if I understand it correctly, I think it might be a little bit of a regression. The previous export-then-inject design forced the server to process both ECH configs and encapsulated keys in both CH1 and CH2, whereas here the server just ignores those in CH2 and uses the values from CH1. That lets clients change these fields in CH2 without any effect. Now, I don't really know of anything that could go wrong here, but it smells like the sort of \"insufficient binding\" problem we've continually run into before.\r\n\r\nI think allowing the actual client to change ignored fields is a general property of HelloRetryRequest. Because we don't expect servers to check consistency between CH1 and CH2, a client that goes out of their way to send something inconsistent may find that their (CH1, CH2) tuple is interpreted ambiguously. But the transcript reflects the whole tuple, so, as far as the handshake itself, the client is just causing its own preferences to be misrepresented here.\r\n\r\nIdeally ambiguous things would be unrepresentable and consistently treated as errors but HRR is what it is. :-/\r\n\r\n> (For example, I think an on-path attacker could modify the enc or config_id fields in CH2, without touching anything else. Decryption would succeed, as the server used CH1's enc value, and the transcript is unaffected since the server would choose the CH inner value. Is that a way for an on-path attacker to quickly check if the connection is real or fake ECH?)\r\n\r\nI think real vs. fake ECH on HRR connections is entirely hopeless, short of completely redoing HRR. If CH1 uses ECH, we need to require CH2 also use ECH. That means ECH decryption failures in CH2 are fatal, and you can distinguish the two by simply replaying CH1 and perturbing the ciphertext in CH2. (That said, note that CHOuterAAD means whether a ClientHello triggers HRR is not under attacker control. So if a client/server pair doesn't trigger HRR, the attacker can't try to do this.)\r\n\r\nThat said, I think there's a variant of this on CH1 in the optional config_id mode. (See below.)\r\n\r\n> Chris asked if we should require servers to verify these match, and as you pointed out, that's a mess. (We also acknowledged that servers missing these checks is something we should expect to happen in the wild, which is somewhat why we are concerned about this re-binding attack in the first place.)\r\n\r\nYeah, this is the \"I think we got HRR wrong and have to live with it\" problem. :-)\r\n\r\n> I wonder if we can solve this in a different way: put these ECH extension fields in the AAD. That would prevent the modification above, I think, and shouldn't be too bad in terms of additional complexity.\r\n\r\nI don't think I believe this matters for HRR (only attack I can see is real vs fake ECH, which is hopeless with HRR anyway), but now that you mention it, I think there *is* a variant of this for the optional config_id mode in the non-HRR case.\r\n\r\nIn CH1, we don't bind config_id, enc, and cipher_suite to the encryption, so a priori an attacker might be able to perturb them without breaking the decryption. Perturbing enc and cipher_suite seems likely to break decryption anyway, but config_id is interesting. In the normal mode, it too will break decryption. In the optional config_id mode, config_id is just a placeholder. That means an attacker can distinguish optional config_id ECH from {GREASE or config_id ECH} by flipping the config_id, sending it to the server, and seeing if the client can decrypt the result.\r\n\r\n(Of course, all this is relative to an unclear and undefined \"don't stick out\" model.)\r\n\r\nComplexity-wise, I think it's fine, but note it changes the processing order somewhat interestingly, both for the spec and implementations. Right now the spec says:\r\n\r\n1. Make your CHInner. This should largely be running through your usual CH assembly logic.\r\n2. Encode it with the extensions you expect to compress.\r\n3. Make your CHOuter, minus the ECH extension. This should largely run through your existing CH assembly logic and computes CHOuterAAD.\r\n4. Take EncodedCHInner and CHOuterAAD and run through the Deserialize, SetupBaseS, context.Seal logic to assemble the final CHOuter.\r\n\r\nIn order to put these fields in AAD, we'd need to say:\r\n\r\n1. Make your CHInner. This should largely be running through your usual CH assembly logic.\r\n2. Encode it with the extensions you expect to compress.\r\n3. Make your CHOuter, minus the ECH extension. This should largely run through your existing CH assembly logic.\r\n4. Run Deserialize and SetupBaseS.\r\n5. Compute CHOuterAAD with half an ECH extension.\r\n6. Take EncodedCHInner and CHOuterAAD and run through the context.Seal logic to assemble the final CHOuter.",
          "createdAt": "2020-11-04T16:10:11Z",
          "updatedAt": "2020-11-04T16:16:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In CH1, we don't bind config_id, enc, and cipher_suite to the encryption, so a priori an attacker might be able to perturb them without breaking the decryption. Perturbing enc and cipher_suite seems likely to break decryption anyway, but config_id is interesting. In the normal mode, it too will break decryption. In the optional config_id mode, config_id is just a placeholder. That means an attacker can distinguish optional config_id ECH from {GREASE or config_id ECH} by flipping the config_id, sending it to the server, and seeing if the client can decrypt the result.\r\n\r\nA similar \"don't stick out\" distinguisher: Flip a bit of ClientECH.payload in CH2. The client-facing server will abort with \"decrypt_error\" if real-ECH is in use but not if grease-ECH is in use. This attack is unavoidable if we want to ensure that the server doesn't change from CHInner to CHOuter across the HRR. (Enforcing this invariant seems like a good idea to me.)\r\n\r\n> In order to put these fields in AAD, we'd need to say:\r\n> -    Make your CHInner. This should largely be running through your usual CH assembly logic.\r\n> -    Encode it with the extensions you expect to compress.\r\n> -    Make your CHOuter, minus the ECH extension. This should largely run through your existing CH assembly logic.\r\n> -    Run Deserialize and SetupBaseS.\r\n> -    Compute CHOuterAAD with half an ECH extension.\r\n> -    Take EncodedCHInner and CHOuterAAD and run through the context.Seal logic to assemble the final CHOuter.\r\n\r\nThis seems like a sensible idea, although I'm not super concerned about the \"don't stick out\" attack it mitigates. I would vote we land this change as-is and follow up with a new PR.",
          "createdAt": "2020-11-04T19:09:02Z",
          "updatedAt": "2020-11-04T19:22:46Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, I mentioned that HRR attack above. ( \"I think real vs. fake ECH on HRR connections is entirely hopeless [...]\".)\r\n\r\nSince avoiding this is hopeless in HRR, I don't think we should use it as a justification for binding bits of CH2's ClientECH or checking they match (which don't actually do the same thing). Whereas attacks on CH1 are interesting because that situation is less obviously hopeless. So maybe we want to add more things to CHOuterAAD for that, though that is orthogonal to this PR, so I think we should deal with it separately. (CHOuterAAD was originally intended to fix the ClientHello malleability attack, in a way that avoids burning 32 bytes on an inner_digest.)",
          "createdAt": "2020-11-04T19:22:43Z",
          "updatedAt": "2020-11-04T19:23:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed. (I was in the middle of editing my comment above to say the same thing when I saw your message!)",
          "createdAt": "2020-11-04T19:24:01Z",
          "updatedAt": "2020-11-04T19:24:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ">This attack is unavoidable if we want to ensure that the server doesn't change from CHInner to CHOuter across the HRR. \r\n\r\nYeah, this morning I came to the conclusion that mitigating this sort of distinguisher for HRR was not really possible unless we relax the inner/outer matching invariant. I'm fine pursuing more AAD as a separate change on top of this, since it's strictly an improvement (and HRR is hopeless).",
          "createdAt": "2020-11-04T19:31:00Z",
          "updatedAt": "2020-11-04T19:31:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben can you please resolve conflicts?",
          "createdAt": "2020-11-04T19:31:09Z",
          "updatedAt": "2020-11-04T19:31:09Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased.",
          "createdAt": "2020-11-04T19:46:46Z",
          "updatedAt": "2020-11-04T19:46:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzcyNjEw",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-30T04:40:04Z",
          "updatedAt": "2020-10-30T04:40:04Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "This fields also don't matter. I wonder if we should say you empty them instead...\r\n\r\n(Insert usual remark that I think we got HelloRetryRequest wrong. :-) )",
              "createdAt": "2020-10-30T04:40:04Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMDMxNjgx",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-30T20:57:47Z",
          "updatedAt": "2020-10-30T20:57:48Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Self-review: \"After sending a HelloRetryRequest\" is slightly odd because, on ECH accept, the client-facing server forwards the HRR from the backend server. At the same time, this section also talks about ECH reject, since we want to clarify that you don't process ECH on the second ClientHello as usual.\r\n\r\nPerhaps: \"After sending or forwarding a HelloRetryRequest\"?",
              "createdAt": "2020-10-30T20:57:48Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODM5MDk5",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T17:17:37Z",
          "updatedAt": "2020-11-02T17:17:38Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "They need to be present in order for stateless-HRR servers to correctly re-compute the HPKE context, right? Incidentally, how do stateless-HRR servers correctly compute the nonce? The sequence number changes after HRR.\r\n\r\nPerhaps this PR should stipulate that (some representation of) the HPKE context ought to appear in the \"cooke\".",
              "createdAt": "2020-11-02T17:17:37Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODQ3NjM5",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T17:28:04Z",
          "updatedAt": "2020-11-02T17:28:04Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Stateless-HRR servers don't work at all right now anyway (#333), so we can't really talk about what goes in the cookie because there's no way for the client-facing server to contribute to the cookie right now. When we do, yes, we should say something about this. (See also https://github.com/tlswg/draft-ietf-tls-esni/issues/349#issuecomment-713724970)\r\n\r\nAs to what the stateless-HRR server needs, it needs to store *something* that allows it to recreate the HPKE context on the second ClientHello. Things that would work:\r\n\r\n* Store the HPKE encryption key, nonce, and sequence number. (Alternatively, know the sequence number is always 1...)\r\n* Store the client `enc` value and sequence number (or assume 1), and some handle to the ECHConfig private key, so it can recreate the HPKE context and fast-forward the context to the right sequence number.\r\n* Store a hash of the client `enc` value, check it matches, and then do as above.\r\n\r\nOnly the last of these actually needs the client to send `enc` again. Note what would not work great is blindly recomputing the `enc` value, given {{flow-hrr-hijack}}. Given #325, my inclination is the first option is most straightforward anyway.",
              "createdAt": "2020-11-02T17:28:04Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODY2Nzc4",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T17:53:22Z",
          "updatedAt": "2020-11-02T17:53:22Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "> Stateless-HRR servers don't work at all right now anyway (#333), so we can't really talk about what goes in the cookie because there's no way for the client-facing server to contribute to the cookie right now.\r\n\r\nIsn't this only true for Split Mode / stateless-HRR? \r\n",
              "createdAt": "2020-11-02T17:53:22Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODc2NDE3",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T18:06:49Z",
          "updatedAt": "2020-11-02T18:06:49Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "That sounds good to me.",
              "createdAt": "2020-11-02T18:06:49Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODg1Mjgy",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T18:19:21Z",
          "updatedAt": "2020-11-02T18:19:22Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "As long as \"cipher_suite\", \"config_id\", \"enc\" are retransmitted in CH2, should the server verify that they don't change?",
              "createdAt": "2020-11-02T18:19:21Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTE4MDQ1",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:07:35Z",
          "updatedAt": "2020-11-02T19:07:35Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "It's true for both. There's no text supporting Shared Mode / stateless-HRR right now because Shared Mode is treated as a special-case of Split Mode. It's \"obvious\" what they're supposed to do, but without any text to support it, we can't talk about what goes in the cookie.\r\n\r\nAs part of #333, we'll need to address all of that. In the meantime, this PR doesn't change things because we already have no text talking about how ech_hrr_key goes in the cookie. All of that is #333.",
              "createdAt": "2020-11-02T19:07:35Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTE5Mzg0",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:09:47Z",
          "updatedAt": "2020-11-02T19:09:47Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "Checking CH1 and CH2 consistency is a huge mess to do. We completely got the design of HRR wrong in RFC8446, and it's too late to do anything about that now. Rather than expend a whole lot of energy on everyone's part, from spec text to implementations to constantly having this discussion, I'd rather we follow RFC8446's example here and leave it alone.",
              "createdAt": "2020-11-02T19:09:47Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTIzNjQy",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:16:29Z",
          "updatedAt": "2020-11-02T19:16:29Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "That is, RFC8446 is already quite restrictive about CH1/CH2 consistency, yet servers are not required to (and in practice do not) check consistency for much, if any, of it.\r\nhttps://tools.ietf.org/html/rfc8446#section-4.1.2\r\n\r\nIndeed if you think about what a server would need to do here, it's clear we just got the design wrong. A server that is capable of checking some individual field most likely stored the value of the field, in which case there was no reason for the client to re-send it in the first place! (This grew organically from an earlier design where the server actually reconstructed CH1 from CH2, but that had all kinds of attacks and was generally a mess. When we dropped that, we probably should have stopped to reevaluate it. Oh well.)",
              "createdAt": "2020-11-02T19:16:29Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTQxNzg5",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:44:44Z",
          "updatedAt": "2020-11-02T19:44:45Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Ack. You can resolve this comment.",
              "createdAt": "2020-11-02T19:44:44Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODczNTcy",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This seems generally good. I'm not sure why we didn't do this in the first place. Are reusable contexts new?",
          "createdAt": "2020-11-03T21:05:32Z",
          "updatedAt": "2020-11-03T21:06:56Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "This seems like it's orthogonal, right?",
              "createdAt": "2020-11-03T21:05:33Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODg3NDkw",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-03T21:28:57Z",
          "updatedAt": "2020-11-03T21:28:57Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "Well, the question is whether we mandate the server check the redundant fields. I think my default is to prefer matching rfc8446 in not saying much. (With a side of grumpiness about how weird HRR is. :-) ) We probably need to do a better job describing HRR in rfc8446bis. I figure the less other specs say about it, the more room we have to figure out what we actually want to require.",
              "createdAt": "2020-11-03T21:28:57Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTY4NTk3",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T00:31:36Z",
          "updatedAt": "2020-11-04T13:38:51Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "```suggestion\r\nAfter sending or forwarding a HelloRetryRequest, the client-facing server does not repeat the\r\n```",
              "createdAt": "2020-11-04T00:31:37Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            },
            {
              "originalPosition": 140,
              "body": "(Assuming this is what you meant...)\r\n\r\n```suggestion\r\ncontinues with the ECHConfig selection from the first ClientHelloOuter as follows:\r\n```",
              "createdAt": "2020-11-04T00:40:38Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            },
            {
              "originalPosition": 165,
              "body": "```suggestion\r\nproceeds with the connection as usual, without decrypting the new\r\n```",
              "createdAt": "2020-11-04T00:48:58Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTE2NTU5",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T16:15:12Z",
          "updatedAt": "2020-11-04T16:15:12Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Hrm. I wrote \"any\" so that this text also works for the no ECH extension case and the \"if any\" version had lots of clauses and commas. :-)\r\n\r\n> If the client-facing server rejected ECH, or if the first ClientHello did not\r\n> include an \"encrypted_client_hello\" extension, the client-facing server\r\n> proceeds with the connection as usual, without decrypting the new\r\n> ClientECH.payload value, if any.\r\n\r\nGiven that, are you happy with \"any new ClientECH.payload value\"? Or do you prefer \", if any\" or maybe some other wording altogether?",
              "createdAt": "2020-11-04T16:15:12Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTMwMDM4",
          "commit": {
            "abbreviatedOid": "3790580"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T16:29:04Z",
          "updatedAt": "2020-11-04T16:29:05Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "\"Any\" to me implied \"possibly one of the many new values,\" but the CH only has one value.",
              "createdAt": "2020-11-04T16:29:05Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTYwNDIz",
          "commit": {
            "abbreviatedOid": "3790580"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T17:02:18Z",
          "updatedAt": "2020-11-04T17:02:19Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Hehe. I read \"any ClientECH.payload value [singular]\" to mean zero or one, but maybe that's not the right way to use that word. :-)\r\n\r\nHow about:\r\n\r\n> If the client-facing server rejected ECH, or if the first ClientHello did not\r\n> include an \"encrypted_client_hello\" extension, the client-facing server\r\n> proceeds with the connection as usual. The server does not decrypt the\r\n> second ClientHello's ClientECH.payload value, if one was included.",
              "createdAt": "2020-11-04T17:02:18Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTY2MTEz",
          "commit": {
            "abbreviatedOid": "3790580"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T17:08:55Z",
          "updatedAt": "2020-11-04T17:08:55Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Perfect!",
              "createdAt": "2020-11-04T17:08:55Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjI1NTM1",
          "commit": {
            "abbreviatedOid": "d1db526"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T18:25:12Z",
          "updatedAt": "2020-11-04T18:25:13Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Reworded.",
              "createdAt": "2020-11-04T18:25:12Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjY4MjM0",
          "commit": {
            "abbreviatedOid": "d1db526"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-04T19:24:49Z",
          "updatedAt": "2020-11-04T19:24:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MzE0ODgy",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-06T16:36:55Z",
          "updatedAt": "2020-11-06T16:36:55Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Unresolving this since we only resolved @cjpatton's clarification question, not the actual issue.\r\n\r\nThinking about this some more, I think we actually should require `enc` be empty on CH2. The reason is, of the three stateless implementation options listed above, only the first one is robust. The second and third rely on the server performing a check that, if they forget, still interops. But if they forget the check, {{flow-hrr-hijack}} applies again. Given @cjpatton's question, I also suspect this mistake is reasonably likely.\r\n\r\nClearing `enc` forces servers to pick the first option, which is the more robust one. We're also guaranteed that a server, stateful or stateless, does not need `enc` (or `cipher_suite`) because you need to process ECH on CH1 regardless. Thus, I propose:\r\n\r\n* CH2's `enc` MUST be empty. Servers check this when parsing (now that it's empty rather than copied over, it's easy).\r\n* CH2's  `cipher_suite` MUST be {copied over, zero; not sure which}. Servers check this one too, just because it's really easy.\r\n\r\nEven more minimal would be if CH2's extension contained `payload` and nothing else, but we don't have any precedent for extension syntaxes varying between CH1 and CH2, so probably we shouldn't go down that route.\r\n\r\n@ekr, I'm curious what your thoughts on this are.",
              "createdAt": "2020-11-06T16:36:55Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MzI1NTYz",
          "commit": {
            "abbreviatedOid": "b4137af"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-06T16:50:35Z",
          "updatedAt": "2020-11-06T16:50:35Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Oh same probably goes for `config_id` in CH2. Force the server to use the same ECHConfig rather than accidentally swapping it. (Except it's not really using the ECHConfig since it's just reusing the HPKE context and not worrying about it.)",
              "createdAt": "2020-11-06T16:50:35Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NTAxNDE3",
          "commit": {
            "abbreviatedOid": "c2b5261"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-06T21:21:43Z",
          "updatedAt": "2020-11-06T21:21:43Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "I have no idea when we use quotation marks or backticks, but we seem to use backticks when referring to ClientECH fields?",
              "createdAt": "2020-11-06T21:21:43Z",
              "updatedAt": "2020-11-06T21:21:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NTAxNjg1",
          "commit": {
            "abbreviatedOid": "c2b5261"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-06T21:22:13Z",
          "updatedAt": "2020-11-06T21:22:13Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "(Updated the PR with this version.)",
              "createdAt": "2020-11-06T21:22:13Z",
              "updatedAt": "2020-11-06T21:22:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NTAxODcx",
          "commit": {
            "abbreviatedOid": "c2b5261"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-06T21:22:36Z",
          "updatedAt": "2020-11-06T21:22:37Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "(Supposing we go with https://github.com/tlswg/draft-ietf-tls-esni/pull/352#discussion_r518868173, the redundant fields are gone and this is moot.)",
              "createdAt": "2020-11-06T21:22:36Z",
              "updatedAt": "2020-11-06T21:22:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjQ2NDQ4",
          "commit": {
            "abbreviatedOid": "c2b5261"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T22:06:51Z",
          "updatedAt": "2020-11-10T22:06:52Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "I've been going with backticks for structures and their fields and quotes for extension names.",
              "createdAt": "2020-11-10T22:06:52Z",
              "updatedAt": "2020-11-10T22:06:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODcyOTU4",
          "commit": {
            "abbreviatedOid": "c2b5261"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM.",
          "createdAt": "2020-11-17T22:40:38Z",
          "updatedAt": "2020-11-17T22:40:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODkzOTU0",
          "commit": {
            "abbreviatedOid": "c2b5261"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-17T23:20:48Z",
          "updatedAt": "2020-11-17T23:20:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 353,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE0MzQ0MjI3",
      "title": "Derive accept confirmation from the handshake secret ",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/353",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[Originally suggested by Karthik Bhargavan](https://mailarchive.ietf.org/arch/msg/tls/XsWf4f7-apwOlehe4j0_qKB3zV4/), this change mitigates an active \"don't stick out\" attack [pointed out by Christian Huitema](https://mailarchive.ietf.org/arch/msg/tls/EAeKCNq7JAFm8DFaoe2MwSslZTQ/). The attack is as follows.\r\n\r\n```\r\nClient                       Attacker             Server\r\nCH\r\n +encrypted_client_hello\r\n +key_share (g^x)        --> CH -->               SH\r\n                                                   +key_share (g^y)\r\n                             SH'              <-- EE\r\n                              +key_share (g^a)\r\n                         <-- EE'\r\n```\r\n\r\n1. The attacker intercepts the client's first flow (`CH`) and forwards it to the\r\n   server.\r\n2. The attacker intercepts the server's first flow and transforms `SH` and `EE` into\r\n   `SH'` and `EE'` respectively, as follows. `SH'` is just like `SH` except that the\r\n   key share `g^y` is replaced with key share `g^a`, where `a` is known to the\r\n   attacker. `EE'` is a malformed handshake message encrypted using a key derived\r\n   from `g^xa`. Finally, it sends `SH'..EE'` to the client.\r\n3. If the client aborts with a \"bad_record_mac\" alert, then the attacker guesses\r\n   that real-ECH was used. Otherwise, it guesses that grease-ECH was used.",
      "createdAt": "2020-11-02T21:46:35Z",
      "updatedAt": "2020-11-17T22:11:42Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3b2b8cd7e8c10fadcd79e087238d67e44048584f",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "accept-binder",
      "headRefOid": "50506ef3c99ab65f6aa9a0c0fcd1c1340940031c",
      "closedAt": "2020-11-17T22:11:42Z",
      "mergedAt": "2020-11-17T22:11:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e4c80070fe32f8a6339053b481b92c7078b15da7"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I have really mixed feelings about this. On the one hand, it's kind of annoying extra complexity. OTOH, given how hard a time we have had by reasoning about the security of ECH, I think better safe than sorry.",
          "createdAt": "2020-11-03T20:31:42Z",
          "updatedAt": "2020-11-03T20:31:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton can you please rebase this PR?",
          "createdAt": "2020-11-04T01:11:41Z",
          "updatedAt": "2020-11-04T01:11:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton this is nice -- thanks! I think the new type name for the special SH is fine, though if someone has an idea for a better name, let's consider it.",
          "createdAt": "2020-11-04T13:38:15Z",
          "updatedAt": "2020-11-04T13:38:15Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @ekr: I have really mixed feelings about this. On the one hand, it's kind of annoying extra complexity. OTOH, given how hard a time we have had by reasoning about the security of ECH, I think better safe than sorry.\r\n\r\nThis change is definitely more invasive than the existing signal, but not all that hard to implement. (E.g., https://github.com/cloudflare/go/pull/38.)\r\n\r\ncc/ @dmcardle, @davidben ",
          "createdAt": "2020-11-11T00:18:37Z",
          "updatedAt": "2020-11-11T00:18:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @cjpatton! @dmcardle and @kjacobs-moz, if you can also comment on the implementation difficulty, we can try and land this soon.",
          "createdAt": "2020-11-11T01:00:57Z",
          "updatedAt": "2020-11-11T01:01:08Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems pretty straightforward. I don't think it would be too difficult to do in NSS.",
          "createdAt": "2020-11-11T19:23:51Z",
          "updatedAt": "2020-11-11T19:23:51Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think on balance we should do this.",
          "createdAt": "2020-11-17T06:39:06Z",
          "updatedAt": "2020-11-17T06:39:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTQxNzc0",
          "commit": {
            "abbreviatedOid": "198671e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-03T01:26:56Z",
          "updatedAt": "2020-11-03T01:26:56Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "nit: s/.../../",
              "createdAt": "2020-11-03T01:26:56Z",
              "updatedAt": "2020-11-04T19:27:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTgwNTc4",
          "commit": {
            "abbreviatedOid": "198671e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T01:12:02Z",
          "updatedAt": "2020-11-04T01:12:03Z",
          "comments": [
            {
              "originalPosition": 280,
              "body": "```suggestion\r\nSection 7.1 and ClientHelloInner..ServerHelloECHConf refers to the sequence of\r\n```",
              "createdAt": "2020-11-04T01:12:02Z",
              "updatedAt": "2020-11-04T19:27:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzY0MjIx",
          "commit": {
            "abbreviatedOid": "ef03c58"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T13:35:40Z",
          "updatedAt": "2020-11-04T13:35:41Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n                      \"ech accept confirmation\",\r\n```",
              "createdAt": "2020-11-04T13:35:40Z",
              "updatedAt": "2020-11-04T19:27:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzY1NzAw",
          "commit": {
            "abbreviatedOid": "ef03c58"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T13:37:22Z",
          "updatedAt": "2020-11-04T13:37:23Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nThe backend server begins by generating a message ServerHelloECHConf, which is identical\r\nin content to a ServerHello message with the exception that ServerHelloECHConf.random is\r\n```",
              "createdAt": "2020-11-04T13:37:22Z",
              "updatedAt": "2020-11-04T19:27:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc1OTQ0",
          "commit": {
            "abbreviatedOid": "ef03c58"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T13:49:30Z",
          "updatedAt": "2020-11-04T13:49:30Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "The relevant text here notes that active attackers can distinguish real from fake ECH, which, as written, is probably still true with this change. (It could probe for the outer name, and then memcmp that to what's in a packet, for example.) So I might drop this TODO and address overhauling this section as part of #354.",
              "createdAt": "2020-11-04T13:49:30Z",
              "updatedAt": "2020-11-04T19:27:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjQxMTkw",
          "commit": {
            "abbreviatedOid": "a90b642"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T18:46:29Z",
          "updatedAt": "2020-11-04T18:46:29Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Done.",
              "createdAt": "2020-11-04T18:46:29Z",
              "updatedAt": "2020-11-04T19:27:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 355,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE1MDE0MjQ5",
      "title": "Bump HPKE-05 to -06",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/355",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-03T22:00:37Z",
      "updatedAt": "2020-11-03T22:01:25Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "384dc60929a56d5f743e1345ac5438a6607a19fc",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hpke-06",
      "headRefOid": "8f7646d3157fe0b7b8c8dd79b12dbff5c9aee7de",
      "closedAt": "2020-11-03T22:01:25Z",
      "mergedAt": "2020-11-03T22:01:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3b2b8cd7e8c10fadcd79e087238d67e44048584f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTA2MTI3",
          "commit": {
            "abbreviatedOid": "8f7646d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-03T22:01:21Z",
          "updatedAt": "2020-11-03T22:01:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 357,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE2OTIyMTk4",
      "title": "Correcting incorrect integer equivalents for ECH and outer_extensions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/357",
      "state": "MERGED",
      "author": "sudheesh001",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Sudheesh Singanamalla <sudheesh@cloudflare.com>",
      "createdAt": "2020-11-06T18:54:57Z",
      "updatedAt": "2020-11-06T20:29:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3b2b8cd7e8c10fadcd79e087238d67e44048584f",
      "headRepository": "sudheesh001/draft-ietf-tls-esni",
      "headRefName": "int_fixes",
      "headRefOid": "06e3e2d2f7477bdf53bc44195f4a34168ee0cc71",
      "closedAt": "2020-11-06T19:02:40Z",
      "mergedAt": "2020-11-06T19:02:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a70b9770debf7bc94570dd6250dbbb1929e1212f"
      },
      "comments": [
        {
          "author": "sudheesh001",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood This is ready for review.",
          "createdAt": "2020-11-06T18:58:40Z",
          "updatedAt": "2020-11-06T18:58:40Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think this is right. It's not an integer equivalent but a max value for sizing the enum.\r\nhttps://tools.ietf.org/html/rfc8446#section-3.5\r\n\r\n(The TLS presentation syntax is sometimes confusing.)",
          "createdAt": "2020-11-06T19:11:32Z",
          "updatedAt": "2020-11-06T19:11:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, well that's annoying. And confusing. I'll revert this.",
          "createdAt": "2020-11-06T19:16:34Z",
          "updatedAt": "2020-11-06T19:16:34Z"
        },
        {
          "author": "sudheesh001",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah that was confusing. Apologies.",
          "createdAt": "2020-11-06T20:29:57Z",
          "updatedAt": "2020-11-06T20:29:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NDE3Mjc3",
          "commit": {
            "abbreviatedOid": "06e3e2d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-06T19:02:35Z",
          "updatedAt": "2020-11-06T19:02:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 360,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyMDY2NzYy",
      "title": "Add is_client_hello_inner extension.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/360",
      "state": "MERGED",
      "author": "cbartle891",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves a second issue detailed in https://github.com/tlswg/draft-ietf-tls-esni/issues/348. Replaces the empty encrypted_client_hello extension with a new extension, is_client_hello_inner, to indicate that the ClientHello is a ClientHelloInner.\r\n\r\nLet me know if I've completely misunderstood what the issue was or what the fix was supposed to be.",
      "createdAt": "2020-11-17T00:54:38Z",
      "updatedAt": "2020-11-19T00:06:14Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "496b50b24d466c24f2d895cce0a8eb3472fc2ba1",
      "headRepository": "cbartle891/draft-ietf-tls-esni",
      "headRefName": "cdb/is_client_hello_inner",
      "headRefOid": "82093ee4a61ec632afda4a8c0464c1ec26f66fdd",
      "closedAt": "2020-11-19T00:06:14Z",
      "mergedAt": "2020-11-19T00:06:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c789ca42e2672dbdec20648866041f483d5082d5"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cbartle891, would you remind rebasing?",
          "createdAt": "2020-11-17T22:16:23Z",
          "updatedAt": "2020-11-17T22:16:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cbartle891, can you please resolve conflicts?",
          "createdAt": "2020-11-18T05:10:32Z",
          "updatedAt": "2020-11-18T05:10:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxOTQ0NDk0",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "\ud83d\udc4d Thank you! I'll let others chime in and bike shed the name. My two main points of concern are (1) about the *focus* of the extension (does it simply instruct the server to apply the confirmation signal, or does it intend to do more?) and (2) what to do when both the outer and inner \"ech\" extensions are present.",
          "createdAt": "2020-11-17T01:01:51Z",
          "updatedAt": "2020-11-17T01:06:35Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I don't feel strongly about the name, though this extension seems to me more about \"swizzling\" ServerHello.random (by setting the confirmation signal), and less about the fact that the CH is of type ClientHelloInner. Unless there's other things that backend servers need to do in response to a CHInner (beyond putting in the acceptance signal), I'd refocus this extension so it targets just that piece.",
              "createdAt": "2020-11-17T01:01:51Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            },
            {
              "originalPosition": 79,
              "body": "If it's empty, I think we can omit this piece.\r\n\r\n```suggestion\r\n```",
              "createdAt": "2020-11-17T01:03:31Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            },
            {
              "originalPosition": 105,
              "body": "What if both extensions are present? I suppose the server MUST abort with illegal_parameter in that case? (I see below that it's suggested for servers to ignore the inner one, but it seems better to fail loudly here, since this is not permitted client behavior.)",
              "createdAt": "2020-11-17T01:04:14Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            },
            {
              "originalPosition": 120,
              "body": "(As above, I'd abort in this case.)",
              "createdAt": "2020-11-17T01:05:10Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxOTUzMjI2",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cbartle891",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T01:24:34Z",
          "updatedAt": "2020-11-17T01:24:34Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I basically had to do most of this entire change to understand what David meant by the \"swizzle\" comment, and I imagine it would be equally confusing for people who are new to this. To me, it's clearer to say \"this extension is just a sign that this ClientHello is an inner ClientHello,\" and then explain what the backend server does in reaction to that in that section.",
              "createdAt": "2020-11-17T01:24:34Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDY3Nzk5",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T07:03:02Z",
          "updatedAt": "2020-11-17T07:03:03Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "My bike shed proposal is to use the following names:\r\n1. \"encrypted_client_hello\"\r\n2. \"ech_is_inner\"\r\n3. \"ech_outer_extensions\"\r\n\r\nThat way the extensions that are only meaningful to ECH have names that indicates as much.",
              "createdAt": "2020-11-17T07:03:03Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDcwMDU4",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cbartle891",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T07:07:55Z",
          "updatedAt": "2020-11-17T07:07:56Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Ack, dangit, I forgot to change \"outer_extensions.\" Sorry about that!",
              "createdAt": "2020-11-17T07:07:55Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDczMDEy",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T07:14:17Z",
          "updatedAt": "2020-11-17T07:14:18Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "> ... but it seems better to fail loudly here, since this is not permitted client behavior.\r\n\r\nThis seems to be true in general, but elsewhere in the draft we deal with client misbehavior by rejecting. For example, if ClientECH.cipher_suite isn't a valid cipher suite for the ECHConfig indicated by ClientECH.config_id, then the client-facing server skips this ECHConfig and moves on to the next. This done for \"don't stick out\" reasons. I think it makes sense to follow the same pattern here.\r\n\r\nTL;DR: I think the text is better as-is.",
              "createdAt": "2020-11-17T07:14:17Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDc1NjA1",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T07:19:36Z",
          "updatedAt": "2020-11-17T07:19:36Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "But a difference in algorithm is not the same as an actual implementation bug on the client side. It could be because of a server misconfiguration. This edge case (sending both extensions) is a flat out bug, no?",
              "createdAt": "2020-11-17T07:19:36Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTI0MDM1",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cbartle891",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T08:30:33Z",
          "updatedAt": "2020-11-17T08:30:33Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "It doesn't add anything to the protocol, but should it be fatal? (I chose to ignore it just for leniency/flexibility but I'm fine with making it a fatal error instead.)",
              "createdAt": "2020-11-17T08:30:33Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTI1OTc4",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T08:33:16Z",
          "updatedAt": "2020-11-17T08:33:16Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I would argue that choosing a cipher suite other than one that is indicated by the ECHConfig is also an implementation bug. (Though I should add that I don't have a strong opinion about aborting or not here.)",
              "createdAt": "2020-11-17T08:33:16Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNTIwNDgw",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T15:57:00Z",
          "updatedAt": "2020-11-17T15:57:00Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I think other people need to weigh in here. @davidben, penny for your thoughts?",
              "createdAt": "2020-11-17T15:57:00Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNTUzOTQ5",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T16:29:05Z",
          "updatedAt": "2020-11-17T16:29:06Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I think let's require failure.",
              "createdAt": "2020-11-17T16:29:06Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODYxODEw",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is pretty good! Most of my suggestions are editorial.",
          "createdAt": "2020-11-17T22:21:38Z",
          "updatedAt": "2020-11-17T22:30:30Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "- Let's promote this subsubsection to a subsection and make it a subsection of {{encrypted-client-hello}}\r\n- In order to be consistent with the other subsections, I suggest using a title that's suggestive of the code points purpose. E.g., `Differentiating between the ClientHelloInner and the ClientHelloOuter`.",
              "createdAt": "2020-11-17T22:21:39Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            },
            {
              "originalPosition": 72,
              "body": "I like the name, for the record.",
              "createdAt": "2020-11-17T22:25:34Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            },
            {
              "originalPosition": 151,
              "body": "No biggy!",
              "createdAt": "2020-11-17T22:28:25Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTAxMzQ5",
          "commit": {
            "abbreviatedOid": "ff7374d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-18T04:46:54Z",
          "updatedAt": "2020-11-18T04:47:16Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "```suggestion\r\nIf the client offers the \"ech_is_inner\" extension ({{is-inner}})\r\nin addition to the \"encrypted_client_hello\" extension, the server MUST abort\r\nwith an \"illegal_parameter\" alert.\r\n```",
              "createdAt": "2020-11-18T04:46:54Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTAzNjUy",
          "commit": {
            "abbreviatedOid": "ff7374d"
          },
          "author": "cbartle891",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T04:54:53Z",
          "updatedAt": "2020-11-18T04:54:53Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "> make it a subsection of {{encrypted-client-hello}}\r\n\r\nI'm not sure about this because `ech_is_inner` isn't part of the `encrypted_client_hello` extension.",
              "createdAt": "2020-11-18T04:54:53Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTAzOTU3",
          "commit": {
            "abbreviatedOid": "dd982fc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T04:56:00Z",
          "updatedAt": "2020-11-18T04:56:00Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "I'd leave it as-is for now. We can move it around later if needed.",
              "createdAt": "2020-11-18T04:56:00Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTA0Mzcw",
          "commit": {
            "abbreviatedOid": "dd982fc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T04:57:13Z",
          "updatedAt": "2020-11-18T04:57:13Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "```suggestion\r\n### ClientHelloInner Indication Extension {#is-inner}\r\n```",
              "createdAt": "2020-11-18T04:57:13Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTA5Mzky",
          "commit": {
            "abbreviatedOid": "4dc9cc9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T05:13:32Z",
          "updatedAt": "2020-11-18T05:13:33Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Fine with me.",
              "createdAt": "2020-11-18T05:13:33Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTA5NTc5",
          "commit": {
            "abbreviatedOid": "4dc9cc9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-18T05:14:13Z",
          "updatedAt": "2020-11-18T05:14:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTc4NzI5",
          "commit": {
            "abbreviatedOid": "58b697f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T00:01:40Z",
          "updatedAt": "2020-11-19T00:01:41Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "```suggestion\r\nServers that support ECH play one of two roles, depending on the extension\r\n```",
              "createdAt": "2020-11-19T00:01:40Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTc5NzA4",
          "commit": {
            "abbreviatedOid": "58b697f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T00:03:49Z",
          "updatedAt": "2020-11-19T00:03:50Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "```suggestion\r\nclient by computing its ServerHello as described here. If both the \"ech_is_inner\" \r\nextension and \"encrypted_client_hello\" extensions are present in the ClientHello, \r\nthe backend server MUST abort with an \"illegal_parameter\" alert.\r\n```",
              "createdAt": "2020-11-19T00:03:50Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTc5Nzgw",
          "commit": {
            "abbreviatedOid": "58b697f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T00:04:00Z",
          "updatedAt": "2020-11-19T00:04:01Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "```suggestion\r\nUpon receipt of an \"ech_is_inner\" extension in a ClientHello, if the backend\r\n```",
              "createdAt": "2020-11-19T00:04:00Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTgwMDkz",
          "commit": {
            "abbreviatedOid": "dd95a13"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T00:04:48Z",
          "updatedAt": "2020-11-19T00:04:48Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "```suggestion\r\nand \"encrypted_client_hello\" extensions are present in the ClientHello, the backend \r\nserver MUST abort with an \"illegal_parameter\" alert.\r\n```",
              "createdAt": "2020-11-19T00:04:48Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTgwMTk3",
          "commit": {
            "abbreviatedOid": "dd95a13"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T00:05:05Z",
          "updatedAt": "2020-11-19T00:05:06Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "```suggestion\r\nextension and \"encrypted_client_hello\" extensions are present in the ClientHello,\r\n```",
              "createdAt": "2020-11-19T00:05:05Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTgwNDE4",
          "commit": {
            "abbreviatedOid": "20d8af3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T00:05:38Z",
          "updatedAt": "2020-11-19T00:05:38Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "```suggestion\r\nand \"encrypted_client_hello\" extensions are present in the ClientHello, the backend\r\n```",
              "createdAt": "2020-11-19T00:05:38Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 361,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyNzg0MTY0",
      "title": "Copy the entire extension on HRR + GREASE for now.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/361",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a temporary mitigation for the compatibility risks from #358, as\r\nany clients experimenting with GREASE will impact servers that otherwise\r\ndon't expect ECH. To resolve this issue overall, we may need a more\r\ninvolved solution.",
      "createdAt": "2020-11-18T00:05:46Z",
      "updatedAt": "2020-11-19T12:08:37Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9f485e939b99814f9a73c1e94ec5e44f0a8d4806",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "hrr-bandaid",
      "headRefOid": "f288d98e489d2603244b11626beabcb73850a074",
      "closedAt": "2020-11-19T12:08:37Z",
      "mergedAt": "2020-11-19T12:08:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8b2dd889525ac50c703d9c3267d1c61db6d7a81c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzODQyNDg0",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T20:19:35Z",
          "updatedAt": "2020-11-18T20:19:36Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'm confused by the word \"match\" here. Do you mean to say that greased ECH looks different from real ECH after HRR?",
              "createdAt": "2020-11-18T20:19:35Z",
              "updatedAt": "2020-11-18T20:19:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzODUwNjA4",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T20:30:58Z",
          "updatedAt": "2020-11-18T20:30:59Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Yes. This is #358. There is a potential compatibility issue with changing CH2's ECH extension when talking to a server that doesn't expect ECH. We also need to change CH2's ECH extension when actually speaking ECH.\r\n\r\nThis PR resolves the compatibility issue, just so we can get this out of the way of draft-09. It does not resolve the bulk of #358 which interacts with every other HRR problem.",
              "createdAt": "2020-11-18T20:30:58Z",
              "updatedAt": "2020-11-18T20:30:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzODYyNTE2",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T20:47:46Z",
          "updatedAt": "2020-11-18T20:47:47Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I think this is a good idea for ECH-09, I'm merely suggesting that the wording of the OPEN ISSUE could be clearer.",
              "createdAt": "2020-11-18T20:47:46Z",
              "updatedAt": "2020-11-18T20:47:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzODc4ODQw",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T21:10:39Z",
          "updatedAt": "2020-11-18T21:10:40Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Ah. What wording would you prefer? Perhaps: \"OPEN ISSUE: The extension value is not copied when sending a real ECH extension. See issue #358.\"",
              "createdAt": "2020-11-18T21:10:39Z",
              "updatedAt": "2020-11-18T21:10:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTMwODYw",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T22:23:24Z",
          "updatedAt": "2020-11-18T22:23:24Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "That's better, but I think we should make this an explicit don't-stick-out issue. Slight revision: \"OPEN ISSUE: The extension value is not copied when sending a real ECH extension, causing this code path to stick out. See issue #358.\"\r\n\r\n",
              "createdAt": "2020-11-18T22:23:24Z",
              "updatedAt": "2020-11-18T22:23:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTM5NTY4",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T22:38:02Z",
          "updatedAt": "2020-11-18T22:38:02Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "It's not just about sticking out. ECH acceptance and ECH rejection currently also violate the RFC8446 requirement. This PR doesn't change it because it would break them, and it's mostly okay compatibility-wise because it would only affect servers that have opted in via DNS. (But only mostly. The recovery flow on a strictly enforcing server is broken.)",
              "createdAt": "2020-11-18T22:38:02Z",
              "updatedAt": "2020-11-18T22:38:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTM5ODUx",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T22:38:32Z",
          "updatedAt": "2020-11-18T22:38:33Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "That's why I specifically wanted this to just be a quick summary and then a pointer to the issue where we'll capture the actual discussion in a more fluid form.",
              "createdAt": "2020-11-18T22:38:32Z",
              "updatedAt": "2020-11-18T22:38:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTUyMzgy",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T23:02:25Z",
          "updatedAt": "2020-11-18T23:02:25Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Ah I see, you wanted the comment to reflect that as well. It's a big vague, but I'm fine leaving it as is.",
              "createdAt": "2020-11-18T23:02:25Z",
              "updatedAt": "2020-11-18T23:02:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MzY3MTI5",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Given the compatibility concerns @davidben found, and based on discussion in IETF 109, I think this is prudent to merge for -09. Doing so now.",
          "createdAt": "2020-11-19T12:07:41Z",
          "updatedAt": "2020-11-19T12:08:30Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Yeah, I think the comment is fine as-is.",
              "createdAt": "2020-11-19T12:07:41Z",
              "updatedAt": "2020-11-19T12:08:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 362,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIzNDAzMjk2",
      "title": "Bind the context handle to encrypted payload",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/362",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #326.",
      "createdAt": "2020-11-18T18:56:37Z",
      "updatedAt": "2020-11-18T23:57:21Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9f485e939b99814f9a73c1e94ec5e44f0a8d4806",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "cjpatton/context-handle-binding",
      "headRefOid": "a2e213788b9673e9758b913371f76f4f949a42e6",
      "closedAt": "2020-11-18T23:57:21Z",
      "mergedAt": "2020-11-18T23:57:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "496b50b24d466c24f2d895cce0a8eb3472fc2ba1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzODEwMzM5",
          "commit": {
            "abbreviatedOid": "f85ca22"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T19:38:08Z",
          "updatedAt": "2020-11-18T19:39:04Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I think we're better off writing this a bit more explicitly in TLS syntax, given we already have way to describe the length prefixes.\r\n\r\nAlternatively, should we say it's the ClientHelloOuter, but with the `payload` field of the encrypted_client_hello extension replaced with the empty string?",
              "createdAt": "2020-11-18T19:38:09Z",
              "updatedAt": "2020-11-18T22:58:34Z"
            },
            {
              "originalPosition": 50,
              "body": "ClientHelloOuterAAD is only used to compute ech_aad anyway. Seems the new text would be better off in {{authenticating-outer}} and then we only need to cite one section and variable name as before.",
              "createdAt": "2020-11-18T19:38:57Z",
              "updatedAt": "2020-11-18T22:58:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzODI2MTg3",
          "commit": {
            "abbreviatedOid": "f85ca22"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T19:59:02Z",
          "updatedAt": "2020-11-18T19:59:02Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I think using TLS syntax is a good idea.",
              "createdAt": "2020-11-18T19:59:02Z",
              "updatedAt": "2020-11-18T22:58:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTQ5MTQ0",
          "commit": {
            "abbreviatedOid": "f85ca22"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T22:55:44Z",
          "updatedAt": "2020-11-18T22:55:44Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Done.",
              "createdAt": "2020-11-18T22:55:44Z",
              "updatedAt": "2020-11-18T22:58:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTQ5Mjg4",
          "commit": {
            "abbreviatedOid": "f85ca22"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T22:56:00Z",
          "updatedAt": "2020-11-18T22:56:01Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Done.",
              "createdAt": "2020-11-18T22:56:00Z",
              "updatedAt": "2020-11-18T22:58:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTc2ODg5",
          "commit": {
            "abbreviatedOid": "a2e2137"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-18T23:57:14Z",
          "updatedAt": "2020-11-18T23:57:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 363,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI0OTYxNzU1",
      "title": "Move some text around in Server Behavior.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/363",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The text for servers rejecting both extensions present is under Backend\r\nServer, but the Server Behavior text gates that section under just the\r\none extension. Likewise, the client-facing server text allows for both\r\nextensions to be present.\r\n\r\nMove the illegal_parameter text around and write out the four cases.",
      "createdAt": "2020-11-20T21:29:49Z",
      "updatedAt": "2020-11-20T22:10:31Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8b2dd889525ac50c703d9c3267d1c61db6d7a81c",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "both-xtns",
      "headRefOid": "771c948abfff773df1044ff86f8640834a00aa16",
      "closedAt": "2020-11-20T22:10:31Z",
      "mergedAt": "2020-11-20T22:10:31Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "44aab0c68e1d39f41377db648aa1e6bf0481c483"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 364,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI0OTk3Nzcz",
      "title": "Remove backticks from empty string literal.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/364",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The backtick-quoted empty string translates to \"\"\"\" in the text output.",
      "createdAt": "2020-11-20T22:59:53Z",
      "updatedAt": "2020-11-21T18:04:52Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "44aab0c68e1d39f41377db648aa1e6bf0481c483",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "c8835c0f1b68bfbe1dfdaf33bb5d7d42d4c3df35",
      "closedAt": "2020-11-21T18:04:52Z",
      "mergedAt": "2020-11-21T18:04:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "13f66e2e01999ccfa341d47f292416fe9f01f772"
      },
      "comments": [
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not sure if this is the best solution, but the quadruple quote in the txt is goofy.",
          "createdAt": "2020-11-20T23:04:04Z",
          "updatedAt": "2020-11-20T23:04:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems fine, yeah. Thanks for catching it!",
          "createdAt": "2020-11-21T18:04:48Z",
          "updatedAt": "2020-11-21T18:04:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1OTg0MzY2",
          "commit": {
            "abbreviatedOid": "c8835c0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-21T18:04:39Z",
          "updatedAt": "2020-11-21T18:04:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 365,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI1MDE3NzMy",
      "title": "Quick editorial pass.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/365",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Tried to clarify some text, PTAL :)\r\n\r\nFor the backend server, I think the `ClientHelloInner..ServerHelloECHConf` notation is a little confusing (pedantically, shouldn't it be `...`?). Can't we just concatenate the two messages and call it a day?",
      "createdAt": "2020-11-21T00:05:45Z",
      "updatedAt": "2020-11-24T12:50:25Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "48662e26fbdc766471a211eb6038a742736fd69b",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "dan-edits",
      "headRefOid": "efafbd8a696a35056df3540b746edd669eb3e9eb",
      "closedAt": "2020-11-24T12:50:25Z",
      "mergedAt": "2020-11-24T12:50:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "da3338fbcf62adb832445b8b3ce2c741f8f460b4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1OTg0NjMy",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The simplified notation LGTM. @cjpatton, please have look!",
          "createdAt": "2020-11-21T18:08:16Z",
          "updatedAt": "2020-11-21T18:08:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NjAyNDc1",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "- I like `..` because it's consistent with RFC 8446 (See the key schedule section.)\r\n- `make` fails because of lines that exceed 80 characters.",
          "createdAt": "2020-11-23T15:49:13Z",
          "updatedAt": "2020-11-23T15:52:02Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Actually, the `..` notation is meant to denote the sequence of messages between `ClientHelloInner` and `ServerHelloECHConf`. This sequence is empty here, but I think we should use the notation nonetheless, in order to be consistent with RFC8446.",
              "createdAt": "2020-11-23T15:49:14Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            },
            {
              "originalPosition": 141,
              "body": "If we revert the above change, don't forget to revert this change as well.",
              "createdAt": "2020-11-23T15:49:47Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NjA2ODU5",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T15:53:42Z",
          "updatedAt": "2020-11-23T15:53:42Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I don\u2019t think this is necessary. || is more clear in this context given that the sequence is always empty.",
              "createdAt": "2020-11-23T15:53:42Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NjUzNDY4",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T16:40:25Z",
          "updatedAt": "2020-11-23T16:40:26Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "What about incorporating the CH1 hash? Isn't that also something that's implied by the `..` notation?",
              "createdAt": "2020-11-23T16:40:26Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NjkyNjI4",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T17:25:01Z",
          "updatedAt": "2020-11-23T17:25:02Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "In this section, it might be clearer to refer to `ECHConfig.contents.kem_id`, since `ECHConfig` has been defined, but `ECHConfigContents` only implicitly refers to `ECHConfig.contents`. (Here and below.)",
              "createdAt": "2020-11-23T17:25:02Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzM4NTUw",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T18:26:02Z",
          "updatedAt": "2020-11-23T18:26:03Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "In other words, this needs to denotes the whole transcript from ClientHelloInner to ServerHelloECHConf, including the messages on the HRR path.",
              "createdAt": "2020-11-23T18:26:02Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzYyOTgz",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T19:01:17Z",
          "updatedAt": "2020-11-23T19:01:17Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "(@chris-wood and I spoke offline and we agreed that the `..` notation should stay as-is.)",
              "createdAt": "2020-11-23T19:01:17Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTE3Mjc4",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T23:10:58Z",
          "updatedAt": "2020-11-23T23:10:58Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I find the range syntax a bit confusing here. If there were messages in between, it's not clear to me which variant of those messages would be selected, or whether some transformation would be applied to them.\r\n\r\nI don't feel really strongly about this. Happy to revert it, but to be fully pedantic, I want to point out that RFC 8446 uses three dots between messages. I'll go ahead and use three dots here, unless two dots has a different meaning that I don't understand.",
              "createdAt": "2020-11-23T23:10:58Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTE4Nzkx",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T23:14:13Z",
          "updatedAt": "2020-11-23T23:14:14Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "Done!",
              "createdAt": "2020-11-23T23:14:14Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTI2ODI2",
          "commit": {
            "abbreviatedOid": "81a03a7"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T23:32:19Z",
          "updatedAt": "2020-11-23T23:32:20Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Agreed, made this change for the whole \"Offering ECH\" section.",
              "createdAt": "2020-11-23T23:32:19Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTQ3OTQw",
          "commit": {
            "abbreviatedOid": "81a03a7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-24T00:25:01Z",
          "updatedAt": "2020-11-24T00:25:01Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Oops, three dots is right! https://tools.ietf.org/html/rfc8446#section-7.1\r\n\r\nI think my dyslexic brain is removing  a dot. ",
              "createdAt": "2020-11-24T00:25:01Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTQ4NTky",
          "commit": {
            "abbreviatedOid": "81a03a7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good, modulo minor nits! ",
          "createdAt": "2020-11-24T00:26:46Z",
          "updatedAt": "2020-11-24T00:29:24Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Is `ECHConfig.config.maximum_name_length` more appropriate here?",
              "createdAt": "2020-11-24T00:26:47Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            },
            {
              "originalPosition": 91,
              "body": "`ECHConfig.contents.maximum_name_length`?",
              "createdAt": "2020-11-24T00:27:00Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            },
            {
              "originalPosition": 100,
              "body": "`ECHConfig.contents.public_name`?",
              "createdAt": "2020-11-24T00:27:12Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            },
            {
              "originalPosition": 136,
              "body": "Nice catch!",
              "createdAt": "2020-11-24T00:27:56Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            },
            {
              "originalPosition": 49,
              "body": "Do these lines break 80 characters?",
              "createdAt": "2020-11-24T00:28:41Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTYxNzU0",
          "commit": {
            "abbreviatedOid": "81a03a7"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-24T01:01:31Z",
          "updatedAt": "2020-11-24T01:01:31Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Yep, good catch! Reflowing the paragraph in a new commit.",
              "createdAt": "2020-11-24T01:01:31Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTY1MTAz",
          "commit": {
            "abbreviatedOid": "0e9bc1a"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-24T01:10:32Z",
          "updatedAt": "2020-11-24T01:10:33Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "Done",
              "createdAt": "2020-11-24T01:10:32Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTY1MTIy",
          "commit": {
            "abbreviatedOid": "0e9bc1a"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-24T01:10:36Z",
          "updatedAt": "2020-11-24T01:10:37Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Done",
              "createdAt": "2020-11-24T01:10:36Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTY1MTkx",
          "commit": {
            "abbreviatedOid": "0e9bc1a"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-24T01:10:48Z",
          "updatedAt": "2020-11-24T01:10:48Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Seems reasonable, done.",
              "createdAt": "2020-11-24T01:10:48Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MDA0MTE5",
          "commit": {
            "abbreviatedOid": "0e9bc1a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-11-24T01:40:43Z",
          "updatedAt": "2020-11-24T01:41:21Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "This line and the one below it are longer than 80 characters. (Sorry if this is annoying ... lines that are longer than 80 characters cause `make` to fail. In fact, you should be getting emails from CI telling you that the build is failing.)",
              "createdAt": "2020-11-24T01:40:43Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MDI5Mzcz",
          "commit": {
            "abbreviatedOid": "efafbd8"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-24T02:27:34Z",
          "updatedAt": "2020-11-24T02:27:34Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Aha, I hadn't run make in a few commits, my bad. Fixed now.",
              "createdAt": "2020-11-24T02:27:34Z",
              "updatedAt": "2020-11-24T02:27:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MDM2OTE1",
          "commit": {
            "abbreviatedOid": "efafbd8"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-11-24T02:48:18Z",
          "updatedAt": "2020-11-24T02:48:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 366,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI1OTE1MDIz",
      "title": "Editorial pass and advance ECHConfig.version to ECH-09",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/366",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-23T18:22:49Z",
      "updatedAt": "2020-11-23T22:13:39Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "13f66e2e01999ccfa341d47f292416fe9f01f772",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "cjpatton/edit",
      "headRefOid": "3078ffac538fe8b2fe8dc151a5d2f1f308336cc4",
      "closedAt": "2020-11-23T22:13:39Z",
      "mergedAt": "2020-11-23T22:13:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7cf17ec836c19bf05778f693b5be935331317713"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2ODg2MzQx",
          "commit": {
            "abbreviatedOid": "3078ffa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-23T22:13:34Z",
          "updatedAt": "2020-11-23T22:13:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 367,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI2MDQ3ODEx",
      "title": "Specify the backend server's behavior when \"ech_is_inner\" is not empty",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/367",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "~It's sufficient to ignore it, I think.~ The backend server enforces the extension's emptiness. ",
      "createdAt": "2020-11-23T23:01:06Z",
      "updatedAt": "2020-11-23T23:21:50Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7cf17ec836c19bf05778f693b5be935331317713",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "cjpatton/nits",
      "headRefOid": "d1a244474073af56b816553d94cc6a6c0d995a97",
      "closedAt": "2020-11-23T23:21:49Z",
      "mergedAt": "2020-11-23T23:21:49Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "48662e26fbdc766471a211eb6038a742736fd69b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTIyMjM5",
          "commit": {
            "abbreviatedOid": "d1a2444"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-23T23:21:45Z",
          "updatedAt": "2020-11-23T23:21:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 368,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI2MDc1MzM3",
      "title": "Fix ClientHelloOuterAAD.outer_hello length",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/368",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Per RFC8446, Section 4, handshake messages, including ClientHello, may\r\nbe up to 2^24-1 bytes in length.",
      "createdAt": "2020-11-24T00:21:41Z",
      "updatedAt": "2020-11-24T12:51:20Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "48662e26fbdc766471a211eb6038a742736fd69b",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "cjpatton/inner-hello-aad-length",
      "headRefOid": "96874f4420b02045c82e53e4ac596cf95784d282",
      "closedAt": "2020-11-24T12:51:19Z",
      "mergedAt": "2020-11-24T12:51:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "314f2067bc540a5992fb37496746355086956c3b"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(I think the maximum possible ClientHello is 2^17 bytes plus some loose change, but who's counting? :-) 2^24-1 is less thinking.)",
          "createdAt": "2020-11-24T00:34:52Z",
          "updatedAt": "2020-11-24T00:35:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTQ3MjE2",
          "commit": {
            "abbreviatedOid": "96874f4"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-24T00:23:11Z",
          "updatedAt": "2020-11-24T00:23:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3NDU5MzQ5",
          "commit": {
            "abbreviatedOid": "96874f4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-24T12:51:15Z",
          "updatedAt": "2020-11-24T12:51:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 370,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMwNjg0NjE0",
      "title": "Clarify ClientHelloOuterAAD serialization",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/370",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Clarifies that serialization of this structure doesn't include the message type and length. We do the same thing for the serialization of EncodedClientHelloInner, but this makes it explicit in case it's not clear from context.",
      "createdAt": "2020-12-02T01:49:37Z",
      "updatedAt": "2020-12-02T02:55:55Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "314f2067bc540a5992fb37496746355086956c3b",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "cjpatton/nit",
      "headRefOid": "e67e59b6c7bc94120aeb58eade15930e9ee9c74b",
      "closedAt": "2020-12-02T02:55:55Z",
      "mergedAt": "2020-12-02T02:55:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7a5c68faf36dcc749a4ab763bf3a600239849b4f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyNDYwNzMy",
          "commit": {
            "abbreviatedOid": "e67e59b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-02T02:55:50Z",
          "updatedAt": "2020-12-02T02:55:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 371,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM3MTc4MTMy",
      "title": "Clarify privacy goal scope",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/371",
      "state": "MERGED",
      "author": "kjacobs-moz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #369",
      "createdAt": "2020-12-11T17:22:16Z",
      "updatedAt": "2020-12-16T14:31:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7a5c68faf36dcc749a4ab763bf3a600239849b4f",
      "headRepository": "kjacobs-moz/draft-ietf-tls-esni",
      "headRefName": "clarify-goal-scope",
      "headRefOid": "054eed3e0e95322c3ca8f38a87014e21de83806b",
      "closedAt": "2020-12-16T14:31:23Z",
      "mergedAt": "2020-12-16T14:31:23Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "985f09bd6f53425b5b3cf009a826f786f47ae412"
      },
      "comments": [
        {
          "author": "kjacobs-moz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done. Thanks!",
          "createdAt": "2020-12-11T18:10:35Z",
          "updatedAt": "2020-12-11T18:10:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMzg2NTIw",
          "commit": {
            "abbreviatedOid": "5c8665c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This LGTM. I have a slight rephrasing, but feel free to reject!",
          "createdAt": "2020-12-11T18:01:06Z",
          "updatedAt": "2020-12-11T18:05:10Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nAttacks that rely on non-ECH traffic to infer server identity in an ECH connection are \r\nout of scope for this document. For example, a client that connects to a particular host \r\nprior to ECH deployment may later resume a connection to that same host after ECH \r\ndeployment, thereby linking the resulting ECH connection to the original non-ECH \r\nconnection.\r\n```",
              "createdAt": "2020-12-11T18:04:45Z",
              "updatedAt": "2020-12-11T18:09:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 372,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM5ODcyODkz",
      "title": "Bump HPKE-06 to -07",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/372",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "TODO: Ensure that the section numbers referenced in the HPKE draft are still correct.",
      "createdAt": "2020-12-14T23:49:16Z",
      "updatedAt": "2020-12-16T14:28:55Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7a5c68faf36dcc749a4ab763bf3a600239849b4f",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "bump-hpke",
      "headRefOid": "7d2a4e6ec5d56fb0e22325bba6993381eb7b1fc2",
      "closedAt": "2020-12-16T14:28:55Z",
      "mergedAt": "2020-12-16T14:28:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "78b75e6cf34eabb6435a99132cc70bbe5be15fa9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNzM4NTU2",
          "commit": {
            "abbreviatedOid": "9db02ad"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-16T14:28:19Z",
          "updatedAt": "2020-12-16T14:28:20Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "These are the same in the latest draft. :-)\r\n```suggestion\r\n```",
              "createdAt": "2020-12-16T14:28:19Z",
              "updatedAt": "2020-12-16T14:28:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNzM5MDQ0",
          "commit": {
            "abbreviatedOid": "7d2a4e6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-16T14:28:51Z",
          "updatedAt": "2020-12-16T14:28:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 376,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYxNDczNDQw",
      "title": "Move to a key identity in lieu of the config identifier hash.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/376",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We may want to change how we deal with GREASE (does a randomly selected byte stick out?), but this should address the issue for now. I think we can (should) treat these issues separately, and focus just on the `key_id` simplification here.\r\n\r\nCloses #375.\r\n\r\ncc @davidben, @cjpatton, @martinthomson, @ekr",
      "createdAt": "2021-01-26T01:48:24Z",
      "updatedAt": "2021-02-15T20:08:02Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ee94206ba488d702a9acae30386875e14a5bb2a7",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/config_id-to-key_id",
      "headRefOid": "ce8a04539acf0655a87ed57aa422c795aa8c6fd6",
      "closedAt": "2021-02-15T20:08:01Z",
      "mergedAt": "2021-02-15T20:08:01Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "c1a3d71f20f6fa69da00fa5ee7fa1a11abc291de"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "My intuition is that one byte is too short; I think 32 bits would be wiser. However, this is a slightly less serious problem than usual because we can rev the ECHConfig version number and the ECH extension if we find something longer is needed.",
          "createdAt": "2021-01-26T02:32:34Z",
          "updatedAt": "2021-01-26T02:32:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> My intuition is that one byte is too short; I think 32 bits would be wiser. However, this is a slightly less serious problem than usual because we can rev the ECHConfig version number and the ECH extension if we find something longer is needed.\r\n\r\nYep, that sounds reasonable to me.",
          "createdAt": "2021-01-26T02:34:44Z",
          "updatedAt": "2021-01-26T02:34:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> But in order to minimize the collision probability, we ought to stick with the current length of 8 bytes.\r\n\r\nThis is somewhat of a bike shed, but 8 bytes seems quite large for something that will only have a handful of possible values at any given point in time. Is there a reason to make this longer beyond the performance cost of decryption failing as a result of collisions?",
          "createdAt": "2021-01-26T18:00:37Z",
          "updatedAt": "2021-01-26T18:00:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This is somewhat of a bike shed, but 8 bytes seems quite large for something that will only have a handful of possible values at any given point in time. Is there a reason to make this longer beyond the performance cost of decryption failing as a result of collisions?\r\n\r\nI guess the only reason I can see is that we've settled on q^2 / 2^64 as our threshold for operational risks. In particular, the \"acceptance\" signal in the SH.random is 8 bytes (https://tools.ietf.org/html/draft-ietf-tls-esni-09#section-10.7). I suppose we could get away with a smaller identifier, since the q is much smaller in this case.\r\n\r\n",
          "createdAt": "2021-01-26T18:14:37Z",
          "updatedAt": "2021-01-26T18:14:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I guess the only reason I can see is that we've settled on q^2 / 2^64 as our threshold for operational risks. In particular, the \"acceptance\" signal in the SH.random is 8 bytes (https://tools.ietf.org/html/draft-ietf-tls-esni-09#section-10.7). I suppose we could get away with a smaller identifier, since the q is much smaller in this case.\r\n\r\nThis seems different from acceptance signal collision, which actually causes breakage. In contrast, a key_id collision here just means that the server wastes cycles attempting decryption, right? ",
          "createdAt": "2021-01-26T18:16:07Z",
          "updatedAt": "2021-01-26T18:16:07Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This seems different from acceptance signal collision, which actually causes breakage. In contrast, a key_id collision here just means that the server wastes cycles attempting decryption, right?\r\n\r\nA config collision is bad because the server has to figure out which config the client used. It can only do so by trial decryption.",
          "createdAt": "2021-01-26T18:17:43Z",
          "updatedAt": "2021-01-26T18:17:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> A config collision is bad because the server has to figure out which config the client used. It can only do so by trial decryption.\r\n\r\nEh? If there's a collision, the server *knows* which key to try (the one it collided with!), and it will do so, fail to decrypt, and move on as per usual. (There's no trial decryption here, but maybe I'm missing something.)",
          "createdAt": "2021-01-26T18:19:08Z",
          "updatedAt": "2021-01-26T18:19:08Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to put a fine point on this: the spec SHOULD NOT require that implementations support trial decryption. In particular, we ought to ensure that, with high probability, configuration identifiers don't collide. A one-byte, randomly-generated identifier would make collisions inevitable, meaning that implementations will have to support trial decryption.",
          "createdAt": "2021-01-26T18:52:26Z",
          "updatedAt": "2021-01-26T18:52:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Just to put a fine point on this: the spec SHOULD NOT require that implementations support trial decryption. In particular, we ought to ensure that, with high probability, configuration identifiers don't collide. A one-byte, randomly-generated identifier would make collisions inevitable, meaning that implementations will have to support trial decryption.\r\n\r\nYeah, that's reasonable. If we're going to abide by this, then the ID needs to be at least 8 bytes. I'd be fine with that that for now assuming others are too. (@ekr suggested it be longer at the top anyway, so many we should just do it.)",
          "createdAt": "2021-01-26T18:53:55Z",
          "updatedAt": "2021-01-27T13:15:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton we're now at 8 bytes :-) ",
          "createdAt": "2021-01-26T18:57:28Z",
          "updatedAt": "2021-01-26T18:57:28Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Just to put a fine point on this: the spec SHOULD NOT require that implementations support trial decryption. In particular, we ought to ensure that, with high probability, configuration identifiers don't collide. A one-byte, randomly-generated identifier would make collisions inevitable, meaning that implementations will have to support trial decryption.\r\n\r\nI don't think one-byte necessary collides. First, note that the number of configs a server needs to have at a time is relatively small. Past the config's DNS TTL, you can retire it. That means you only need O(dns_ttl / time_between_rotation) configs at once. (From #177, I think the exact value is 1 + ceil(dns_ttl / time_between_rotation). Maybe add a little bit of leeway for people using stale DNS caches, though note we have a recovery flow so you only need to cover most, not all, of stale caches.) This means we don't need to worry about that many values.\r\n\r\nAdditionally, everything here is server-allocated. Whether you're worried about a birthday bound depends on how you allocate IDs. If it's random, you have a birthday bound, yes. If you cycle through a counter, you get the full range. (Compare how QUIC and DTLS 1.3 only send the low-order bits of the epoch.) If it's random, but you check for duplicates at key issuance, you also get the full range.\r\n\r\nThe counters or duplicate checks are trickier to issue, of course, though you can implement the trial decryption as a safety net. As of #344, the trial decryption and config_id modes are already unified. Specifically, decryption failure falls back to the outer ClientHello.",
          "createdAt": "2021-01-26T21:19:58Z",
          "updatedAt": "2021-01-26T21:19:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with everything you said, but want to drill in on this:\r\n\r\n> The counters or duplicate checks are trickier to issue, of course, though you can implement the trial decryption as a safety net. As of #344, the trial decryption and config_id modes are already unified. Specifically, decryption failure falls back to the outer ClientHello.\r\n\r\nThis seems to be key. I agree that the fallback case is clear and well understood, though one consideration is the case wherein a client attempts GREASE to a server that actually supports ECH. The probability of collision in that scenario is high, and if that scenario happens often, then decryption failure and fallback to the outer CH happens quite regularly. Bumping the length back to eight bytes removes the collision probability for that scenario, I think. \r\n\r\nI'd like to propose we treat the two problems here separately. That is, let's first see if we can land the key ID change (from a client-computed hash to a server-selected ID). And then let's see if we can safely make that ID smaller in size. I don't think we need to address both here. Would that work?",
          "createdAt": "2021-01-26T22:46:03Z",
          "updatedAt": "2021-01-26T22:46:03Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the only thing that pushes toward a larger identifier space for me is the risk of grease colliding with an active key.  I agree with David, that your likely number of keys is ~2 (I might go as high as 4 if the server is in an extended period of offering two types of KEM).  With a one-byte identifier, that's only 1/64 greased sessions hitting the expensive decryption code.\r\n\r\nFlexibility here seems appealing, but I'm not sure that this is a place that needs it.  Operationally, this seems very much dependent on centralization, so I'm not buying any story based on loose coordination.  I also note that very small spaces reduce the options servers have for targeted tracking through the use of keys (though it is impossible to eliminate tracking, small spaces make the cost higher to operate tracking at any reasonable scale).\r\n\r\nThat is why I was motivated to go as low as 1 byte.  If you prefer a much lower probability of having to deal with failed decryption in response to greasing, then 2 bytes gets that down to lower than your likely failed connection rate at 1/16k.",
          "createdAt": "2021-01-27T05:40:18Z",
          "updatedAt": "2021-01-27T05:43:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> With a one-byte identifier, that's only 1/64 greased sessions hitting the expensive decryption code.\r\n\r\nIndeed, this is why I propose we separate these issues. Specifically, let's use this PR to land the server-chosen key ID, and then make it smaller (as needed) in a followup change. (Personally, I'm fine with one, two, or four bytes here, as I think the decryption failure case is unavoidable.) I'll file an issue for the size of the ID in a bit.\r\n\r\n@davidben, @martinthomson, @ekr, @cjpatton: what say you? :-)",
          "createdAt": "2021-01-27T13:06:38Z",
          "updatedAt": "2021-01-27T14:07:39Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Happy to have the identifier discussion separately. It is unfortunately not important or clear enough to lead to easy agreement. I can live with any outcome.\r\n\r\nDitto.",
          "createdAt": "2021-01-29T18:28:51Z",
          "updatedAt": "2021-01-29T18:28:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NTkyNTI0",
          "commit": {
            "abbreviatedOid": "15d8adb"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "If we're going to use a single byte to identify an ECH config, then we should choose the byte deterministically. But because this may complicate greasing (the grease client needs to know the procedure by which identities are chosen), my preference would be to randomly generate it. But in order to minimize the collision probability, we ought to stick with the current length of 8 bytes.",
          "createdAt": "2021-01-26T17:33:09Z",
          "updatedAt": "2021-01-26T17:55:38Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Why this name change?",
              "createdAt": "2021-01-26T17:33:09Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 14,
              "body": "IMO it's a bit tidier to have `cipher_suites` immediately precede the `kem_id`.",
              "createdAt": "2021-01-26T17:37:01Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 163,
              "body": "Whether this sticks out depends on how the real `key_id` is chosen. If chosen randomly then we're golden. However the chance of two randomly chosen key ids colliding is high.",
              "createdAt": "2021-01-26T17:48:58Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 53,
              "body": "Why `key_id` instead of `config_id`? The new name sounds as if it should be possible to have a single key used by multiple configs, but what we actually want is a handle with which the server can resolve which config to use.",
              "createdAt": "2021-01-26T17:51:14Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjEyOTgy",
          "commit": {
            "abbreviatedOid": "15d8adb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T17:56:39Z",
          "updatedAt": "2021-01-26T17:56:40Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I don't have a strong feeling here. I think the only important bit is that the kem_id precedes the public key.",
              "createdAt": "2021-01-26T17:56:39Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjEzMjcw",
          "commit": {
            "abbreviatedOid": "15d8adb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T17:56:59Z",
          "updatedAt": "2021-01-26T17:56:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It seems to capture the intent of the struct better.",
              "createdAt": "2021-01-26T17:56:59Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjE0NTU2",
          "commit": {
            "abbreviatedOid": "15d8adb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T17:58:24Z",
          "updatedAt": "2021-01-26T17:58:24Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Since the identifier corresponds primarily to the HPKE public key, and not the public name et al. (If we lifted the key_id *out* of the HpkeKeyConfig, I think config_id would be better.)",
              "createdAt": "2021-01-26T17:58:24Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2Njg3NTk5",
          "commit": {
            "abbreviatedOid": "513617a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I believe that `key_id` should be a U8-prefixed string, just like `config_id` was. The spec currently allows for implementations to send an empty `ClientECH.config_id`, e.g., in \"local discovery mode\" (https://tools.ietf.org/html/draft-ietf-tls-esni-09#section-7.1).",
          "createdAt": "2021-01-26T19:27:01Z",
          "updatedAt": "2021-01-26T22:47:16Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "SHOULD instead of MAY?",
              "createdAt": "2021-01-26T19:28:03Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 14,
              "body": "My thinking is that we should minimize changes to the ECHConfig structure, since the less changes we make the easier it will be to support multiple versions. Concretely, I would revert changes that re-order parameter unless there's a compelling reason to reorder them.",
              "createdAt": "2021-01-26T19:29:31Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 53,
              "body": "Perhaps another way to resolve this would be to change `key_id` to simply `id`. The `key_` prefix seems a bit redundant.",
              "createdAt": "2021-01-26T22:32:44Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 154,
              "body": "Like we did for config_id, we could avoid re-transmitting the key_id by changing its type to a U8-prefixed string. IIRC there were upsides to not re-transmitting config_id.",
              "createdAt": "2021-01-26T22:42:21Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2OTk4MzQ2",
          "commit": {
            "abbreviatedOid": "513617a"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T05:38:49Z",
          "updatedAt": "2021-01-27T05:38:49Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Any change is a change and they are all equally not-free, so minimizing changes is not a goal I would worry about.  In terms of ordering, I prefer what @chris-wood proposed.",
              "createdAt": "2021-01-27T05:38:49Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3MzE2NzE5",
          "commit": {
            "abbreviatedOid": "513617a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T13:09:27Z",
          "updatedAt": "2021-01-27T13:09:28Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "We could do that, but then ClientECH would either have an inconsistently named field (key_id) or an ambiguously named field (id). I'd prefer to keep key_id, but in the interest of minimizing changes in this PR, I'll revert to config_id.",
              "createdAt": "2021-01-27T13:09:27Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3MzIzNDg5",
          "commit": {
            "abbreviatedOid": "2aa42e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T13:17:26Z",
          "updatedAt": "2021-01-27T13:17:26Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "One upside is that the server doesn't have to check them for equality against HRR, but there's already a check for the cipher_suite field, so this seems like not a stretch.",
              "createdAt": "2021-01-27T13:17:26Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3MzI1Njc4",
          "commit": {
            "abbreviatedOid": "2aa42e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T13:19:57Z",
          "updatedAt": "2021-01-27T13:19:57Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "That would align this with GREASE, which seems like a fine thing to do. (That is, in both GREASE and optional configs, the ID would be random.)",
              "createdAt": "2021-01-27T13:19:57Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3MzY5NDQz",
          "commit": {
            "abbreviatedOid": "766001f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T14:06:41Z",
          "updatedAt": "2021-01-27T14:06:42Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "I reverted this change, too. It's now length prefixed so the HRR case is empty. We can discuss the size of the ID in a separate issue.",
              "createdAt": "2021-01-27T14:06:42Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3MzcyMTg2",
          "commit": {
            "abbreviatedOid": "766001f"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM but I would split out the technical change from the refactor of the structures.",
          "createdAt": "2021-01-27T14:09:21Z",
          "updatedAt": "2021-01-27T14:10:48Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "So when is empty valid?",
              "createdAt": "2021-01-27T14:09:21Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 96,
              "body": "```suggestion\r\n: The ECHConfigContents.key_config.config_id for the chosen ECHConfig.\r\n```",
              "createdAt": "2021-01-27T14:10:27Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NTQ0OTQ0",
          "commit": {
            "abbreviatedOid": "766001f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T16:47:45Z",
          "updatedAt": "2021-01-27T16:47:46Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Why change the wire format of the ECH extension? We might end up changing the type of `config_id` anyway, in which case the point is moot. However, for now, I think we should keep the extension parameters in the same order.",
              "createdAt": "2021-01-27T16:47:45Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NTU2OTE3",
          "commit": {
            "abbreviatedOid": "3fa9d47"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T16:59:35Z",
          "updatedAt": "2021-01-27T16:59:35Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Reverted!",
              "createdAt": "2021-01-27T16:59:35Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NTU3NjAz",
          "commit": {
            "abbreviatedOid": "3fa9d47"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T17:00:14Z",
          "updatedAt": "2021-01-27T17:00:15Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "It's always valid, I think. The server will just have to do trial decryption.",
              "createdAt": "2021-01-27T17:00:14Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3ODgwMTY3",
          "commit": {
            "abbreviatedOid": "3fa9d47"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T00:06:53Z",
          "updatedAt": "2021-01-28T00:06:53Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "An empty identifier is just one possible value in the space.  It doesn't mean that other configurations aren't identified by non-empty identifiers.",
              "createdAt": "2021-01-28T00:06:53Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3ODgwOTEy",
          "commit": {
            "abbreviatedOid": "3fa9d47"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Happy to have the identifier discussion separately.  It is unfortunately not important or clear enough to lead to easy agreement.  I can live with any outcome.",
          "createdAt": "2021-01-28T00:08:40Z",
          "updatedAt": "2021-01-28T00:08:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3OTEwNTY2",
          "commit": {
            "abbreviatedOid": "3fa9d47"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T01:13:01Z",
          "updatedAt": "2021-01-28T01:13:01Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "I believe this change needs to be reverted as well. From {#client-hrr}:\r\n\r\n> The client then modifies the \"encrypted_client_hello\" extension in ClientHelloOuter as follows:\r\n> \r\n>   - **config_id is replaced with the empty string.**\r\n>   - cipher_suite is unchanged and contains the client's chosen HPKE cipher suite.\r\n>   - enc is replaced with the empty string.\r\n>   - payload is replaced with the value computed above.\r\n",
              "createdAt": "2021-01-28T01:13:01Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3OTEyNzQw",
          "commit": {
            "abbreviatedOid": "24aebee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T01:18:17Z",
          "updatedAt": "2021-01-28T01:18:17Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "Fixed.",
              "createdAt": "2021-01-28T01:18:17Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3OTE2OTE1",
          "commit": {
            "abbreviatedOid": "6c67b9f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "One little nit then -> LGTM.",
          "createdAt": "2021-01-28T01:29:20Z",
          "updatedAt": "2021-01-28T01:31:05Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "nit: missing semicolon `;`",
              "createdAt": "2021-01-28T01:29:20Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3OTE4NDA1",
          "commit": {
            "abbreviatedOid": "6c67b9f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T01:33:20Z",
          "updatedAt": "2021-01-28T01:33:20Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "```suggestion\r\n       opaque config_id<0..255>;\r\n```",
              "createdAt": "2021-01-28T01:33:20Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzA1NTE5",
          "commit": {
            "abbreviatedOid": "2d2e514"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T19:04:33Z",
          "updatedAt": "2021-02-15T19:06:17Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "It's a little goofy to have the config_id apply to the whole thing here, but I suppose it's inlined.",
              "createdAt": "2021-02-15T19:04:33Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 146,
              "body": "What I'm saying here is that we have a way to indicate the identifier is optional, and that's to have it be 8 random bytes. So when would you use empty?",
              "createdAt": "2021-02-15T19:05:50Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 18,
              "body": "I think we at least need a comment here to explain that.",
              "createdAt": "2021-02-15T19:06:14Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzA2Nzk5",
          "commit": {
            "abbreviatedOid": "2d2e514"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T19:07:47Z",
          "updatedAt": "2021-02-15T19:07:47Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Can you suggest text?",
              "createdAt": "2021-02-15T19:07:47Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzA3MjQ0",
          "commit": {
            "abbreviatedOid": "2d2e514"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T19:08:52Z",
          "updatedAt": "2021-02-15T19:08:52Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Whenever the application wants it, I suppose? We're just recommending that these be random when optional. As Martin says, they don't need to be. Can you propose text if you think something else needs to be said here?",
              "createdAt": "2021-02-15T19:08:52Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzA3NTM4",
          "commit": {
            "abbreviatedOid": "2d2e514"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T19:09:44Z",
          "updatedAt": "2021-02-15T19:11:42Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I think we should forbid the empty identifier.",
              "createdAt": "2021-02-15T19:09:44Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nwith the HPKE public key. Note that this structure contains the `config_id` field, which applies to the\r\nentire ECHConfigContents. Sites MUST NOT publish two differet`ECHConfigContents` values with the same\r\n`HpkeKeyConfig` value.\r\n```",
              "createdAt": "2021-02-15T19:11:25Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzA4Nzc4",
          "commit": {
            "abbreviatedOid": "2d2e514"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T19:13:00Z",
          "updatedAt": "2021-02-15T19:13:01Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I'd like to not do anything here, especially given #379, wherein we move from a vector to a `uint`. Would that be OK?",
              "createdAt": "2021-02-15T19:13:01Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 377,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY2NDE0ODQx",
      "title": "Remove some more remnants of ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/377",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The reference to \"retry keys\" comes from when the field was called\r\nretry_keys and the type ESNIKeys. We've since renamed them to\r\nretry_config and ECHConfig, so the prose should match.",
      "createdAt": "2021-02-02T23:55:31Z",
      "updatedAt": "2021-02-03T16:50:21Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ee94206ba488d702a9acae30386875e14a5bb2a7",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "retry-config-naming",
      "headRefOid": "ad6acf8d783c9d3b39f650160196dc1b3bd5bce9",
      "closedAt": "2021-02-03T16:50:21Z",
      "mergedAt": "2021-02-03T16:50:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f77361979f03b3df295773accbdb4910e6967a40"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgxOTQ3NDI3",
          "commit": {
            "abbreviatedOid": "1df4a26"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-03T02:08:33Z",
          "updatedAt": "2021-02-03T02:08:33Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Nit: s/the both/both/",
              "createdAt": "2021-02-03T02:08:33Z",
              "updatedAt": "2021-02-03T15:41:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyNTAzMTI4",
          "commit": {
            "abbreviatedOid": "1df4a26"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-03T15:41:07Z",
          "updatedAt": "2021-02-03T15:41:08Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Huh, that's new. I fixed it in https://github.com/davidben/draft-ietf-tls-esni/tree/retry-config-naming, but GitHub doesn't seem to have noticed. Hopefully it's just some weird slowness on their end and the PR will notice sooner or later?",
              "createdAt": "2021-02-03T15:41:07Z",
              "updatedAt": "2021-02-03T15:41:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyNTAzNjk1",
          "commit": {
            "abbreviatedOid": "ad6acf8"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-03T15:41:38Z",
          "updatedAt": "2021-02-03T15:41:39Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Okay, now it's noticed. Done.",
              "createdAt": "2021-02-03T15:41:39Z",
              "updatedAt": "2021-02-03T15:41:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyNTc2OTE4",
          "commit": {
            "abbreviatedOid": "ad6acf8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-03T16:50:15Z",
          "updatedAt": "2021-02-03T16:50:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 381,
      "id": "MDExOlB1bGxSZXF1ZXN0NTczNzUzNDM0",
      "title": "Truncate the config_id to a single byte.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/381",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #379.\r\n\r\ncc @davidben, @martinthomson, @cjpatton, @cbartle891, @ekr ",
      "createdAt": "2021-02-15T19:28:35Z",
      "updatedAt": "2021-03-08T16:47:16Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "caw/config_id-to-key_id",
      "baseRefOid": "ce8a04539acf0655a87ed57aa422c795aa8c6fd6",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/short-id",
      "headRefOid": "85db0c01e55e72c782dbfce9e5841c71bdb349b0",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM based on the discussion.",
          "createdAt": "2021-03-08T16:46:51Z",
          "updatedAt": "2021-03-08T16:46:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzUxNDA3",
          "commit": {
            "abbreviatedOid": "3daa28a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good to me, though I think we should weaken \"config_id MUST be unique\"  to \"config_id SHOULD be unique\", since this seems impossible to enforce. (This comment pertains to the previous PR, unfortunately, but we could fix it here.)",
          "createdAt": "2021-02-15T21:04:28Z",
          "updatedAt": "2021-02-15T21:09:16Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "\"MUST NOT\" -> \"SHOULD NOT\"? This sounds like it could be hard to enforce.",
              "createdAt": "2021-02-15T21:04:29Z",
              "updatedAt": "2021-02-16T13:42:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzY1OTY1",
          "commit": {
            "abbreviatedOid": "3daa28a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T21:37:58Z",
          "updatedAt": "2021-02-15T21:37:58Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Who are you thinking might enforce this? Clients? (I definitely don't feel strongly about the choice of word here.) ",
              "createdAt": "2021-02-15T21:37:58Z",
              "updatedAt": "2021-02-16T13:42:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzY3MjQ2",
          "commit": {
            "abbreviatedOid": "3daa28a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-15T21:40:33Z",
          "updatedAt": "2021-02-15T21:40:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzg3OTUy",
          "commit": {
            "abbreviatedOid": "3daa28a"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-15T22:43:10Z",
          "updatedAt": "2021-02-15T22:44:45Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nThis process is repeated if this config_id matches that of any valid ECHConfig, which\r\ncould include any ECHConfig that has been recently removed from active use.\r\n```\r\n\r\n... or something along those lines.  I suspect that operations will want to avoid collisions over slightly longer timescales.",
              "createdAt": "2021-02-15T22:43:10Z",
              "updatedAt": "2021-02-16T13:42:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxNjIzNTM2",
          "commit": {
            "abbreviatedOid": "85db0c0"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-16T21:04:40Z",
          "updatedAt": "2021-02-16T21:04:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2NDkxNzUz",
          "commit": {
            "abbreviatedOid": "85db0c0"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-08T16:47:16Z",
          "updatedAt": "2021-03-08T16:47:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 382,
      "id": "MDExOlB1bGxSZXF1ZXN0NTczODAyNzQ2",
      "title": "Clarify \"don't stick out\" considerations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/382",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR aims to resolve the discussion in issue #354 by:\r\n\r\n1. clarifying goals/non-goals for \"don't stick out\"; and\r\n2. creating a TODO for a future experiment that assesses the deployability of the GREASE extension.\r\n\r\nDealing with PSK sticking out has been assigned to #384.",
      "createdAt": "2021-02-15T21:35:45Z",
      "updatedAt": "2021-03-05T19:10:48Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "c1a3d71f20f6fa69da00fa5ee7fa1a11abc291de",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "dont-stick-out",
      "headRefOid": "30e22a2d4096854138fee6d6852c2445994e4060",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzY5MTQ0",
          "commit": {
            "abbreviatedOid": "fc1c47c"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T21:45:54Z",
          "updatedAt": "2021-02-15T21:45:54Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Is this an open issue in the sense that the data from that experiment needs to be in this draft? If not, I'm not sure it should be mentioned here.\r\n\r\nEDIT: Never mind, I see that you mention the experiment later. This seems like material for a different draft? Like, about the ramifications of implementations? Or rationale for the design?",
              "createdAt": "2021-02-15T21:45:54Z",
              "updatedAt": "2021-02-18T19:58:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzczMDc5",
          "commit": {
            "abbreviatedOid": "fc1c47c"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-15T21:56:46Z",
          "updatedAt": "2021-02-15T21:56:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxNzA3NjQz",
          "commit": {
            "abbreviatedOid": "fc1c47c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I have only a couple of small nits, but overall this is really nice! Thanks for writing it up, and for marking next steps for the protocol deployment.",
          "createdAt": "2021-02-16T23:19:49Z",
          "updatedAt": "2021-02-16T23:25:24Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "This isn't clear to me. I'd just leave this as an open issue without a decision one way or the other.\r\n\r\n```suggestion\r\n   #<new issue ID>, this may be mitigated with a future change.]]\r\n```",
              "createdAt": "2021-02-16T23:19:49Z",
              "updatedAt": "2021-02-18T19:58:15Z"
            },
            {
              "originalPosition": 117,
              "body": "```suggestion\r\nwhether the attacker is passive or active (see {{goals}}).\r\n```\r\n\r\nI'd suggest dropping this unless we can point to some evidence. Maybe @davidben has one?",
              "createdAt": "2021-02-16T23:20:32Z",
              "updatedAt": "2021-02-18T19:58:15Z"
            },
            {
              "originalPosition": 93,
              "body": "I think the point is that we will first run an experiment -- before this document is published as an RFC -- and then update this text with the results. Perhaps this helps?\r\n\r\n```suggestion\r\nthe protocol and measuring its impact. [[TODO: Document results from preliminary experiment that\r\n```",
              "createdAt": "2021-02-16T23:23:00Z",
              "updatedAt": "2021-02-18T19:58:15Z"
            },
            {
              "originalPosition": 7,
              "body": "Let's revert this. We don't yet have consensus as to whether or not we want (or need) to mitigate this particular differentiator. (Please also file a separate issue focused specifically on this issue that we can use to track discussion!)",
              "createdAt": "2021-02-16T23:24:04Z",
              "updatedAt": "2021-02-18T19:58:15Z"
            },
            {
              "originalPosition": 7,
              "body": "(#354 seems too generic to be useful for converging on consensus here, I think.)",
              "createdAt": "2021-02-16T23:24:46Z",
              "updatedAt": "2021-02-18T19:58:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyMzQzMTI4",
          "commit": {
            "abbreviatedOid": "fc1c47c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T15:49:52Z",
          "updatedAt": "2021-02-17T15:49:52Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Yup, that's what I mean!",
              "createdAt": "2021-02-17T15:49:52Z",
              "updatedAt": "2021-02-18T19:58:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTg0ODM1",
          "commit": {
            "abbreviatedOid": "fc1c47c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T19:44:38Z",
          "updatedAt": "2021-02-18T19:44:38Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "There are some amazing examples [here](https://mailarchive.ietf.org/arch/msg/tls/i9blmvG2BEPf1s1OJkenHknRw9c/):\r\n> We found that Firepower middleboxes in \"Decrypt - Resign\" mode\r\nterminate TLS connections, but do not send a compliant ClientHello:\r\nThey modify the original ClientHello to remove unknown ciphersuites,\r\nEMS, and NPN, but incorrectly forward most other fields from the\r\noriginal ClientHello, including unknown extensions (supported_versions\r\nand key_shares), and the client random. This breaks TLS 1.3 servers.\r\nAdditionally, these devices forward the server random rather than\r\ngenerating their own (which will break when deploying the TLS 1.3\r\nanti-downgrade feature), and forward unknown signature algorithms\r\n(which will break when deploying, e.g., Ed25519).\r\n",
              "createdAt": "2021-02-18T19:44:38Z",
              "updatedAt": "2021-02-18T19:58:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTg2MTQ3",
          "commit": {
            "abbreviatedOid": "fc1c47c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T19:46:12Z",
          "updatedAt": "2021-02-18T19:46:12Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Done. I also added a reference to #384.",
              "createdAt": "2021-02-18T19:46:12Z",
              "updatedAt": "2021-02-18T19:58:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTkwNTMy",
          "commit": {
            "abbreviatedOid": "0b5bc28"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T19:52:00Z",
          "updatedAt": "2021-02-18T19:52:01Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Can we just cite this email? That would be fine for me!",
              "createdAt": "2021-02-18T19:52:00Z",
              "updatedAt": "2021-02-18T19:58:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTkwNTcx",
          "commit": {
            "abbreviatedOid": "0b5bc28"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-18T19:52:03Z",
          "updatedAt": "2021-02-18T19:52:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTk3MDE1",
          "commit": {
            "abbreviatedOid": "30e22a2"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T20:00:23Z",
          "updatedAt": "2021-02-18T20:00:23Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Cited references in Section D.4 of RFC 8446.",
              "createdAt": "2021-02-18T20:00:23Z",
              "updatedAt": "2021-02-18T20:00:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTA4Mzcx",
          "commit": {
            "abbreviatedOid": "30e22a2"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Hi @cjpatton I think this needs to be trimmed down substantially. In particular, a lot of the sections about formally defining indifferentiability don't really belong here.\r\n\r\nIn addition, I wouldn't frame GREASE as an experimental method. It's a permanent feature.",
          "createdAt": "2021-03-05T18:50:06Z",
          "updatedAt": "2021-03-05T18:56:58Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n({{real-ech}}) without protecting the client hello.\r\n```",
              "createdAt": "2021-03-05T18:50:06Z",
              "updatedAt": "2021-03-05T18:56:58Z"
            },
            {
              "originalPosition": 87,
              "body": "I'm not sure I think of this so much as a measurement thing but rather as an anti-ossification measure.",
              "createdAt": "2021-03-05T18:50:31Z",
              "updatedAt": "2021-03-05T18:56:58Z"
            },
            {
              "originalPosition": 113,
              "body": "I would remove everything between \"This strategy is...\" and here.",
              "createdAt": "2021-03-05T18:52:33Z",
              "updatedAt": "2021-03-05T18:56:58Z"
            },
            {
              "originalPosition": 92,
              "body": "```suggestion\r\nossification is to make the use of GREASE ECH widespread, thus disincentivizing filtering of the ECH extension by passive attackers.\r\n```",
              "createdAt": "2021-03-05T18:53:53Z",
              "updatedAt": "2021-03-05T18:56:58Z"
            },
            {
              "originalPosition": 123,
              "body": "I would also remove this paragraph.",
              "createdAt": "2021-03-05T18:54:27Z",
              "updatedAt": "2021-03-05T18:56:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 383,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc0NTk2Nzcy",
      "title": "Clarify privacy risk pertaining to resumption.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/383",
      "state": "MERGED",
      "author": "cbartle891",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #380.\r\n\r\ncc @davidben ",
      "createdAt": "2021-02-17T02:21:32Z",
      "updatedAt": "2021-02-17T20:20:55Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "c1a3d71f20f6fa69da00fa5ee7fa1a11abc291de",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "cdb/privacy-leak-clarification",
      "headRefOid": "23bd6b03319b515b5b6835f56bb77c97181c8cda",
      "closedAt": "2021-02-17T20:20:55Z",
      "mergedAt": "2021-02-17T20:20:55Z",
      "mergedBy": "cbartle891",
      "mergeCommit": {
        "oid": "b7757a11639f4b6ea77d97477ee39c2398dcc9a5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyNDgyODkx",
          "commit": {
            "abbreviatedOid": "23bd6b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM -- thanks!",
          "createdAt": "2021-02-17T18:08:33Z",
          "updatedAt": "2021-02-17T18:08:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyNTkyNzE4",
          "commit": {
            "abbreviatedOid": "23bd6b0"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2021-02-17T20:19:11Z",
          "updatedAt": "2021-02-17T20:19:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 385,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc2NTU4Mzc5",
      "title": "Add note about denial-of-service vulnerability",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/385",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A naive implementation of EncodedClientHelloInner decoding would require\r\na quadratic amount of work, which clients might be able to  exploit to\r\nDoS the server. This adds an implementation note intended to guide\r\nservers to mitigate this problem.\r\n\r\nResolves #378.",
      "createdAt": "2021-02-19T16:05:44Z",
      "updatedAt": "2021-02-23T01:36:40Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b7757a11639f4b6ea77d97477ee39c2398dcc9a5",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "decode-cho-risk",
      "headRefOid": "315fe49aaaa0047a70de8fe64b49c715da1a9e99",
      "closedAt": "2021-02-23T01:36:40Z",
      "mergedAt": "2021-02-23T01:36:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1aa4a2e222c77d1f29cb273ad71e7fcfe890ac53"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc/ @davidben :)",
          "createdAt": "2021-02-19T16:06:03Z",
          "updatedAt": "2021-02-19T16:06:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben let's do that change in a separate PR for now. ",
          "createdAt": "2021-02-23T01:36:36Z",
          "updatedAt": "2021-02-23T01:36:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0NTA3OTg0",
          "commit": {
            "abbreviatedOid": "b0da5cd"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-19T19:41:25Z",
          "updatedAt": "2021-02-19T19:43:14Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Nit: O(N\\*M) and O(N\\*log(M)), since it's not exact? (And since O captures \"in the worst case\", you could probably even omit it then.)",
              "createdAt": "2021-02-19T19:41:25Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            },
            {
              "originalPosition": 14,
              "body": "You want to represent the ClientHelloOuter's extensions this way, not the OuterExtensions, right? OuterExtensions is the structure stored in the outer_extensions extension. (Gosh, so many variations on \"outer\" and \"extensions\"!)",
              "createdAt": "2021-02-19T19:43:10Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0Nzc4Mjc5",
          "commit": {
            "abbreviatedOid": "b0da5cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM pending nits and suggestions from @davidben.",
          "createdAt": "2021-02-20T19:17:18Z",
          "updatedAt": "2021-02-20T19:19:33Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nClientHelloOuter. The naive strategy would require O(N\\*M) comparisons in the worst\r\n```",
              "createdAt": "2021-02-20T19:17:18Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\ncan be improved to O(N\\*log(M)) by sorting the OuterExtensions and using binary\r\n```",
              "createdAt": "2021-02-20T19:17:28Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nexploit this behavior in order to cause excessive work for the server.\r\nThis problem can be mitigated by representing OuterExtensions in a way\r\n```",
              "createdAt": "2021-02-20T19:18:07Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nthat allows it to be searched more quickly. For example, the worst case runtime\r\n```",
              "createdAt": "2021-02-20T19:18:15Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NTM0OTY0",
          "commit": {
            "abbreviatedOid": "b0da5cd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T16:28:01Z",
          "updatedAt": "2021-02-22T16:28:02Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Done.",
              "createdAt": "2021-02-22T16:28:02Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NTM4MTQx",
          "commit": {
            "abbreviatedOid": "b0da5cd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T16:30:52Z",
          "updatedAt": "2021-02-22T16:30:52Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I was thinking it would be better to pre-sort OuterExtensions, since presumably M << N.",
              "createdAt": "2021-02-22T16:30:52Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NTM5OTc1",
          "commit": {
            "abbreviatedOid": "b0da5cd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T16:32:32Z",
          "updatedAt": "2021-02-22T16:32:32Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done, I also added \", possibly making it unavailable.\" (Worth mentioning since it's the goal of the attacker.)",
              "createdAt": "2021-02-22T16:32:32Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NTQxMTU4",
          "commit": {
            "abbreviatedOid": "b0da5cd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T16:33:42Z",
          "updatedAt": "2021-02-22T16:33:42Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "O(M log(M)) instead of O(N log(N)) seems better for sorting.",
              "createdAt": "2021-02-22T16:33:42Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NzI2NTE3",
          "commit": {
            "abbreviatedOid": "315fe49"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, though I guess we should either update it to resolve this other vector, or just make the PR not quite close the issue yet:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/issues/378#issuecomment-782763490\r\n\r\n(This other vector is even more fun because you can make a quadratically-*sized* ClientHello!)",
          "createdAt": "2021-02-22T19:53:05Z",
          "updatedAt": "2021-02-22T19:53:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 390,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc5Mzg0NjMw",
      "title": "Update HPKE (and ECH) versions.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/390",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #387, and also updates the ECH version. I didn't bump the extension codepoint for \"ech_is_inner,\" since that seems harmless. \r\n\r\ncc @davidben, @cjpatton ",
      "createdAt": "2021-02-24T15:20:40Z",
      "updatedAt": "2021-02-24T18:05:13Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1aa4a2e222c77d1f29cb273ad71e7fcfe890ac53",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/update-versions",
      "headRefOid": "8aa95378e039d33b09316725a28a2e04878d63e9",
      "closedAt": "2021-02-24T18:05:13Z",
      "mergedAt": "2021-02-24T18:05:13Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "fe714e011f8541d961b14d8090b0e1809056b36c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3Njg3OTQ4",
          "commit": {
            "abbreviatedOid": "8aa9537"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-24T16:39:36Z",
          "updatedAt": "2021-02-24T16:39:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3NzMzNDcx",
          "commit": {
            "abbreviatedOid": "8aa9537"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Works for me!",
          "createdAt": "2021-02-24T17:22:27Z",
          "updatedAt": "2021-02-24T17:22:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3Nzc0MDc0",
          "commit": {
            "abbreviatedOid": "8aa9537"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-24T18:04:57Z",
          "updatedAt": "2021-02-24T18:04:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 391,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgwOTYzNTYz",
      "title": "s/ECHConfigs/ECHConfigList, for clarity.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/391",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See [the source of confusion](https://github.com/MikeBishop/dns-alt-svc/issues/298).",
      "createdAt": "2021-02-26T16:06:00Z",
      "updatedAt": "2021-03-02T22:30:10Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "fe714e011f8541d961b14d8090b0e1809056b36c",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/s-to-list",
      "headRefOid": "3e2595417121a57545daf6151040b00340bac4cd",
      "closedAt": "2021-03-02T22:30:09Z",
      "mergedAt": "2021-03-02T22:30:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d5113cc41f9f2c52e327ae2b9ab97dfbf04cfaf9"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I figure the precision might help reenforce the path from published structure to client behavior.\r\n\r\nI left this out because I figure there may be cases where there is no \"published\" ECHConfigList. (Maybe the config is baked in the app?)",
          "createdAt": "2021-02-26T16:26:54Z",
          "updatedAt": "2021-02-26T16:26:54Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah fair, that might be too precise. I think it still makes sense for that case to have the baked-in thing be an ECHConfigList than an ECHConfig, just for consistency. (I'm envisioning that ECHConfigList is the \"public API\" for client ECH and your TLS library might just that one byte string as input.)\r\n\r\nHow about s/published/server's/?",
          "createdAt": "2021-02-26T16:34:07Z",
          "updatedAt": "2021-02-26T16:34:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> How about s/published/server's/?\r\n\r\nThat'd work :)",
          "createdAt": "2021-02-26T16:45:13Z",
          "updatedAt": "2021-02-26T16:45:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben done!",
          "createdAt": "2021-02-26T16:50:42Z",
          "updatedAt": "2021-02-26T16:50:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzI1NzYy",
          "commit": {
            "abbreviatedOid": "ccf349e"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T16:14:07Z",
          "updatedAt": "2021-02-26T16:14:07Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Would it be possible to keep the \"set of candidate $X\" phrasing?\r\n\r\nThe phrase \"candidate ECHConfigList\" sounds to me like the whole ECHConfigList is a candidate, not that each element is a candidate. \r\n\r\nPerhaps\r\n\r\n> First, the server collects a set of candidate ECHConfig values.",
              "createdAt": "2021-02-26T16:14:07Z",
              "updatedAt": "2021-02-26T16:50:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzI4ODc3",
          "commit": {
            "abbreviatedOid": "ccf349e"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T16:17:32Z",
          "updatedAt": "2021-02-26T16:17:32Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I think this section should just be \"ECHConfigs\" or \"ECHConfig values\". The server doesn't actually need to serialize them or anything. (Edit: Ah, I see Dan and I crossed mid-air!)\r\n\r\nAlso now that we also have a better word, maybe {{real-ech}} should now be a bit more precise and say something like:\r\n\"To offer ECH, the client first chooses a suitable ECHConfig from the published ECHConfigList.\"",
              "createdAt": "2021-02-26T16:17:32Z",
              "updatedAt": "2021-02-26T16:50:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzMwMTQz",
          "commit": {
            "abbreviatedOid": "ccf349e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T16:18:54Z",
          "updatedAt": "2021-02-26T16:18:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Sure, that works equally well for me!",
              "createdAt": "2021-02-26T16:18:55Z",
              "updatedAt": "2021-02-26T16:50:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzMwNDMy",
          "commit": {
            "abbreviatedOid": "4652d8e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T16:19:14Z",
          "updatedAt": "2021-02-26T16:19:14Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "(See latest change)",
              "createdAt": "2021-02-26T16:19:14Z",
              "updatedAt": "2021-02-26T16:50:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzM1MTg5",
          "commit": {
            "abbreviatedOid": "4652d8e"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks, Chris!",
          "createdAt": "2021-02-26T16:24:34Z",
          "updatedAt": "2021-02-26T16:24:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzM1NDI4",
          "commit": {
            "abbreviatedOid": "4652d8e"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM with one comment that got lost in the mixup. Now that we also have a better word, maybe {{real-ech}} should now be a bit more precise and say something like:\r\n\r\n> To offer ECH, the client first chooses a suitable ECHConfig from the published ECHConfigList.\r\n\r\nI figure the precision might help reenforce the path from published structure to client behavior.",
          "createdAt": "2021-02-26T16:24:49Z",
          "updatedAt": "2021-02-26T16:24:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5ODM2ODU3",
          "commit": {
            "abbreviatedOid": "3e25954"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-26T18:30:40Z",
          "updatedAt": "2021-02-26T18:30:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5ODYxMDgx",
          "commit": {
            "abbreviatedOid": "3e25954"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-02-26T19:04:23Z",
          "updatedAt": "2021-02-26T19:04:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 392,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgzMzk1MTQ0",
      "title": "Add -09 to -10 change log.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/392",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #388. We'll keep this updated moving forward.\r\n\r\ncc @martinthomson, @davidben, @cjpatton ",
      "createdAt": "2021-03-02T22:45:57Z",
      "updatedAt": "2021-03-08T18:54:58Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d5113cc41f9f2c52e327ae2b9ab97dfbf04cfaf9",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/change-log",
      "headRefOid": "da6859a0ba7063def5bf77301a1f014cd0f05003",
      "closedAt": "2021-03-08T18:54:58Z",
      "mergedAt": "2021-03-08T18:54:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "db33d117910bc62026b9efc2eb6fe01254b87cba"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMzcwNDAw",
          "commit": {
            "abbreviatedOid": "da6859a"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-02T23:32:04Z",
          "updatedAt": "2021-03-02T23:32:04Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMzc2MzI4",
          "commit": {
            "abbreviatedOid": "da6859a"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-02T23:43:56Z",
          "updatedAt": "2021-03-02T23:43:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 393,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg1ODA1MDkw",
      "title": "Define HelloRetryRequestInner/Outer messages",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/393",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-05T18:43:35Z",
      "updatedAt": "2021-03-05T18:43:42Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d5113cc41f9f2c52e327ae2b9ab97dfbf04cfaf9",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hrr-inner",
      "headRefOid": "bcb679661d6a96aeddc45391e43c133c3507b3a6",
      "closedAt": "2021-03-05T18:43:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}